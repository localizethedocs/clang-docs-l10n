# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2025, The Clang Team
# This file is distributed under the same license as the Clang package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Clang main\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-13 13:41+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../TypeSanitizer.rst:3
msgid "TypeSanitizer"
msgstr ""

#: ../../../TypeSanitizer.rst:9
msgid "Introduction"
msgstr ""

#: ../../../TypeSanitizer.rst:11
msgid ""
"The TypeSanitizer is a detector for strict type aliasing violations. It "
"consists of a compiler instrumentation module and a run-time library. C/C++ "
"has type-based aliasing rules, and LLVM can exploit these for optimizations "
"given the TBAA metadata Clang emits. In general, a pointer of a given type "
"cannot access an object of a different type, with only a few exceptions."
msgstr ""

#: ../../../TypeSanitizer.rst:16
msgid ""
"These rules aren't always apparent to users, which leads to code that "
"violates these rules (e.g. for type punning). This can lead to optimization "
"passes introducing bugs unless the code is build with ``-fno-strict-"
"aliasing``, sacrificing performance."
msgstr ""

#: ../../../TypeSanitizer.rst:20
msgid ""
"TypeSanitizer is built to catch when these strict aliasing rules have been "
"violated, helping users find where such bugs originate in their code despite "
"the code looking valid at first glance."
msgstr ""

#: ../../../TypeSanitizer.rst:23
msgid ""
"As TypeSanitizer is still experimental, it can currently have a large impact "
"on runtime speed, memory use, and code size. It also has a large compile-"
"time overhead. Work is being done to reduce these impacts."
msgstr ""

#: ../../../TypeSanitizer.rst:28
msgid "The TypeSanitizer Algorithm"
msgstr ""

#: ../../../TypeSanitizer.rst:29
msgid ""
"For each TBAA type-access descriptor, encoded in LLVM IR using TBAA "
"Metadata, the instrumentation pass generates descriptor tables. Thus there "
"is a unique pointer to each type (and access descriptor). These tables are "
"comdat (except for anonymous-namespace types), so the pointer values are "
"unique across the program."
msgstr ""

#: ../../../TypeSanitizer.rst:34
msgid ""
"The descriptors refer to other descriptors to form a type aliasing tree, "
"like how LLVM's TBAA data does."
msgstr ""

#: ../../../TypeSanitizer.rst:37
msgid ""
"The runtime uses 8 bytes of shadow memory, the size of the pointer to the "
"type descriptor, for every byte of accessed data in the program. The first "
"byte of a type will have its shadow memory be set to the pointer to its type "
"descriptor. Aside from that, there are some other values it may be."
msgstr ""

#: ../../../TypeSanitizer.rst:41
msgid "0 is used to represent an unknown type"
msgstr ""

#: ../../../TypeSanitizer.rst:42
msgid ""
"Negative numbers represent an interior byte: A byte inside a type that is "
"not the first one. As an example, a value of -2 means you are in the third "
"byte of a type."
msgstr ""

#: ../../../TypeSanitizer.rst:45
msgid ""
"The Instrumentation first checks for an exact match between the type of the "
"current access and the type for that address in the shadow memory. This can "
"quickly be done by checking pointer values. If it matches, it checks the "
"remaining shadow memory of the type to ensure they are the correct negative "
"numbers. If this fails, it calls the \"slow path\" check. If the exact match "
"fails, we check to see if the value, and the remainder of the shadow bytes, "
"is 0. If they are, we can set the shadow memory to the correct type "
"descriptor pointer for the first byte, and the correct negative numbers for "
"the rest of the type's shadow."
msgstr ""

#: ../../../TypeSanitizer.rst:53
msgid ""
"If the type in shadow memory is neither an exact match nor 0, we call the "
"slower runtime check. It uses the full TBAA algorithm, just as the compiler "
"does, to determine when two types are permitted to alias."
msgstr ""

#: ../../../TypeSanitizer.rst:57
msgid ""
"The instrumentation pass inserts calls to the memset intrinsic to set the "
"memory updated by memset, memcpy, and memmove, as well as allocas/byval (and "
"for lifetime.start/end) to reset the shadow memory to reflect that the type "
"is now unknown. The runtime intercepts memset, memcpy, etc. to perform the "
"same function for the library calls."
msgstr ""

#: ../../../TypeSanitizer.rst:63
msgid "How to build"
msgstr ""

#: ../../../TypeSanitizer.rst:65
msgid ""
"Build LLVM/Clang with `CMake <https://llvm.org/docs/CMake.html>`_ and enable "
"the ``compiler-rt`` runtime. An example CMake configuration that will allow "
"for the use/testing of TypeSanitizer:"
msgstr ""

#: ../../../TypeSanitizer.rst:74
msgid "Usage"
msgstr ""

#: ../../../TypeSanitizer.rst:76
msgid ""
"Compile and link your program with ``-fsanitize=type`` flag. The "
"TypeSanitizer run-time library should be linked to the final executable, so "
"make sure to use ``clang`` (not ``ld``) for the final link step. To get a "
"reasonable performance add ``-O1`` or higher. TypeSanitizer by default "
"doesn't print the full stack trace in error messages. Use "
"``TYSAN_OPTIONS=print_stacktrace=1`` to print the full trace. To get nicer "
"stack traces in error messages add ``-fno-omit-frame-pointer`` and ``-g``.  "
"To get perfect stack traces you may need to disable inlining (just use ``-"
"O1``) and tail call elimination (``-fno-optimize-sibling-calls``)."
msgstr ""

#: ../../../TypeSanitizer.rst:98
msgid ""
"The program will print an error message to ``stderr`` each time a strict "
"aliasing violation is detected. The program won't terminate, which will "
"allow you to detect many strict aliasing violations in one run."
msgstr ""

#: ../../../TypeSanitizer.rst:114
msgid "Error terminology"
msgstr ""

#: ../../../TypeSanitizer.rst:116
msgid ""
"There are some terms that may appear in TypeSanitizer errors that are "
"derived from `TBAA Metadata <https://llvm.org/docs/LangRef.html#tbaa-"
"metadata>`. This section hopes to provide a brief dictionary of these terms."
msgstr ""

#: ../../../TypeSanitizer.rst:120
msgid ""
"``omnipotent char``: This is a special type which can alias with anything. "
"Its name comes from the C/C++ type ``char``."
msgstr ""

#: ../../../TypeSanitizer.rst:122
msgid ""
"``type p[x]``: This signifies pointers to the type. ``x`` is the number of "
"indirections to reach the final value. As an example, a pointer to a pointer "
"to an integer would be ``type p2 int``."
msgstr ""

#: ../../../TypeSanitizer.rst:125
msgid ""
"TypeSanitizer is still experimental. User-facing error messages should be "
"improved in the future to remove references to LLVM IR specific terms."
msgstr ""

#: ../../../TypeSanitizer.rst:129
msgid "Sanitizer features"
msgstr ""

#: ../../../TypeSanitizer.rst:132
msgid "``__has_feature(type_sanitizer)``"
msgstr ""

#: ../../../TypeSanitizer.rst:134
msgid ""
"In some cases one may need to execute different code depending on whether "
"TypeSanitizer is enabled. :ref:`\\_\\_has\\_feature <langext-__has_feature-"
"__has_extension>` can be used for this purpose."
msgstr ""

#: ../../../TypeSanitizer.rst:148
msgid "``__attribute__((no_sanitize(\"type\")))``"
msgstr ""

#: ../../../TypeSanitizer.rst:150
msgid ""
"Some code you may not want to be instrumented by TypeSanitizer.  One may use "
"the function attribute ``no_sanitize(\"type\")`` to disable instrumenting "
"type aliasing. It is possible, depending on what happens in non-instrumented "
"code, that instrumented code emits false-positives/ false-negatives. This "
"attribute may not be supported by other compilers, so we suggest to use it "
"together with ``__has_feature(type_sanitizer)``."
msgstr ""

#: ../../../TypeSanitizer.rst:157
msgid "``__attribute__((disable_sanitizer_instrumentation))``"
msgstr ""

#: ../../../TypeSanitizer.rst:159
msgid ""
"The ``disable_sanitizer_instrumentation`` attribute can be applied to "
"functions to prevent all kinds of instrumentation. As a result, it may "
"introduce false positives and incorrect stack traces. Therefore, it should "
"be used with care, and only if absolutely required; for example for certain "
"code that cannot tolerate any instrumentation and resulting side-effects. "
"This attribute overrides ``no_sanitize(\"type\")``."
msgstr ""

#: ../../../TypeSanitizer.rst:167
msgid "Ignorelist"
msgstr ""

#: ../../../TypeSanitizer.rst:169
msgid ""
"TypeSanitizer supports ``src`` and ``fun`` entity types in :doc:"
"`SanitizerSpecialCaseList`, that can be used to suppress aliasing violation "
"reports in the specified source files or functions. Like with other methods "
"of ignoring instrumentation, this can result in false positives/ false-"
"negatives."
msgstr ""

#: ../../../TypeSanitizer.rst:176
msgid "Limitations"
msgstr ""

#: ../../../TypeSanitizer.rst:178
msgid ""
"TypeSanitizer uses more real memory than a native run. It uses 8 bytes of "
"shadow memory for each byte of user memory."
msgstr ""

#: ../../../TypeSanitizer.rst:180
msgid ""
"There are transformation passes which run before TypeSanitizer. If these "
"passes optimize out an aliasing violation, TypeSanitizer cannot catch it."
msgstr ""

#: ../../../TypeSanitizer.rst:182
msgid ""
"Currently, all instrumentation is inlined. This can result in a **15x** (on "
"average) increase in generated file size, and **3x** to **7x** increase in "
"compile time. In some documented cases this can cause the compiler to hang. "
"There are plans to improve this in the future."
msgstr ""

#: ../../../TypeSanitizer.rst:186
msgid ""
"Codebases that use unions and struct-initialized variables can see incorrect "
"results, as TypeSanitizer doesn't yet instrument these reliably."
msgstr ""

#: ../../../TypeSanitizer.rst:188
msgid ""
"Since Clang & LLVM's TBAA system is used to generate the checks used by the "
"instrumentation, TypeSanitizer follows Clang & LLVM's rules for type "
"aliasing. There may be situations where that disagrees with the standard. "
"However this does at least mean that TypeSanitizer will catch any aliasing "
"violations that would cause bugs when compiling with Clang & LLVM."
msgstr ""

#: ../../../TypeSanitizer.rst:193
msgid ""
"TypeSanitizer cannot currently be run alongside other sanitizers such as "
"AddressSanitizer, ThreadSanitizer or UndefinedBehaviourSanitizer."
msgstr ""

#: ../../../TypeSanitizer.rst:197
msgid "Current Status"
msgstr ""

#: ../../../TypeSanitizer.rst:199
msgid ""
"TypeSanitizer is brand new, and still in development. There are some known "
"issues, especially in areas where Clang's emitted TBAA data isn't extensive "
"enough for TypeSanitizer's runtime."
msgstr ""

#: ../../../TypeSanitizer.rst:203
msgid ""
"We are actively working on enhancing the tool --- stay tuned.  Any help, "
"issues, pull requests, ideas, is more than welcome. You can find the `issue "
"tracker here. <https://github.com/llvm/llvm-project/issues?"
"q=is%3Aissue%20state%3Aopen%20TySan%20label%3Acompiler-rt%3Atysan>`_"
msgstr ""
