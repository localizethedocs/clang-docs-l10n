# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2025, The Clang Team
# This file is distributed under the same license as the Clang package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Clang main\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-13 13:41+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../OffloadingDesign.rst:3
msgid "Offloading Design & Internals"
msgstr ""

#: ../../../OffloadingDesign.rst:9
msgid "Introduction"
msgstr ""

#: ../../../OffloadingDesign.rst:11
msgid ""
"This document describes the Clang driver and code generation steps for "
"creating offloading applications. Clang supports offloading to various "
"architectures using programming models like CUDA, HIP, and OpenMP. The "
"purpose of this document is to illustrate the steps necessary to create an "
"offloading application using Clang."
msgstr ""

#: ../../../OffloadingDesign.rst:18
msgid "OpenMP Offloading"
msgstr ""

#: ../../../OffloadingDesign.rst:20
msgid ""
"Clang supports OpenMP target offloading to several different architectures "
"such as NVPTX, AMDGPU, X86_64, Arm, and PowerPC. Offloading code is "
"generated by Clang and then executed using the ``libomptarget`` runtime and "
"the associated plugin for the target architecture, e.g. ``libomptarget.rtl."
"cuda``. This section describes the steps necessary to create a functioning "
"device image that can be loaded by the OpenMP runtime.  More information on "
"the OpenMP runtimes can be found at the `OpenMP documentation page <https://"
"openmp.llvm.org>`__."
msgstr ""

#: ../../../OffloadingDesign.rst:31
msgid "Offloading Overview"
msgstr ""

#: ../../../OffloadingDesign.rst:33
msgid ""
"The goal of offloading compilation is to create an executable device image "
"that can be run on the target device. OpenMP offloading creates executable "
"images by compiling the input file for both the host and the target device. "
"The output from the device phase then needs to be embedded into the host to "
"create a fat object. A special tool then needs to extract the device code "
"from the fat objects, run the device linking step, and embed the final image "
"in a symbol the host runtime library can use to register the library and "
"access the symbols on the device."
msgstr ""

#: ../../../OffloadingDesign.rst:43
msgid "Compilation Process"
msgstr ""

#: ../../../OffloadingDesign.rst:45
msgid ""
"The compiler performs the following high-level actions to generate OpenMP "
"offloading code:"
msgstr ""

#: ../../../OffloadingDesign.rst:48
msgid ""
"Compile the input file for the host to produce a bitcode file. Lower "
"``#pragma omp target`` declarations to :ref:`offloading entries <Generating "
"Offloading Entries>` and create metadata to indicate which entries are on "
"the device."
msgstr ""

#: ../../../OffloadingDesign.rst:51
msgid ""
"Compile the input file for the target :ref:`device <Device Compilation>` "
"using the :ref:`offloading entry <Generating Offloading Entries>` metadata "
"created by the host."
msgstr ""

#: ../../../OffloadingDesign.rst:54
msgid ""
"Link the OpenMP device runtime library and run the backend to create a "
"device object file."
msgstr ""

#: ../../../OffloadingDesign.rst:56
msgid ""
"Run the backend on the host bitcode file and create a :ref:`fat object file "
"<Creating Fat Objects>` using the device object file."
msgstr ""

#: ../../../OffloadingDesign.rst:58
msgid ""
"Pass the fat object file to the :ref:`linker wrapper tool <Device Linking>` "
"and extract the device objects. Run the device linking action on the "
"extracted objects."
msgstr ""

#: ../../../OffloadingDesign.rst:61
msgid ""
":ref:`Wrap <Device Binary Wrapping>` the :ref:`device images <Device "
"linking>` and :ref:`offload entries <Generating Offloading Entries>` in a "
"symbol that can be accessed by the host."
msgstr ""

#: ../../../OffloadingDesign.rst:64
msgid ""
"Add the :ref:`wrapped binary <Device Binary Wrapping>` to the linker input "
"and run the host linking action. Link with ``libomptarget`` to register and "
"execute the images."
msgstr ""

#: ../../../OffloadingDesign.rst:71
msgid "Generating Offloading Entries"
msgstr ""

#: ../../../OffloadingDesign.rst:73
msgid ""
"The first step in compilation is to generate offloading entries for the "
"host. This information is used to identify function kernels or global values "
"that will be provided by the device. Blocks contained in a ``#pragma omp "
"target`` or symbols inside a ``#pragma omp declare target`` directive will "
"have offloading entries generated. The following table shows the :ref:"
"`offload entry structure <table-tgt_offload_entry_structure>`."
msgstr ""

#: ../../../OffloadingDesign.rst:80
msgid "__tgt_offload_entry Structure"
msgstr ""

#: ../../../OffloadingDesign.rst:84 ../../../OffloadingDesign.rst:169
#: ../../../OffloadingDesign.rst:295 ../../../OffloadingDesign.rst:313
#: ../../../OffloadingDesign.rst:335
msgid "Type"
msgstr ""

#: ../../../OffloadingDesign.rst:84 ../../../OffloadingDesign.rst:169
#: ../../../OffloadingDesign.rst:295 ../../../OffloadingDesign.rst:313
msgid "Identifier"
msgstr ""

#: ../../../OffloadingDesign.rst:84 ../../../OffloadingDesign.rst:107
#: ../../../OffloadingDesign.rst:124 ../../../OffloadingDesign.rst:169
#: ../../../OffloadingDesign.rst:244 ../../../OffloadingDesign.rst:295
#: ../../../OffloadingDesign.rst:313 ../../../OffloadingDesign.rst:335
msgid "Description"
msgstr ""

#: ../../../OffloadingDesign.rst:86 ../../../OffloadingDesign.rst:297
#: ../../../OffloadingDesign.rst:299
msgid "void*"
msgstr ""

#: ../../../OffloadingDesign.rst:86
msgid "addr"
msgstr ""

#: ../../../OffloadingDesign.rst:86
msgid "Address of global symbol within device image (function or global)"
msgstr ""

#: ../../../OffloadingDesign.rst:88 ../../../OffloadingDesign.rst:179
msgid "char*"
msgstr ""

#: ../../../OffloadingDesign.rst:88
msgid "name"
msgstr ""

#: ../../../OffloadingDesign.rst:88
msgid "Name of the symbol"
msgstr ""

#: ../../../OffloadingDesign.rst:90
msgid "size_t"
msgstr ""

#: ../../../OffloadingDesign.rst:90
msgid "size"
msgstr ""

#: ../../../OffloadingDesign.rst:90
msgid "Size of the entry info (0 if it is a function)"
msgstr ""

#: ../../../OffloadingDesign.rst:92 ../../../OffloadingDesign.rst:94
#: ../../../OffloadingDesign.rst:171 ../../../OffloadingDesign.rst:173
#: ../../../OffloadingDesign.rst:175 ../../../OffloadingDesign.rst:177
#: ../../../OffloadingDesign.rst:315
msgid "int32_t"
msgstr ""

#: ../../../OffloadingDesign.rst:92 ../../../OffloadingDesign.rst:173
msgid "flags"
msgstr ""

#: ../../../OffloadingDesign.rst:92
msgid "Flags associated with the entry (see :ref:`table-offload_entry_flags`)"
msgstr ""

#: ../../../OffloadingDesign.rst:94 ../../../OffloadingDesign.rst:171
#: ../../../OffloadingDesign.rst:175 ../../../OffloadingDesign.rst:177
msgid "reserved"
msgstr ""

#: ../../../OffloadingDesign.rst:94 ../../../OffloadingDesign.rst:171
#: ../../../OffloadingDesign.rst:175 ../../../OffloadingDesign.rst:177
msgid "Reserved, to be used by the runtime library."
msgstr ""

#: ../../../OffloadingDesign.rst:97
msgid ""
"The address of the global symbol will be set to the device pointer value by "
"the runtime once the device image is loaded. The flags are set to indicate "
"the handling required for the offloading entry. If the offloading entry is "
"an entry to a target region it can have one of the following :ref:`entry "
"flags <table-offload_entry_flags>`."
msgstr ""

#: ../../../OffloadingDesign.rst:103
msgid "Target Region Entry Flags"
msgstr ""

#: ../../../OffloadingDesign.rst:107 ../../../OffloadingDesign.rst:124
msgid "Name"
msgstr ""

#: ../../../OffloadingDesign.rst:107 ../../../OffloadingDesign.rst:124
msgid "Value"
msgstr ""

#: ../../../OffloadingDesign.rst:109
msgid "OMPTargetRegionEntryTargetRegion"
msgstr ""

#: ../../../OffloadingDesign.rst:109 ../../../OffloadingDesign.rst:126
msgid "0x00"
msgstr ""

#: ../../../OffloadingDesign.rst:109
msgid "Mark the entry as generic target region"
msgstr ""

#: ../../../OffloadingDesign.rst:111
msgid "OMPTargetRegionEntryCtor"
msgstr ""

#: ../../../OffloadingDesign.rst:111
msgid "0x02"
msgstr ""

#: ../../../OffloadingDesign.rst:111
msgid "Mark the entry as a global constructor"
msgstr ""

#: ../../../OffloadingDesign.rst:113
msgid "OMPTargetRegionEntryDtor"
msgstr ""

#: ../../../OffloadingDesign.rst:113
msgid "0x04"
msgstr ""

#: ../../../OffloadingDesign.rst:113
msgid "Mark the entry as a global destructor"
msgstr ""

#: ../../../OffloadingDesign.rst:116
msgid ""
"If the offloading entry is a global variable, indicated by a non-zero size, "
"it will instead have one of the following :ref:`global <table-"
"offload_global_flags>` flags."
msgstr ""

#: ../../../OffloadingDesign.rst:120
msgid "Target Region Global"
msgstr ""

#: ../../../OffloadingDesign.rst:126
msgid "OMPTargetGlobalVarEntryTo"
msgstr ""

#: ../../../OffloadingDesign.rst:126
msgid "Mark the entry as a 'to' attribute (w.r.t. the to clause)"
msgstr ""

#: ../../../OffloadingDesign.rst:128
msgid "OMPTargetGlobalVarEntryLink"
msgstr ""

#: ../../../OffloadingDesign.rst:128
msgid "0x01"
msgstr ""

#: ../../../OffloadingDesign.rst:128
msgid "Mark the entry as a 'link' attribute (w.r.t. the link clause)"
msgstr ""

#: ../../../OffloadingDesign.rst:131
msgid ""
"The target offload entries are used by the runtime to access the device "
"kernels and globals that will be provided by the final device image. Each "
"offloading entry is set to use the ``omp_offloading_entries`` section. When "
"the final application is created the linker will provide the "
"``__start_omp_offloading_entries`` and ``__stop_omp_offloading_entries`` "
"symbols which are used to create the :ref:`final image <Device Binary "
"Wrapping>`."
msgstr ""

#: ../../../OffloadingDesign.rst:138
msgid ""
"This information is used by the device compilation stage to determine which "
"symbols need to be exported from the device. We use the ``omp_offload.info`` "
"metadata node to pass this information device compilation stage."
msgstr ""

#: ../../../OffloadingDesign.rst:143
msgid "Accessing Entries on the Device"
msgstr ""

#: ../../../OffloadingDesign.rst:145
msgid ""
"Accessing the entries in the device is done using the address field in the :"
"ref:`offload entry<table-tgt_offload_entry_structure>`. The runtime will set "
"the address to the pointer associated with the device image during runtime "
"initialization. This is used to call the corresponding kernel function when "
"entering a ``#pragma omp target`` region. For variables, the runtime "
"maintains a table mapping host pointers to device pointers. Global variables "
"inside a ``#pragma omp target declare`` directive are first initialized to "
"the host's address. Once the device address is initialized we insert it into "
"the table to map the host address to the device address."
msgstr ""

#: ../../../OffloadingDesign.rst:156
msgid "Debugging Information"
msgstr ""

#: ../../../OffloadingDesign.rst:158
msgid ""
"We generate structures to hold debugging information that is passed to "
"``libomptarget``. This allows the front-end to generate information the "
"runtime library uses for more informative error messages. This is done using "
"the standard :ref:`identifier structure <table-ident_t_structure>` used in "
"``libomp`` and ``libomptarget``. This is used to pass information and source "
"locations to the runtime."
msgstr ""

#: ../../../OffloadingDesign.rst:165
msgid "ident_t Structure"
msgstr ""

#: ../../../OffloadingDesign.rst:173
msgid "Flags used to indicate some features, mostly unused."
msgstr ""

#: ../../../OffloadingDesign.rst:179
msgid "psource"
msgstr ""

#: ../../../OffloadingDesign.rst:179
msgid ""
"Program source information, stored as \";filename;function;line;column;;\\"
"\\0\""
msgstr ""

#: ../../../OffloadingDesign.rst:182
msgid ""
"If debugging information is enabled, we will also create strings to indicate "
"the names and declarations of variables mapped in target regions. These have "
"the same format as the source location in the :ref:`identifier structure "
"<table-ident_t_structure>`, but the function name is replaced with the "
"variable name."
msgstr ""

#: ../../../OffloadingDesign.rst:191
msgid "Offload Device Compilation"
msgstr ""

#: ../../../OffloadingDesign.rst:193
msgid ""
"The input file is compiled for each active device toolchain. The device "
"compilation stage is performed differently from the host stage. Namely, we "
"do not generate any offloading entries. This is set by passing the ``-"
"fopenmp-is-target-device`` flag to the front-end. We use the host bitcode to "
"determine which symbols to export from the device. The bitcode file is "
"passed in from the previous stage using the ``-fopenmp-host-ir-file-path`` "
"flag. Compilation is otherwise performed as it would be for any other target "
"triple."
msgstr ""

#: ../../../OffloadingDesign.rst:201
msgid ""
"When compiling for the OpenMP device, we set the visibility of all device "
"symbols to be ``protected`` by default. This improves performance and "
"prevents a class of errors where a symbol in the target device could preempt "
"a host library."
msgstr ""

#: ../../../OffloadingDesign.rst:206
msgid ""
"The OpenMP runtime library is linked in during compilation to provide the "
"implementations for standard OpenMP functionality. For GPU targets this is "
"done by linking in a special bitcode library during compilation, (e.g. "
"``libomptarget-nvptx64-sm_70.bc``) using the ``-mlink-builtin-bitcode`` "
"flag. Other device libraries, such as CUDA's libdevice, are also linked this "
"way. If the target is a standard architecture with an existing ``libomp`` "
"implementation, that will be linked instead. Finally, device tools are used "
"to create a relocatable device object file that can be embedded in the host."
msgstr ""

#: ../../../OffloadingDesign.rst:218
msgid "Creating Fat Objects"
msgstr ""

#: ../../../OffloadingDesign.rst:220
msgid ""
"A fat binary is a binary file that contains information intended for another "
"device. We create a fat object by embedding the output of the device "
"compilation stage into the host as a named section. The output from the "
"device compilation is passed to the host backend using the ``-fembed-offload-"
"object`` flag. This embeds the device image into the ``.llvm.offloading`` "
"section using a special binary format that behaves like a string map. This "
"binary format is used to bundle metadata about the image so the linker can "
"associate the proper device linking action with the image. Each device image "
"will start with the magic bytes ``0x10FF10AD``."
msgstr ""

#: ../../../OffloadingDesign.rst:234
msgid ""
"The device code will then be placed in the corresponding section one the "
"backend is run on the host, creating a fat object. Using fat objects allows "
"us to treat offloading objects as standard host objects. The final object "
"file should contain the following :ref:`offloading sections <table-"
"offloading_sections>`. We will use this information when :ref:`Device "
"Linking`."
msgstr ""

#: ../../../OffloadingDesign.rst:240
msgid "Offloading Sections"
msgstr ""

#: ../../../OffloadingDesign.rst:244
msgid "Section"
msgstr ""

#: ../../../OffloadingDesign.rst:246
msgid "omp_offloading_entries"
msgstr ""

#: ../../../OffloadingDesign.rst:246
msgid ""
"Offloading entry information (see :ref:`table-tgt_offload_entry_structure`)"
msgstr ""

#: ../../../OffloadingDesign.rst:248
msgid ".llvm.offloading"
msgstr ""

#: ../../../OffloadingDesign.rst:248
msgid "Embedded device object file for the target device and architecture"
msgstr ""

#: ../../../OffloadingDesign.rst:254
msgid "Linking Target Device Code"
msgstr ""

#: ../../../OffloadingDesign.rst:256
msgid ""
"Objects containing :ref:`table-offloading_sections` require special handling "
"to create an executable device image. This is done using a Clang tool, see :"
"doc:`ClangLinkerWrapper` for more information. This tool works as a wrapper "
"over the host linking job. It scans the input object files for the "
"offloading section ``.llvm.offloading``. The device files stored in this "
"section are then extracted and passed to the appropriate linking job. The "
"linked device image is then :ref:`wrapped <Device Binary Wrapping>` to "
"create the symbols used to load the device image and link it with the host."
msgstr ""

#: ../../../OffloadingDesign.rst:265
msgid ""
"The linker wrapper tool supports linking bitcode files through link time "
"optimization (LTO). This is used whenever the object files embedded in the "
"host contain LLVM bitcode. Bitcode will be embedded for architectures that "
"do not support a relocatable object format, such as AMDGPU or SPIR-V, or if "
"the user requested it using the ``-foffload-lto`` flag."
msgstr ""

#: ../../../OffloadingDesign.rst:274
msgid "Device Binary Wrapping"
msgstr ""

#: ../../../OffloadingDesign.rst:276
msgid ""
"Various structures and functions are used to create the information "
"necessary to offload code on the device. We use the :ref:`linked device "
"executable <Device Linking>` with the corresponding offloading entries to "
"create the symbols necessary to load and execute the device image."
msgstr ""

#: ../../../OffloadingDesign.rst:282
msgid "Structure Types"
msgstr ""

#: ../../../OffloadingDesign.rst:284
msgid ""
"Several different structures are used to store offloading information. The :"
"ref:`device image structure <table-device_image_structure>` stores a single "
"linked device image and its associated offloading entries. The offloading "
"entries are stored using the ``__start_omp_offloading_entries`` and "
"``__stop_omp_offloading_entries`` symbols generated by the linker using the :"
"ref:`table-tgt_offload_entry_structure`."
msgstr ""

#: ../../../OffloadingDesign.rst:291
msgid "__tgt_device_image Structure"
msgstr ""

#: ../../../OffloadingDesign.rst:297
msgid "ImageStart"
msgstr ""

#: ../../../OffloadingDesign.rst:297
msgid "Pointer to the target code start"
msgstr ""

#: ../../../OffloadingDesign.rst:299
msgid "ImageEnd"
msgstr ""

#: ../../../OffloadingDesign.rst:299
msgid "Pointer to the target code end"
msgstr ""

#: ../../../OffloadingDesign.rst:301 ../../../OffloadingDesign.rst:303
#: ../../../OffloadingDesign.rst:319 ../../../OffloadingDesign.rst:321
msgid "__tgt_offload_entry*"
msgstr ""

#: ../../../OffloadingDesign.rst:301
msgid "EntriesBegin"
msgstr ""

#: ../../../OffloadingDesign.rst:301
msgid "Begin of table with all target entries"
msgstr ""

#: ../../../OffloadingDesign.rst:303
msgid "EntriesEnd"
msgstr ""

#: ../../../OffloadingDesign.rst:303 ../../../OffloadingDesign.rst:321
msgid "End of table (non inclusive)"
msgstr ""

#: ../../../OffloadingDesign.rst:306
msgid ""
"The target :ref:`target binary descriptor <table-target_binary_descriptor>` "
"is used to store all binary images and offloading entries in an array."
msgstr ""

#: ../../../OffloadingDesign.rst:309
msgid "__tgt_bin_desc Structure"
msgstr ""

#: ../../../OffloadingDesign.rst:315
msgid "NumDeviceImages"
msgstr ""

#: ../../../OffloadingDesign.rst:315
msgid "Number of device types supported"
msgstr ""

#: ../../../OffloadingDesign.rst:317
msgid "__tgt_device_image*"
msgstr ""

#: ../../../OffloadingDesign.rst:317
msgid "DeviceImages"
msgstr ""

#: ../../../OffloadingDesign.rst:317
msgid "Array of device images (1 per dev. type)"
msgstr ""

#: ../../../OffloadingDesign.rst:319
msgid "HostEntriesBegin"
msgstr ""

#: ../../../OffloadingDesign.rst:319
msgid "Begin of table with all host entries"
msgstr ""

#: ../../../OffloadingDesign.rst:321
msgid "HostEntriesEnd"
msgstr ""

#: ../../../OffloadingDesign.rst:325 ../../../OffloadingDesign.rst:331
msgid "Global Variables"
msgstr ""

#: ../../../OffloadingDesign.rst:327
msgid ""
":ref:`table-global_variables` lists various global variables, along with "
"their type and their explicit ELF sections, which are used to store device "
"images and related symbols."
msgstr ""

#: ../../../OffloadingDesign.rst:335
msgid "Variable"
msgstr ""

#: ../../../OffloadingDesign.rst:335
msgid "ELF Section"
msgstr ""

#: ../../../OffloadingDesign.rst:337
msgid "__start_omp_offloading_entries"
msgstr ""

#: ../../../OffloadingDesign.rst:337 ../../../OffloadingDesign.rst:339
#: ../../../OffloadingDesign.rst:341
msgid "__tgt_offload_entry"
msgstr ""

#: ../../../OffloadingDesign.rst:337 ../../../OffloadingDesign.rst:339
#: ../../../OffloadingDesign.rst:341 ../../../OffloadingDesign.rst:345
#: ../../../OffloadingDesign.rst:347 ../../../OffloadingDesign.rst:349
#: ../../../OffloadingDesign.rst:351
msgid ".omp_offloading_entries"
msgstr ""

#: ../../../OffloadingDesign.rst:337
msgid "Begin symbol for the offload entries table."
msgstr ""

#: ../../../OffloadingDesign.rst:339
msgid "__stop_omp_offloading_entries"
msgstr ""

#: ../../../OffloadingDesign.rst:339
msgid "End symbol for the offload entries table."
msgstr ""

#: ../../../OffloadingDesign.rst:341
msgid "__dummy.omp_offloading.entry"
msgstr ""

#: ../../../OffloadingDesign.rst:341
msgid ""
"Dummy zero-sized object in the offload entries section to force linker to "
"define begin/end symbols defined above."
msgstr ""

#: ../../../OffloadingDesign.rst:345
msgid ".omp_offloading.device_image"
msgstr ""

#: ../../../OffloadingDesign.rst:345 ../../../OffloadingDesign.rst:347
#: ../../../OffloadingDesign.rst:349
msgid "__tgt_device_image"
msgstr ""

#: ../../../OffloadingDesign.rst:345
msgid "ELF device code object of the first image."
msgstr ""

#: ../../../OffloadingDesign.rst:347
msgid ".omp_offloading.device_image.N"
msgstr ""

#: ../../../OffloadingDesign.rst:347
msgid "ELF device code object of the (N+1)th image."
msgstr ""

#: ../../../OffloadingDesign.rst:349
msgid ".omp_offloading.device_images"
msgstr ""

#: ../../../OffloadingDesign.rst:349
msgid "Array of images."
msgstr ""

#: ../../../OffloadingDesign.rst:351
msgid ".omp_offloading.descriptor"
msgstr ""

#: ../../../OffloadingDesign.rst:351
msgid "__tgt_bin_desc"
msgstr ""

#: ../../../OffloadingDesign.rst:351
msgid "Binary descriptor object (see :ref:`binary_descriptor`)"
msgstr ""

#: ../../../OffloadingDesign.rst:357
msgid "Binary Descriptor for Device Images"
msgstr ""

#: ../../../OffloadingDesign.rst:359
msgid ""
"This object is passed to the offloading runtime at program startup and it "
"describes all device images available in the executable or shared library. "
"It is defined as follows:"
msgstr ""

#: ../../../OffloadingDesign.rst:396
msgid "Global Constructor and Destructor"
msgstr ""

#: ../../../OffloadingDesign.rst:398
msgid ""
"The global constructor (``.omp_offloading.descriptor_reg()``) registers the "
"device images with the runtime by calling the ``__tgt_register_lib()`` "
"runtime function. The constructor is explicitly defined in ``.text.startup`` "
"section and is run once when the program starts. Similarly, the global "
"destructor (``.omp_offloading.descriptor_unreg()``) calls "
"``__tgt_unregister_lib()`` for the destructor and is also defined in ``.text."
"startup`` section and run when the program exits."
msgstr ""

#: ../../../OffloadingDesign.rst:407
msgid "Offloading Example"
msgstr ""

#: ../../../OffloadingDesign.rst:409
msgid ""
"This section contains a simple example of generating offloading code using "
"OpenMP offloading. We will use a simple ``ZAXPY`` BLAS routine."
msgstr ""

#: ../../../OffloadingDesign.rst:431
msgid "This code is compiled using the following Clang flags."
msgstr ""

#: ../../../OffloadingDesign.rst:437
msgid ""
"The output section in the object file can be seen using the ``readelf`` "
"utility. The ``.llvm.offloading`` section has the ``SHF_EXCLUDE`` flag so it "
"will be removed from the final executable or shared library by the linker."
msgstr ""

#: ../../../OffloadingDesign.rst:450
msgid ""
"Compiling this file again will invoke the ``clang-linker-wrapper`` utility "
"to extract and link the device code stored at the section named ``.llvm."
"offloading`` and then use entries stored in the section named "
"``omp_offloading_entries`` to create the symbols necessary for "
"``libomptarget`` to register the device image and call the entry function."
msgstr ""

#: ../../../OffloadingDesign.rst:461
msgid ""
"We can see the steps created by clang to generate the offloading code using "
"the ``-ccc-print-phases`` option in Clang. This matches the description in :"
"ref:`Offloading Overview`."
msgstr ""

#: ../../../OffloadingDesign.rst:475
msgid "Relocatable Linking"
msgstr ""

#: ../../../OffloadingDesign.rst:477
msgid ""
"The offloading compilation pipeline normally will defer the final device "
"linking and runtime registration until the ``clang-linker-wrapper`` is run "
"to create the executable. This is the standard behaviour when compiling for "
"OpenMP offloading or CUDA and HIP in ``-fgpu-rdc`` mode. However, there are "
"some cases where the user may wish to perform this device handling "
"prematurely. This is described in the :doc:`linker wrapper "
"documentation<ClangLinkerWrapper>`."
msgstr ""

#: ../../../OffloadingDesign.rst:484
msgid ""
"Effectively, this allows the user to handle offloading specific linking "
"ahead of time when shipping objects or static libraries. This can be thought "
"of as performing a standard ``-fno-gpu-rdc`` compilation on a subset of "
"object files. This can be useful to reduce link time, prevent users from "
"interacting with the library's device code, or for shipping libraries to "
"incompatible compilers."
msgstr ""

#: ../../../OffloadingDesign.rst:490
msgid ""
"Normally, if a relocatable link is done using ``clang -r`` it will simply "
"merge the ``.llvm.offloading`` sections which will then be linked later when "
"the executable is created. However, if the ``-r`` flag is used with the "
"offloading toolchain, it will perform the device linking and registration "
"phases and then merge the registration code into the final relocatable "
"object file."
msgstr ""

#: ../../../OffloadingDesign.rst:496
msgid ""
"The following example shows how using the relocatable link with the "
"offloading pipeline can create a static library with offloading code that "
"can be redistributed without requiring any additional handling."
msgstr ""
