# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2025, The Clang Team
# This file is distributed under the same license as the Clang package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Clang main\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-16 08:35+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../StandardCPlusPlusModules.rst:3
msgid "Standard C++ Modules"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:9
msgid "Introduction"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:11
msgid ""
"The term ``module`` is ambiguous, as it is used to mean multiple things in "
"Clang. For Clang users, a module may refer to an ``Objective-C Module``, "
"`Clang Module <Modules.html>`_ (also called a ``Clang Header Module``) or a "
"``C++20 Module`` (or a ``Standard C++ Module``). The implementation of all "
"these kinds of modules in Clang shares a lot of code, but from the "
"perspective of users their semantics and command line interfaces are very "
"different. This document is an introduction to the use of C++20 modules in "
"Clang. In the remainder of this document, the term ``module`` will refer to "
"Standard C++20 modules and the term ``Clang module`` will refer to the Clang "
"Modules extension."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:22
msgid ""
"In terms of the C++ Standard, modules consist of two components: \"Named "
"Modules\" or \"Header Units\". This document covers both."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:26
msgid "Standard C++ Named modules"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:28
msgid ""
"In order to better understand the compiler's behavior, it is helpful to "
"understand some terms and definitions for readers who are not familiar with "
"the C++ feature. This document is not a tutorial on C++; it only introduces "
"necessary concepts to better understand use of modules in a project. Other "
"resources at `Wikipedia <https://en.wikipedia.org/wiki/Modules_(C++)>`_ and "
"`cppreference <https://en.cppreference.com/w/cpp/language/modules.html>`_ "
"can provide more background information about modules if needed."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:37
msgid "Background and terminology"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:40
msgid "Module and module unit"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:42
msgid ""
"A module consists of one or more module units. A module unit is a special "
"kind of translation unit. A module unit should almost always start with a "
"module declaration. The syntax of the module declaration is:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:50
msgid ""
"Terms enclosed in ``[]`` are optional. ``module_name`` and "
"``partition_name`` follow the rules for a C++ identifier, except that they "
"may contain one or more period (``.``) characters. Note that a ``.`` in the "
"name has no semantic meaning and does not imply any hierarchy."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:55
msgid "In this document, module units are classified as:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:57
msgid "Primary module interface unit"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:58
msgid "Module implementation unit"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:59
msgid "Module partition interface unit"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:60
msgid "Internal module partition unit"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:62
msgid ""
"A primary module interface unit is a module unit whose module declaration is "
"``export module module_name;`` where ``module_name`` denotes the name of the "
"module. A module should have one and only one primary module interface unit."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:66
msgid ""
"A module implementation unit is a module unit whose module declaration is "
"``module module_name;``. Multiple module implementation units can be "
"declared in the same module."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:70
msgid ""
"A module partition interface unit is a module unit whose module declaration "
"is ``export module module_name:partition_name;``. The ``partition_name`` "
"should be unique within any given module."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:74
msgid ""
"An internal module partition unit is a module unit whose module declaration "
"is ``module module_name:partition_name;``. The ``partition_name`` should be "
"unique within any given module."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:78
msgid "In this document, we use the following terms:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:80
msgid ""
"A ``module interface unit`` refers to either a ``primary module interface "
"unit`` or a ``module partition interface unit``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:83
msgid ""
"An ``importable module unit`` refers to either a ``module interface unit`` "
"or an ``internal module partition unit``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:86
msgid ""
"A ``module partition unit`` refers to either a ``module partition interface "
"unit`` or an ``internal module partition unit``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:90
msgid "Built Module Interface"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:92
msgid ""
"A ``Built Module Interface`` (or ``BMI``) is the precompiled result of an "
"importable module unit."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:96
msgid "Global module fragment"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:98
msgid ""
"The ``global module fragment`` (or ``GMF``) is the code between the ``module;"
"`` and the module declaration within a module unit."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:103
msgid "How to build projects using modules"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:106
#: ../../../StandardCPlusPlusModules.rst:1935
msgid "Quick Start"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:108
msgid "Let's see a \"hello world\" example that uses modules."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:127
msgid "Then, on the command line, invoke Clang like:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:136
msgid ""
"In this example, we make and use a simple module ``Hello`` which contains "
"only a primary module interface unit named ``Hello.cppm``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:139
msgid ""
"A more complex \"hello world\" example which uses the 4 kinds of module "
"units is:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:181
msgid "Then, back on the command line, invoke Clang with:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:200
msgid "We explain the options in the following sections."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:203
msgid "How to enable standard C++ modules"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:205
msgid ""
"Standard C++ modules are enabled automatically when the language standard "
"mode is ``-std=c++20`` or newer."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:209
msgid "How to produce a BMI"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:211
msgid ""
"To generate a BMI for an importable module unit, use either the ``--"
"precompile``, ``--precompile-reduced-bmi``, or ``-fmodule-output`` command "
"line options."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:214
msgid ""
"The ``--precompile`` option generates the BMI as the output of the "
"compilation with the output path specified using the ``-o`` option."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:217
msgid ""
"The ``--precompile-reduced-bmi`` option generates a Reduced BMI (See the "
"following section for the definition of Reduced BMI) as the output of the "
"compilation with the output path specified using the ``-o`` option."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:221
msgid ""
"The ``-fmodule-output`` option generates the BMI as a by-product of the "
"compilation. If ``-fmodule-output=`` is specified, the BMI will be emitted "
"to the specified location. If ``-fmodule-output`` and ``-c`` are specified, "
"the BMI will be emitted in the directory of the output file with the name of "
"the input file with the extension ``.pcm``. Otherwise, the BMI will be "
"emitted in the working directory with the name of the input file with the "
"extension ``.pcm``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:229
msgid ""
"Generating BMIs with ``--precompile`` is referred to as two-phase "
"compilation because it takes two steps to compile a source file to an object "
"file. Generating BMIs with ``-fmodule-output`` is called one-phase "
"compilation. The one-phase compilation model is simpler for build systems to "
"implement while the two-phase compilation has the potential to compile "
"faster due to higher parallelism. As an example, if there are two module "
"units ``A`` and ``B``, and ``B`` depends on ``A``, the one-phase compilation "
"model needs to compile them serially, whereas the two-phase compilation "
"model can be compiled as soon as ``A.pcm`` is available, and thus can be "
"compiled simultaneously with the ``A.pcm`` to ``A.o`` compilation step."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:241
msgid "File name requirements"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:243
msgid ""
"By convention, ``importable module unit`` files should use ``.cppm`` (or ``."
"ccm``, ``.cxxm``, or ``.c++m``) as a file extension. ``Module implementation "
"unit`` files should use ``.cpp`` (or ``.cc``, ``.cxx``, or ``.c++``) as a "
"file extension."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:248
msgid ""
"A BMI should use ``.pcm`` as a file extension. The file name of the BMI for "
"a ``primary module interface unit`` should be ``module_name.pcm``. The file "
"name of a BMI for a ``module partition unit`` should be ``module_name-"
"partition_name.pcm``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:253
msgid ""
"Clang may fail to build the module if different extensions are used. For "
"example, if the filename of an ``importable module unit`` ends with ``.cpp`` "
"instead of ``.cppm``, then Clang cannot generate a BMI for the ``importable "
"module unit`` with the ``--precompile`` option because the ``--precompile`` "
"option would only run the preprocessor (``-E``). If using a different "
"extension than the conventional one for an ``importable module unit`` you "
"can specify ``-x c++-module`` before the file. For example,"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:278
msgid ""
"In this example, the extension used by the ``module interface`` is ``.cpp`` "
"instead of ``.cppm``, so it cannot be compiled like the previous example, "
"but it can be compiled with:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:290
msgid "Module name requirements"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:294
msgid "[module.unit]p1:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:296
msgid ""
"All module-names either beginning with an identifier consisting of std "
"followed by zero or more digits or containing a reserved identifier ([lex."
"name]) are reserved and shall not be specified in a module-declaration; no "
"diagnostic is required. If any identifier in a reserved module-name is a "
"reserved identifier, the module name is reserved for use by C++ "
"implementations; otherwise it is reserved for future standardization."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:302
msgid "Therefore, none of the following names are valid by default:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:312
msgid ""
"Using a reserved module name is strongly discouraged, but ``-Wno-reserved-"
"module-identifier`` can be used to suppress the warning."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:316
msgid "Specifying BMI dependencies"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:318
msgid "There are 3 ways to specify a BMI dependency:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:320
msgid "``-fprebuilt-module-path=<path/to/directory>``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:321
msgid "``-fmodule-file=<path/to/BMI>`` (Deprecated)."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:322
msgid "``-fmodule-file=<module-name>=<path/to/BMI>``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:324
msgid ""
"The ``-fprebuilt-module-path`` option specifies the path to search for BMI "
"dependencies. Multiple paths may be specified, similar to using ``-I`` to "
"specify a search path for header files. When importing a module ``M``, the "
"compiler looks for ``M.pcm`` in the directories specified by ``-fprebuilt-"
"module-path``. Similarly, when importing a partition module unit ``M:P``, "
"the compiler looks for ``M-P.pcm`` in the directories specified by ``-"
"fprebuilt-module-path``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:332
msgid ""
"The ``-fmodule-file=<path/to/BMI>`` option causes the compiler to load the "
"specified BMI directly. The ``-fmodule-file=<module-name>=<path/to/BMI>`` "
"option causes the compiler to load the specified BMI for the module "
"specified by ``<module-name>`` when necessary. The main difference is that "
"``-fmodule-file=<path/to/BMI>`` will load the BMI eagerly, whereas ``-"
"fmodule-file=<module-name>=<path/to/BMI>`` will only load the BMI lazily, as "
"will ``-fprebuilt-module-path``. The ``-fmodule-file=<path/to/BMI>`` option "
"for named modules is deprecated and will be removed in a future version of "
"Clang."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:342
msgid ""
"When these options are specified in the same invocation of the compiler, the "
"``-fmodule-file=<path/to/BMI>`` option takes precedence over ``-fmodule-"
"file=<module-name>=<path/to/BMI>``, which takes precedence over ``-fprebuilt-"
"module-path=<path/to/directory>``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:347
msgid ""
"Note: all BMI dependencies must be specified explicitly, either directly or "
"indirectly. See https://github.com/llvm/llvm-project/issues/62707 for "
"details."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:350
msgid ""
"When compiling a ``module implementation unit``, the BMI of the "
"corresponding ``primary module interface unit`` must be specified because a "
"module implementation unit implicitly imports the primary module interface "
"unit."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:354
msgid "[module.unit]p8"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:356
msgid ""
"A module-declaration that contains neither an export-keyword nor a module-"
"partition implicitly imports the primary module interface unit of the module "
"as if by a module-import-declaration."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:359
msgid ""
"The ``-fprebuilt-module-path=<path/to/directory>``, ``-fmodule-file=<path/to/"
"BMI>``, and ``-fmodule-file=<module-name>=<path/to/BMI>`` options may be "
"specified multiple times. For example, the command line to compile ``M."
"cppm`` in the previous example could be rewritten as:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:368
msgid ""
"When there are multiple ``-fmodule-file=<module-name>=`` options for the "
"same ``<module-name>``, the last ``-fmodule-file=<module-name>=`` overrides "
"the previous ``-fmodule-file=<module-name>=`` option."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:373
msgid "Remember that module units still have an object counterpart to the BMI"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:375
msgid ""
"While module interfaces resemble traditional header files, they still "
"require compilation. Module units are translation units, and need to be "
"compiled to object files, which then need to be linked together as the "
"following examples show."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:380
msgid ""
"For example, the traditional compilation processes for headers are like:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:389
msgid "And the compilation processes for module units are like:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:398
msgid ""
"As the diagrams show, we need to compile the BMI from module units to object "
"files and then link the object files. (However, this cannot be done for the "
"BMI from header units. See the section on :ref:`header units <header-units>` "
"for more details.)"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:403
msgid ""
"BMIs cannot be shipped in an archive to create a module library. Instead, "
"the BMIs(``*.pcm``) are compiled into object files(``*.o``) and those object "
"files are added to the archive instead."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:408
msgid "clang-cl"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:410
msgid ""
"``clang-cl`` supports the same options as ``clang++`` for modules as "
"detailed above; there is no need to prefix these options with ``/clang:``. "
"Note that ``cl.exe`` `options to emit/consume IFC files <https://devblogs."
"microsoft.com/cppblog/using-cpp-modules-in-msvc-from-the-command-line-part-1/"
">` are *not* supported. The resulting precompiled modules are also not "
"compatible for use with ``cl.exe``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:415
msgid ""
"We recommend that build system authors use the above-mentioned ``clang++`` "
"options  with ``clang-cl`` to build modules."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:418
msgid "Consistency Requirements"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:420
msgid ""
"Modules can be viewed as a kind of cache to speed up compilation. Thus, like "
"other caching techniques, it is important to maintain cache consistency, "
"which is why Clang does very strict checking for consistency."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:425
msgid "Options consistency"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:427
msgid ""
"Compiler options related to the language dialect for a module unit and its "
"non-module-unit uses need to be consistent. Consider the following example:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:443
msgid ""
"Clang rejects the example due to the inconsistent language standard modes. "
"Not all compiler options are language-dialect options, though. For example:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:454
msgid ""
"Although the optimization and debugging levels are inconsistent, these "
"compilations are accepted because the compiler options do not impact the "
"language dialect."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:458
msgid ""
"Note that the compiler **currently** doesn't reject inconsistent macro "
"definitions (this may change in the future). For example:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:467
msgid ""
"Currently, Clang accepts the above example, though it may produce surprising "
"results if the debugging code depends on consistent use of ``NDEBUG`` in "
"other translation units."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:472
msgid "Source Files Consistency"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:474
msgid ""
"Clang may open the input files [1]_ of a BMI during the compilation. This "
"implies that when Clang consumes a BMI, all the input files need to be "
"present in the original path and with the original contents."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:478
msgid ""
"To overcome these requirements and simplify cases like distributed builds "
"and sandboxed builds, users can use the ``-fmodules-embed-all-files`` flag "
"to embed all input files into the BMI so that Clang does not need to open "
"the corresponding file on disk."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:482
msgid ""
"When the ``-fmodules-embed-all-files`` flag is enabled, Clang explicitly "
"emits the source code into the BMI file; the BMI file contains a "
"sufficiently verbose representation to reproduce the original source file."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:486
msgid ""
"Input files: The source files which took part in the compilation of the BMI. "
"For example:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:500
msgid ""
"The ``M.cppm``, ``foo.h`` and ``bar.h`` are input files for the BMI of ``M."
"cppm``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:503
msgid "Object definition consistency"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:505
msgid ""
"The C++ language requires that declarations of the same entity in different "
"translation units have the same definition, which is known as the One "
"Definition Rule (ODR). Without modules, the compiler cannot perform strong "
"ODR violation checking because it only sees one translation unit at a time. "
"With the use of modules, the compiler can perform checks for ODR violations "
"across translation units."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:512
msgid ""
"However, the current ODR checking mechanisms are not perfect. There are a "
"significant number of false positive ODR violation diagnostics, where the "
"compiler incorrectly diagnoses two identical declarations as having "
"different definitions. Further, true positive ODR violations are not always "
"reported."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:517
msgid ""
"To give a better user experience, improve compilation performance, and for "
"consistency with MSVC, ODR checking of declarations in the global module "
"fragment is disabled by default. These checks can be enabled by specifying "
"``-Xclang -fno-skip-odr-check-in-gmf`` when compiling. If the check is "
"enabled and you encounter incorrect or missing diagnostics, please report "
"them via the `community issue tracker <https://github.com/llvm/llvm-project/"
"issues/>`_."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:525
msgid "Privacy Issue"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:527
msgid ""
"BMIs are not and should not be treated as an information hiding mechanism. "
"They should always be assumed to contain all the information that was used "
"to create them, in a recoverable form."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:532
msgid "ABI Impacts"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:534
msgid ""
"This section describes the new ABI changes brought by modules. Only changes "
"to the Itanium C++ ABI are covered."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:538
msgid "Name Mangling"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:540
msgid ""
"The declarations in a module unit which are not in the global module "
"fragment have new linkage names."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:543
#: ../../../StandardCPlusPlusModules.rst:1484
msgid "For example,"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:552
msgid ""
"The linkage name of ``NS::foo()`` is ``_ZN2NSW1M3fooEv``. This couldn't be "
"demangled by previous versions of the debugger or demangler. As of LLVM 15."
"x, ``llvm-cxxfilt`` can be used to demangle this:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:561
msgid "The result should be read as ``NS::foo()`` in module ``M``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:563
msgid ""
"The ABI implies that something cannot be declared in a module unit and "
"defined in a non-module unit (or vice-versa), as this would result in "
"linking errors."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:566
msgid ""
"Despite this, it is possible to implement declarations with a compatible ABI "
"in a module unit by using a language linkage specifier because the "
"declarations in the language linkage specifier are attached to the global "
"module fragment. For example:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:578
msgid "Now the linkage name of ``NS::foo()`` will be ``_ZN2NS3fooEv``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:581
msgid "Module Initializers"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:583
msgid ""
"All importable module units are required to emit an initializer function to "
"handle the dynamic initialization of non-inline variables in the module "
"unit. The importable module unit has to emit the initializer even if there "
"is no dynamic initialization; otherwise, the importer may call a nonexistent "
"function. The initializer function emits calls to imported modules first "
"followed by calls to all of the dynamic initializers in the current module "
"unit."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:591
msgid ""
"Translation units that explicitly or implicitly import a named module must "
"call the initializer functions of the imported named module within the "
"sequence of the dynamic initializers in the translation unit. "
"Initializations of entities at namespace scope are appearance-ordered. This "
"(recursively) extends to imported modules at the point of appearance of the "
"import declaration."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:597
msgid ""
"If the imported module is known to be empty, the call to its initializer may "
"be omitted. Additionally, if the imported module is known to have already "
"been imported, the call to its initializer may be omitted."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:602
msgid "Reduced BMI"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:604
msgid ""
"To support the two-phase compilation model, Clang puts everything needed to "
"produce an object into the BMI. However, other consumers of the BMI "
"generally don't need that information. This makes the BMI larger and may "
"introduce unnecessary dependencies for the BMI. To mitigate the problem, "
"Clang has a compiler option to reduce the information contained in the BMI. "
"These two formats are known as Full BMI and Reduced BMI, respectively."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:611
msgid ""
"Users can use the ``-fmodules-reduced-bmi`` or ``--precompile-reduced-bmi`` "
"option to produce a Reduced BMI."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:614
msgid ""
"The ``--precompile-reduced-bmi`` option will produce the reduced BMI to the "
"location specified by ``-o``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:617
msgid ""
"Note that ``--precompile`` will always generate the full BMI. So that build "
"system which may generate the BMI only should take care of this."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:620
msgid ""
"For the one-phase compilation model (CMake implements this model), with ``-"
"fmodules-reduced-bmi``, the generated BMI will be a Reduced BMI "
"automatically. (The output path of the BMI is specified by ``-fmodule-"
"output=`` as usual with the one-phase compilation model)."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:625
msgid ""
"It is also possible to produce a Reduced BMI with the two-phase compilation "
"model. When ``-fmodules-reduced-bmi``, ``--precompile``, and ``-fmodule-"
"output=`` are specified, the generated BMI specified by ``-o`` will be a "
"full BMI and the BMI specified by ``-fmodule-output=`` will be a Reduced "
"BMI. The dependency graph in this case would look like:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:640
msgid ""
"Clang does not emit diagnostics when ``-fmodules-reduced-bmi`` is used with "
"a non-module unit. This design permits users of the one-phase compilation "
"model to try using reduced BMIs without needing to modify the build system. "
"The two-phase compilation module requires build system support."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:645
msgid ""
"In a Reduced BMI, Clang does not emit unreachable entities from the global "
"module fragment, or definitions of non-inline functions and non-inline "
"variables. This may not be a transparent change."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:649
msgid "Consider the following example:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:697
msgid ""
"In the above example, the function definition of ``N::g`` is elided from the "
"Reduced BMI of ``M.cppm``. Then the use of ``use_g<int>`` in ``M-impl.cpp`` "
"fails to instantiate. For such issues, users can add references to ``N::g`` "
"in the `module purview <https://eel.is/c++draft/module.unit#5>`_ of ``M."
"cppm`` to ensure it is reachable, e.g. ``using N::g;``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:703
msgid ""
"As of Clang 22.x, the Reduced BMI is enabled by default. You may still want "
"to use Full BMI with ``-fno-modules-reduced-bmi`` in the following case: 1. "
"Your build system uses two-phase compilation, but it hasn't adjusted the "
"implementation for reduced BMI. 2. You encounter a regression with Reduced "
"BMI that you cannot work around. Please report an issue for this case."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:711
msgid "Experimental Non-Cascading Changes"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:713
msgid ""
"This section is primarily for build system vendors. For end compiler users, "
"if you don't want to read it all, this is helpful to reduce recompilations. "
"We encourage build system vendors and end users to try this out and bring "
"feedback."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:717
msgid ""
"Before Clang 19, a change in BMI of any (transitive) dependency would cause "
"the outputs of the BMI to change. Starting with Clang 19, changes to non-"
"direct dependencies should not directly affect the output BMI, unless they "
"affect the results of the compilations. We expect that there are many more "
"opportunities for this optimization than we currently have realized and "
"would appreciate feedback about missed optimization opportunities. For "
"example,"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:751
msgid "To compile the project (for brevity, some commands are omitted.):"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:762
msgid "If the interface of ``m-partA.cppm`` is changed to:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:770
msgid "and the BMI for ``useBOnly`` is recompiled as in:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:781
msgid ""
"then the contents of ``useBOnly.pcm`` remain unchanged. Consequently, if the "
"build system only bases recompilation decisions on directly imported "
"modules, it becomes possible to skip the recompilation of ``Use.cc``. It "
"should be fine because the altered interfaces do not affect ``Use.cc`` in "
"any way; the changes do not cascade."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:787
msgid ""
"When ``Clang`` generates a BMI, it records the hash values of all "
"potentially contributory BMIs for the BMI being produced. This ensures that "
"build systems are not required to consider transitively imported modules "
"when deciding whether to recompile."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:791
msgid ""
"What is considered to be a potential contributory BMIs is currently "
"unspecified. However, it is a severe bug for a BMI to remain unchanged "
"following an observable change in the module source files that affects the "
"module consumers."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:795
msgid ""
"Build systems may utilize this optimization by doing an update-if-changed "
"operation to the BMI that is consumed from the BMI that is output by the "
"compiler."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:798
msgid ""
"We encourage build systems to add an experimental mode that reuses the "
"cached BMI when **direct** dependencies did not change, even if "
"**transitive** dependencies did change."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:802
msgid ""
"Given that there are potential compiler bugs, we recommend that build "
"systems support this feature as a configurable option so that users can go "
"back to the transitive change mode safely at any time."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:807
msgid "Interactions with Reduced BMI"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:809
msgid ""
"With reduced BMI, non-cascading changes can be more powerful. For example,"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:829
msgid "And let's change the implementation for ``A.cppm`` to:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:837
msgid "and recompile the example:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:846
msgid ""
"We should find the contents of ``B.pcm`` remain the same. In this case, the "
"build system is allowed to skip recompilations of TUs which solely and "
"directly depend on module ``B``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:849
msgid ""
"This only happens with a reduced BMI. With reduced BMIs, we won't record the "
"function body of ``int b()`` in the BMI for ``B`` so that the module ``A`` "
"doesn't contribute to the BMI of ``B`` and we have less dependencies."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:854
msgid "Performance Tips"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:857
msgid "Reduce duplications"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:859
msgid ""
"While it is valid to have duplicated declarations in the global module "
"fragments of different module units, it is not free for Clang to deal with "
"the duplicated declarations. A translation unit will compile more slowly if "
"there are a lot of duplicated declarations between the translation unit and "
"modules it imports. For example:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:899
msgid ""
"When ``big.header.h`` is big enough and there are a lot of partitions, the "
"compilation of ``use.cpp`` may be significantly slower than the following "
"approach:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:939
msgid ""
"Reducing the duplication from textual includes is what improves compile-time "
"performance."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:942
msgid ""
"To help users to identify such issues, we add a warning ``-Wdecls-in-"
"multiple-modules``. This warning is disabled by default and it needs to be "
"explicitly enabled or by ``-Weverything``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:946
msgid "Transitioning to modules"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:948
msgid ""
"It is best for new code and libraries to use modules from the start if "
"possible. However, it may be a breaking change for existing code or "
"libraries to switch to modules. As a result, many existing libraries need to "
"provide both headers and module interfaces for a while to not break existing "
"users."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:953
msgid ""
"This section provides some suggestions on how to ease the transition process "
"for existing libraries. **Note that this information is only intended as "
"guidance, rather than as requirements to use modules in Clang.** It presumes "
"the project is starting with no module-based dependencies."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:959
msgid "ABI non-breaking styles"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:962
msgid "export-using style"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:979
msgid ""
"This example shows how to include all the headers containing declarations "
"which need to be exported, and uses `using` declarations in an `export` "
"block to produce the module interface."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:984
msgid "export extern-C++ style"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1002
msgid ""
"Headers (from ``header_1.h`` to ``header_n.h``) need to define the macro:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1012
msgid "and put ``EXPORT`` on the declarations you want to export."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1014
msgid ""
"Also, it is recommended to refactor headers to include third-party headers "
"conditionally:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1027
msgid ""
"This can be helpful because it gives better diagnostic messages if the "
"module interface unit is not properly updated when modifying code."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1030
msgid ""
"This approach works because the declarations with language linkage are "
"attached to the global module. Thus, the ABI of the modular form of the "
"library does not change."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1034
msgid ""
"While this style is more involved than the export-using style, it makes it "
"easier to further refactor the library to other styles."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1038
msgid "ABI breaking style"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1040
msgid ""
"The term ``ABI breaking`` may sound like a bad approach. However, this style "
"forces consumers of the library use it in a consistent way. e.g., either "
"always include headers for the library or always import modules. The style "
"prevents the ability to mix includes and imports for the library."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1045
msgid ""
"The pattern for ABI breaking style is similar to the export extern-C++ style."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1078
msgid ""
"(And add `EXPORT` and conditional include to the headers as suggested in the "
"export extern-C++ style section.)"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1081
msgid ""
"The ABI with modules is different and thus we need to compile the source "
"files into the new ABI. This is done by an additional part of the interface "
"unit:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1103
msgid ""
"If the number of source files is small, everything can be put in the private "
"module fragment directly (it is recommended to add conditional includes to "
"the source files as well). However, compile time performance will be bad if "
"there are a lot of source files to compile."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1108
msgid ""
"**Note that the private module fragment can only be in the primary module "
"interface unit and the primary module interface unit containing the private "
"module fragment should be the only module unit of the corresponding module.**"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1112
msgid ""
"In this case, source files (.cpp files) must be converted to module "
"implementation units:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1129
msgid ""
"The module implementation unit will import the primary module implicitly. Do "
"not include any headers in the module implementation units as it avoids "
"duplicated declarations between translation units. This is why non-exported "
"using declarations should be added from third-party libraries in the primary "
"module interface unit."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1135
msgid ""
"If the library is provided as ``libyour_library.so``, a modular library (e."
"g., ``libyour_library_modules.so``) may also need to be provided for ABI "
"compatibility."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1140
msgid "What if there are headers only included by the source files"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1142
msgid ""
"The above practice may be problematic if there are headers only included by "
"the source files. When using a private module fragment, this issue may be "
"solved by including those headers in the private module fragment. While it "
"is OK to solve it by including the implementation headers in the module "
"purview when using implementation module units, it may be suboptimal because "
"the primary module interface units now contain entities that do not belong "
"to the interface."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1149
msgid ""
"This can potentially be improved by introducing a module partition "
"implementation unit. An internal module partition unit is an importable "
"module unit which is internal to the module itself."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1154
msgid "The ABI of your library"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1156
msgid "You can skip this section your library doesn't ship ABI."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1158
msgid ""
"With the ABI breaking style, for every ABI you shipped in your library, you "
"should provide a corresponding ABI within the modules version."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1161
msgid "For example, if this your library before provding modules,"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1185
msgid "Then you will ship ABI may be like:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1193
msgid "Then with ABI breaking style, your code may look like:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1209
msgid "And your ABI should look like:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1220
msgid ""
"Here ``example::C@example::inline_get()`` and ``example::C@example::get()`` "
"is the corresponding version for ``example::C::inline_get()`` and ``example::"
"C::get()`` in modules version."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1225
msgid "Which part of the ABI will be broken?"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1227
msgid ""
"While your library keeps ABI compatible by providing both ABI versions. The "
"users's ABI may be breaking if they used the ABI of modules' version."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1230
msgid ""
"This is similar with `the famous ABI break in GCC 5's libstdc++ for C++11 "
"<https://gcc.gnu.org/onlinedocs/libstdc++/manual/using_dual_abi.html>`_."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1233
msgid ""
"Although your library remains compatible with both ABIs, for your library's "
"users, choosing the module-based ABI will also break their ABI. For example, "
"if your user's code contains:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1247
msgid ""
"then, (if your user will ship ABI too), their shipped ABI may look like:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1254
msgid "But when your user switches to your ABI-breaking style module:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1266
msgid "The corresponding ABI may look like:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1273
msgid ""
"Here we can find the ABI break from ``user::user_def(example::C&)`` to "
"``user::user_def(example::C@example&)``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1277
msgid "Less duplicated generated code"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1279
msgid ""
"Another benefit of ABI breaking style is, it is more likely to modules "
"native style. So that compiler can generate the previously implicitly inline "
"entities (e.g., virtual tables, variables and functions) to the module unit "
"instead of generating them in every translation unit used."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1284
msgid ""
"e.g, for the above example, in header version, the definition of ``example::"
"C::inline_get()`` will be generated in every translation unit used. But in "
"modules version, ``example::C::inline_get()`` will only be generated once in "
"the module unit."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1289
msgid ""
"This is helpful for the whole build process to generate less duplicated "
"code, which will results in smaller binary size and faster compilation speed."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1292
msgid ""
"Note that for compatibility, the explicitly inline entities will still be "
"inline in modules. So that if you have explicitly inline entities and you're "
"using ABI breaking style, it is suggestted to use a macro to control "
"inliness of the entity."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1296
msgid "e.g.,"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1305
msgid "within ABI breaking style, we suggest,"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1334
msgid "So that ``your_interface()`` will not be inline in modules version."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1337
msgid "Providing a header to skip parsing redundant headers"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1339
msgid ""
"Many redeclarations shared between translation units cause Clang to have "
"slower compile-time performance. Further, there are known issues with "
"`include after import <https://github.com/llvm/llvm-project/issues/61465>`_. "
"Even when that issue is resolved, users may still get slower compilation "
"speed and larger BMIs. For these reasons, it is recommended to not include "
"headers after importing the corresponding module. However, it is not always "
"easy if the library is included by other dependencies, as in:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1352
msgid "or"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1359
msgid ""
"For such cases, it is best if the library providing both module and header "
"interfaces also provides a header which skips parsing so that the library "
"can be imported with the following approach that skips redundant "
"redeclarations:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1369
msgid ""
"The implementation of ``your_library_imported.h`` can be a set of "
"controlling macros or an overall controlling macro if using `#pragma once`. "
"Then headers can be refactored to:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1380
msgid ""
"If the modules imported by the library provide such headers, remember to add "
"them to ``your_library_imported.h`` too."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1384
msgid "Importing modules"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1386
msgid ""
"When there are library dependencies providing modules, the module "
"dependencies should be imported in your module as well. Many existing "
"libraries will fall into this category once the ``std`` module is more "
"widely available."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1391
msgid "All library dependencies providing modules"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1393
msgid ""
"Of course, most of the complexity disappears if all the library dependencies "
"provide modules."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1396
msgid ""
"Headers need to be converted to include third-party headers conditionally. "
"Then, for the export-using style:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1416
msgid "or, for the export extern-C++ style:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1430
msgid "or, for the ABI-breaking style,"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1450
msgid ""
"Non-exported ``using`` declarations are unnecessary if using implementation "
"module units. Instead, third-party modules can be imported directly in "
"implementation module units."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1455
msgid "Partial library dependencies providing modules"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1457
msgid ""
"If the library has to mix the use of ``include`` and ``import`` in its "
"module, the primary goal is still the removal of duplicated declarations in "
"translation units as much as possible. If the imported modules provide "
"headers to skip parsing their headers, those should be included after the "
"import. If the imported modules don't provide such a header, one can be made "
"manually for improved compile time performance."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1465
msgid "Reachability of internal partition units"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1467
msgid ""
"The internal partition units are sometimes called implementation partition "
"units in other documentation. However, the name may be confusing since "
"implementation partition units are not implementation units."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1471
msgid ""
"According to `[module.reach]p1 <https://eel.is/c++draft/module.reach#1>`_ "
"and `[module.reach]p2 <https://eel.is/c++draft/module.reach#2>`_ (from "
"N4986):"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1474
msgid ""
"A translation unit U is necessarily reachable from a point P if U is a "
"module interface unit on which the translation unit containing P has an "
"interface dependency, or the translation unit containing P imports U, in "
"either case prior to P."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1479
msgid ""
"All translation units that are necessarily reachable are reachable. "
"Additional translation units on which the point within the program has an "
"interface dependency may be considered reachable, but it is unspecified "
"which are and under what circumstances."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1507
msgid ""
"The internal partition unit ``c.cppm`` is not necessarily reachable by ``a."
"cpp`` because ``c.cppm`` is not a module interface unit and ``a.cpp`` "
"doesn't import ``c.cppm``. This leaves it up to the compiler to decide if "
"``c.cppm`` is reachable by ``a.cpp`` or not. Clang's behavior is that "
"indirectly imported internal partition units are not reachable."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1513
msgid ""
"The suggested approach for using an internal partition unit in Clang is to "
"only import them in the implementation unit."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1517
msgid "Using Clang Module Map to Avoid mixing #include and import problems"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1520
msgid "Discussion in this section is experimental."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1523
msgid "Problems Background"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1525
msgid ""
"As discussed before, the redeclaration in different TU is one of the major "
"problems of using modules from the perspective of the compiler. The "
"redeclaration pattern is a major trigger of compiler bugs. And even if the "
"compiler accepts the redeclaration pattern as expected, the compilation "
"performance will be affected too."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1530
#: ../../../StandardCPlusPlusModules.rst:1590
msgid "e.g,"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1549
msgid ""
"Here in ``a.cc``, we have redeclaration for ``A``, one from ``a.cppm`` and "
"one from ``a.cc`` itself."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1552
msgid ""
"To avoid the redeclaration pattern, in previous section, we suggested users "
"to comment out thirdparty headers manually."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1555
msgid ""
"And here we will introduce another approach to avoid such redeclaration "
"pattern by using clang module map."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1559
msgid "Clang Module Map Background"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1561
msgid ""
"Clang Module Map is a feature of Clang Header Modules. See `Clang Module "
"<Modules.html>`_ for full introduction of Clang Header Modules. Here we "
"would only introduce Clang Header Modules to make this document self "
"contained."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1566
msgid "Clang Implicit Header Modules"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1568
msgid ""
"In Clang Implicit Header Module mode, Clang will read the module map and "
"compile the header in the module map into a module file and use the module "
"file automatically. This sounds very nice. But due to the complexity, this "
"is not so wonderful in practice. Clang has to compile the same header in "
"different preprocessor context into different module file for correctness "
"conservatively. Then this may trigger the redeclaration in different TU "
"problems. So that the user of implicit header modules has to design a module "
"system bottom up carefully. And clang implicit header module `has many "
"issues with soundness and performance due to tradeoffs made for module reuse "
"and filesystem contention <https://discourse.llvm.org/t/clang-modules-build-"
"daemon-build-system-agnostic-support-for-explicitly-built-modules>`_."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1580
msgid "Clang Explicit Header Modules"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1582
msgid ""
"Clang explicit header modules offloads the job of creating and managing "
"module files to the build system. Given the C++20 modules and clang header "
"modules actually share the same underlying implementation, it is actually "
"possible to reuse the interface of clang module map for C++20 named modules."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1587
msgid ""
"Technically, Clang Explicit Header Modules may be able to solve the "
"redeclaration problem. For the above example,"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1609
msgid ""
"The build system can build the header into a module file and use it in both "
"``a.cppm`` and ``a.cc``. Then there is no redeclaration in the example. All "
"the declaration of ``class A`` come from the synthesized TU ``a.h``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1613
msgid ""
"But there are problems: (1) the build system needs to support clang explicit "
"module. (2) The interaction between clang named modules and clang header "
"modules are theoriticall fine but not verified in practice. And also the "
"document itself is about standard C++ modules, so we won't expand here."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1619
msgid "Examples"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1621
msgid ""
"To use Clang Module Map for C++20 Named Modules, end users have to wait for "
"the support from build systems. Here we ignore the build systems to help "
"users to understand the mechanism."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1625
msgid ""
"Here is an example of using clang module map to replace a header to an "
"import of a module."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1655
msgid "Then invoke Clang with:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1664
msgid ""
"We can find that the header file ``a.h`` is not included actually (otherwise "
"the compilation should fail due to the static assert). And it imports the "
"module ``a`` and then the varaible in module ``a`` got initialized."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1667
msgid ""
"The secret comes from the flag ``-fmodule-map-file=a.cppm.modulemap``, the "
"content of ``a.cppm.modulemap`` says: map the #include of ``a.h`` to the "
"import to module ``a``. Then when the compiler sees ``#include \"a.h\"``, "
"the compiler won't include ``a.h`` actually but tries to import the module "
"``a``. And the from the command line ``-fmodule-file=a=a.pcm``, the compiler "
"get the module file of module ``a``, then module file of module ``a`` get "
"imported and the inclusion of ``a.h`` is skipped."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1673
msgid ""
"Then we can try to use the mechanism to avoid redeclaration pattern for "
"header wrapping modules."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1697
msgid ""
"Similarly, when we compile ``a.cc``, if we add the flag ``-fmodule-map-"
"file=a.cppm.modulemap``, the compiler will map the inclusion of ``a.h`` to "
"the import of module ``a``. And the module ``a`` is already imported. So we "
"avoid the redeclaration of class ``A`` in ``a.cc``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1701
msgid ""
"An imaginable problem with this approach maybe the hidden inclusion. e.g,"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1739
msgid "The example is valid if we don't use the module map:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1747
msgid "But if we enable the module map, the example is invalid:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1761
msgid "A suggested convention for end users and build systems"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1763
msgid ""
"As said, the build system is a vital role in this strategy. However, for "
"build systems, it is not easy to support clang explicit header modules or "
"support the module map with C++20 named modules generally. The complexity "
"for build system won't be less than supporting C++20 named modules."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1768
msgid ""
"So here we suggest a convention between end users and build systems to ease "
"the implementation burden of build systems and help end users to avoid the "
"redeclaration problem from mixing #include and import."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1772
msgid ""
"For end users who is the author of header based library offering named "
"module wrappers, The header's interface should be a subset of the module "
"interface excluding user-facing macros."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1775
msgid ""
"Extract all user facing headers into a single header file. Since C++20 named "
"modules"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1776
msgid ""
"For each named module interface, provide a module map file to map the "
"interface headers to the named module. The name of the module map should be "
"the name of the module interface unit plus ``.modulemap``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1778
msgid ""
"The number of the module map may not be a lot sicne this is still a header "
"based library."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1781
msgid "For build systems,"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1783
msgid ""
"For each Translation Units, if the unit doesn't import any named modules, "
"stop. This is not what we want."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1784
msgid ""
"If the TU imports named module, for all imported named module unit, look up "
"for the module map file in the same path of the imported module unit with "
"the name of the module unit plus ``.modulemap``. e.g., if the name of the "
"module unit is ``a.cppm``, we should lookup for ``a.cppm.modulemap``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1785
msgid ""
"For the found module map, pass ``-fmodule-map-file=<module_map_file_path>`` "
"to the clang compiler."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1787
msgid ""
"The point of the approach is, the build system can reuse the result of C++20 "
"named modules to manage depencies. So that the implementation burden of "
"build systems is largely reduced."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1791
msgid "Known Issues"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1793
msgid ""
"The following describes issues in the current implementation of modules. "
"Please see `the issues list for modules <https://github.com/llvm/llvm-"
"project/labels/clang%3Amodules>`_ for a list of issues or to file a new "
"issue if you don't find an existing one. When creating a new issue for "
"standard C++ modules, please start the title with ``[C++20] [Modules]`` (or "
"``[C++23] [Modules]``, etc) and add the label ``clang:modules`` if possible."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1801
msgid ""
"A high-level overview of support for standards features, including modules, "
"can be found on the `C++ Feature Status <https://clang.llvm.org/cxx_status."
"html>`_ page."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1806
msgid "Including headers after import is not well-supported"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1808
msgid "The following example is accepted:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1821
msgid ""
"but if the order of ``#include <iostream>`` and ``import foo;`` is reversed, "
"then the code is currently rejected:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1835
msgid "Both of the above examples should be accepted."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1837
msgid ""
"This is a limitation of the implementation. In the first example, the "
"compiler will see and parse ``<iostream>`` first then it will see the "
"``import``. In this case, ODR checking and declaration merging will happen "
"in the deserializer. In the second example, the compiler will see the "
"``import`` first and the ``#include`` second which results in ODR checking "
"and declarations merging happening in the semantic analyzer. This is due to "
"a divergence in the implementation path. This is tracked by `#61465 <https://"
"github.com/llvm/llvm-project/issues/61465>`_."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1847
msgid "Ignored ``preferred_name`` Attribute"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1849
msgid ""
"When Clang writes BMIs, it will ignore the ``preferred_name`` attribute on "
"declarations which use it. Thus, the preferred name will not be displayed in "
"the debugger as expected. This is tracked by `#56490 <https://github.com/"
"llvm/llvm-project/issues/56490>`_."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1855
msgid "Inconsistent filename suffix requirement for importable module units"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1857
msgid ""
"Currently, Clang requires the file name of an ``importable module unit`` to "
"have ``.cppm`` (or ``.ccm``, ``.cxxm``, ``.c++m``) as the file extension. "
"However, the behavior is inconsistent with other compilers. This is tracked "
"by `#57416 <https://github.com/llvm/llvm-project/issues/57416>`_."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1863
msgid "Incorrect ODR violation diagnostics"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1865
msgid ""
"ODR violations are a common issue when using modules. Clang sometimes "
"produces false-positive diagnostics or fails to produce true-positive "
"diagnostics of the One Definition Rule. One often-reported example is:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1895
msgid ""
"Currently the compiler incorrectly diagnoses the inconsistent definition of "
"``fun()`` in two module units. Because both definitions of ``fun()`` have "
"the same spelling and ``T`` refers to the same type entity, there is no ODR "
"violation. This is tracked by `#78850 <https://github.com/llvm/llvm-project/"
"issues/78850>`_."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1902
msgid "Using TU-local entity in other units"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1904
msgid ""
"Module units are translation units, so the entities which should be local to "
"the module unit itself should never be used by other units."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1907
msgid ""
"The C++ standard defines the concept of ``TU-local`` and ``exposure`` in "
"`basic.link/p14 <https://eel.is/c++draft/basic.link#14>`_, `basic.link/p15 "
"<https://eel.is/c++draft/basic.link#15>`_, `basic.link/p16 <https://eel.is/c+"
"+draft/basic.link#16>`_, `basic.link/p17 <https://eel.is/c++draft/basic."
"link#17>`_, and `basic.link/p18 <https://eel.is/c++draft/basic.link#18>`_."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1914
msgid ""
"However, Clang doesn't formally support these two concepts. This results in "
"unclear or confusing diagnostic messages. Further, Clang may import ``TU-"
"local`` entities to other units without any diagnostics. This is tracked by "
"`#78173 <https://github.com/llvm/llvm-project/issues/78173>`_."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1922
msgid "Header Units"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1925
msgid "How to build projects using header units"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1929
msgid ""
"The support for header units, including related command line options, is "
"experimental. There are still many unanswered questions about how tools "
"should interact with header units. The details described here may change in "
"the future."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1937
msgid "The following example:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1946
#: ../../../StandardCPlusPlusModules.rst:1979
msgid "could be compiled with:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1954
msgid "How to produce BMIs"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1956
msgid ""
"Similar to named modules, ``--precompile`` can be used to produce a BMI. "
"However, that requires specifying that the input file is a header by using "
"``-xc++-system-header`` or ``-xc++-user-header``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1960
msgid ""
"The ``-fmodule-header={user,system}`` option can also be used to produce a "
"BMI for header units which have a file extension like `.h` or `.hh`. The "
"argument to ``-fmodule-header`` specifies either the user search path or the "
"system search path. The default value for ``-fmodule-header`` is ``user``. "
"For example:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1986
msgid ""
"For headers which do not have a file extension, ``-xc++-header`` (or ``-xc++-"
"system-header``, ``-xc++-user-header``) must be used to specify the file as "
"a header. For example:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2004
msgid "How to specify BMI dependencies"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2006
msgid ""
"``-fmodule-file`` can be used to specify a BMI dependency (or multiple times "
"for more than one BMI dependency)."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2009
msgid ""
"With the existing implementation, ``-fprebuilt-module-path`` cannot be used "
"for header units (because they are nominally anonymous). For header units, "
"use ``-fmodule-file`` to include the relevant PCM file for each header unit."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2013
msgid ""
"This is expected to be solved in a future version of Clang either by the "
"compiler finding and specifying ``-fmodule-file`` automatically, or by the "
"use of a module-mapper that understands how to map the header name to their "
"PCMs."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2018
msgid "Compiling a header unit to an object file"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2020
msgid ""
"A header unit cannot be compiled to an object file due to the semantics of "
"header units. For example:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2030
msgid "Include translation"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2032
msgid ""
"The C++ standard allows vendors to convert ``#include header-name`` to "
"``import header-name;`` when possible. Currently, Clang does this "
"translation for the ``#include`` in the global module fragment. For example, "
"the following example:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2046
msgid "is the same as this example:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2062
msgid ""
"In the latter example, Clang can find the BMI for ``<iostream>`` and so it "
"tries to replace the ``#include <iostream>`` with ``import <iostream>;`` "
"automatically."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2068
msgid "Differences between Clang modules and header units"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2070
msgid ""
"Header units have similar semantics to Clang modules. The semantics of both "
"are like headers. Therefore, header units can be mimicked by Clang modules "
"as in the following example:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2085
msgid "This example is simplified when using libc++:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2091
msgid ""
"because libc++ already supplies a `module map <https://github.com/llvm/llvm-"
"project/blob/main/libcxx/include/module.modulemap.in>`_."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2094
msgid ""
"This raises the question: why are header units not implemented through Clang "
"modules?"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2097
msgid ""
"This is primarily because Clang modules have more hierarchical semantics "
"when wrapping multiple headers together as one module, which is not "
"supported by Standard C++ Header units. We want to avoid the impression that "
"these additional semantics get interpreted as Standard C++ behavior."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2102
msgid ""
"Another reason is that there are proposals to introduce module mappers to "
"the C++ standard (for example, https://wg21.link/p1184r2). Reusing Clang's "
"``modulemap`` may be more difficult if we need to introduce another module "
"mapper."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2108
msgid "Discovering Dependencies"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2110
msgid ""
"Without use of modules, all the translation units in a project can be "
"compiled in parallel. However, the presence of module units requires "
"compiling the translation units in a topological order."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2114
msgid ""
"The ``clang-scan-deps`` tool can extract dependency information and produce "
"a JSON file conforming to the specification described in `P1689 <https://www."
"open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1689r5.html>`_. Only named "
"modules are supported currently."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2119
msgid ""
"A compilation database is needed when using ``clang-scan-deps``. See `JSON "
"Compilation Database Format Specification <JSONCompilationDatabase.html>`_ "
"for more information about compilation databases. Note that the ``output`` "
"JSON attribute is necessary for ``clang-scan-deps`` to scan using the P1689 "
"format. For example:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2166
msgid "And here is the compilation database:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2203
msgid "To get the dependency information in P1689 format, use:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2209
msgid "to get:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2287
msgid "See the P1689 paper for the meaning of the fields."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2289
msgid ""
"Getting dependency information per file with finer-grained control (such as "
"scanning generated source files) is possible. For example:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2296
#: ../../../StandardCPlusPlusModules.rst:2338
msgid "will produce:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2322
msgid ""
"Individual command line options can be specified after ``--``. ``clang-scan-"
"deps`` will extract the necessary information from the specified options. "
"Note that the path to the compiler executable needs to be specified "
"explicitly instead of using ``clang++`` directly."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2327
msgid ""
"Users may want the scanner to get the transitive dependency information for "
"headers. Otherwise, the project has to be scanned twice, once for headers "
"and once for modules. To address this, ``clang-scan-deps`` will recognize "
"the specified preprocessor options in the given command line and generate "
"the corresponding dependency information. For example:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2350
msgid ""
"When ``clang-scan-deps`` detects the ``-MF`` option, it will try to write "
"the dependency information for headers to the file specified by ``-MF``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2354
msgid "Possible Issues: Failed to find system headers"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2356
msgid ""
"If encountering an error like ``fatal error: 'stddef.h' file not found``, "
"the specified ``<path-to-compiler-executable>/clang++`` probably refers to a "
"symlink instead of a real binary. There are four potential solutions to the "
"problem:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2361
msgid ""
"Point the specified compiler executable to the real binary instead of the "
"symlink."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2363
msgid ""
"Invoke ``<path-to-compiler-executable>/clang++ -print-resource-dir`` to get "
"the corresponding resource directory for your compiler and add that "
"directory to the include search paths manually in the build scripts."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2366
msgid ""
"For build systems that use a compilation database as the input for ``clang-"
"scan-deps``, the build system can add the ``--resource-dir-recipe invoke-"
"compiler`` option when executing ``clang-scan-deps`` to calculate the "
"resource directory dynamically. The calculation happens only once for a "
"unique ``<path-to-compiler-executable>/clang++``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2371
msgid ""
"For build systems that invoke ``clang-scan-deps`` per file, repeatedly "
"calculating the resource directory may be inefficient. In such cases, the "
"build system can cache the resource directory and specify ``-resource-dir "
"<resource-dir>`` explicitly, as in:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2382
msgid "Import modules with clang-repl"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2384
msgid "``clang-repl`` supports importing C++20 named modules. For example:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2394
msgid "The named module still needs to be compiled ahead of time."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2402
msgid ""
"Note that the module unit needs to be compiled as a dynamic library so that "
"``clang-repl`` can load the object files of the module units. Then it is "
"possible to import module ``M`` in clang-repl."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2418
msgid "Possible Questions"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2421
msgid "How modules speed up compilation"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2423
msgid ""
"A classic theory for the reason why modules speed up the compilation is: if "
"there are ``n`` headers and ``m`` source files and each header is included "
"by each source file, then the complexity of the compilation is ``O(n*m)``. "
"However, if there are ``n`` module interfaces and ``m`` source files, the "
"complexity of the compilation is ``O(n+m)``. Therefore, using modules would "
"be a significant improvement at scale. More simply, use of modules causes "
"many of the redundant compilations to no longer be necessary."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2431
msgid ""
"While this is accurate at a high level, this depends greatly on the "
"optimization level, as illustrated below."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2434
msgid ""
"First is ``-O0``. The compilation process is described in the following "
"graph."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2456
msgid ""
"In this case, the source file (which could be a non-module unit or a module "
"unit) would get processed by the entire pipeline. However, the imported code "
"would only get involved in semantic analysis, which, for the most part, is "
"name lookup, overload resolution, and template instantiation. All of these "
"processes are fast relative to the whole compilation process. More "
"importantly, the imported code only needs to be processed once during "
"frontend code generation, as well as the whole middle end and backend. So we "
"could get a big win for the compilation time in ``-O0``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2465
msgid ""
"But with optimizations, things are different (the ``code generation`` part "
"for each end is omitted due to limited space):"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2487
msgid ""
"It would be very unfortunate if we end up with worse performance when using "
"modules. The main concern is that when a source file is compiled, the "
"compiler needs to see the body of imported module units so that it can "
"perform IPO (InterProcedural Optimization, primarily inlining in practice) "
"to optimize functions in the current source file with the help of the "
"information provided by the imported module units. In other words, the "
"imported code would be processed again and again in importee units by "
"optimizations (including IPO itself). The optimizations before IPO and IPO "
"itself are the most time-consuming part in whole compilation process. So "
"from this perspective, it might not be possible to get the compile time "
"improvements described, but there could be time savings for optimizations "
"after IPO and the whole backend."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2499
msgid ""
"Overall, at ``-O0`` the implementations of functions defined in a module "
"will not impact module users, but at higher optimization levels the "
"definitions of such functions are provided to user compilations for the "
"purposes of optimization (but definitions of these functions are still not "
"included in the use's object file). This means the build speedup at higher "
"optimization levels may be lower than expected given ``-O0`` experience, but "
"does provide more optimization opportunities."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2508
msgid "Interoperability with Clang Modules"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2510
msgid ""
"We **wish** to support Clang modules and standard C++ modules at the same "
"time, but the mixing them together is not well used/tested yet. Please file "
"new GitHub issues as you find interoperability problems."
msgstr ""
