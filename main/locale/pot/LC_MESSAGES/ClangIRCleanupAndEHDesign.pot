# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2026, The Clang Team
# This file is distributed under the same license as the Clang package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Clang main\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-16 08:35+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../ClangIRCleanupAndEHDesign.md:1
msgid "ClangIR Cleanup and Exception Handling Design"
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:3
msgid "::: {.contents local=\"\"} :::"
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:6
msgid "Overview"
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:8
msgid ""
"This document describes the design for C++ cleanups and exception handling "
"representation and lowering in the CIR dialect. The initial CIR generation "
"will follow the general structure of the cleanup and exception handling code "
"in Clang's LLVM IR generation. In particular, we will continue to use the "
"`EHScopeStack` with pushing and popping of `EHScopeStack::Cleanup` objects "
"to drive the creation of cleanup scopes within CIR."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:16
msgid ""
"However, the LLVM IR generated by Clang is fundamentally unstructured and "
"therefore isn't well suited to the goals of CIR. Therefore, we are proposing "
"a high-level representation that follows MLIR's structured control flow "
"model."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:21
msgid ""
"The `cir::LowerCFG` pass will lower this high-level representation to a "
"different form where control flow is block-based and explicit. This form "
"will more closely resemble the LLVM IR used when Clang is generating LLVM IR "
"directly. However, this form will still be ABI-agnostic."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:26
msgid ""
"An additional pass will be introduced to lower the flattened form to an ABI-"
"specific representation. This ABI-specific form will have a direct "
"correspondence to the LLVM IR exception handling representation for a given "
"target."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:31
msgid "High-level CIR representation"
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:33
msgid "Normal and EH cleanups"
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:35
msgid ""
"Scopes that require normal or EH cleanup will be represented using a new "
"operation, `cir.cleanup.scope`."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:46
msgid ""
"Execution begins with the first operation in the body region and continues "
"according to normal control flow semantics until a terminating operation "
"(`cir.yield`, `cir.break`, `cir.return`, `cir.continue`) is encountered or "
"an exception is thrown."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:51
msgid ""
"If the cleanup region is marked as `eh_only`, normal control flow exits from "
"the body region skip the cleanup region and continue to their normal "
"destination according to the semantics of the operation. If the cleanup "
"region is not marked as `eh_only`, normal control flow exits from the body "
"region must execute the cleanup region before control is transferred to the "
"destination implied by the operation."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:58
msgid ""
"If a `cir.goto` operation occurs within a cleanup scope, the behavior "
"depends on the target of the operation. If the target is within the same "
"cleanup scope, control is transferred to the target block directly. If the "
"target is not within the cleanup scope, control is transferred to the "
"cleanup region according to the rules described above for normal exits "
"before branching to the destination of the goto operation."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:65
msgid ""
"While we do not expect to encounter `cir.br` or `cir.brcond` operations that "
"exit a cleanup scope, if such a thing did happen, it would follow the rules "
"described above for `cir.goto` operations."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:69
msgid ""
"The `cir.indirect_br` operation is not permitted within a cleanup scope."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:71
msgid ""
"When an exception is thrown from within a cleanup scope and not caught "
"within the scope, the cleanup region must be executed before handling of the "
"exception continues. If the cleanup scope is nested within another cleanup "
"scope, the cleanup region of the inner scope is executed, followed by the "
"cleanup region of the outer scope, and handling continues according to these "
"rules. If the cleanup scope is nested within a try operation, the cleanup "
"region is executed before control is transferred to the catch handlers. If "
"an exception is thrown from within a cleanup region that is not nested "
"within either another cleanup region or a try operation, the cleanup region "
"is executed and then exception unwinding continues as if a `cir.resume` "
"operation had been executed."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:83
msgid ""
"If a `cir.resume` operation occurs within a cleanup scope, for example, if "
"the scope contains a try operation with uncaught exception types, the `cir."
"resume` operation will unwind to the cleanup region of the enclosing cleanup "
"scope."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:88
msgid ""
"Note that this design eliminates the need for synthetic try operations, such "
"as were used to represent calls within a cleanup scope in the ClangIR "
"incubator project."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:92
#: ../../../ClangIRCleanupAndEHDesign.md:201
msgid "Implementation notes"
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:94
msgid ""
"The `cir.cleanup.scope` must be created when we call `pushCleanup`. We will "
"need to set the insertion point at that time. When each cleanup block is "
"popped, we will need to set the insertion point to immediately following the "
"cleanup scope operation. If `forceCleanups()` is called, it will pop cleanup "
"blocks, which is good."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:100
msgid "Example: Automatic storage object cleanup"
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:102
#: ../../../ClangIRCleanupAndEHDesign.md:144
#: ../../../ClangIRCleanupAndEHDesign.md:211
#: ../../../ClangIRCleanupAndEHDesign.md:305
#: ../../../ClangIRCleanupAndEHDesign.md:383
#: ../../../ClangIRCleanupAndEHDesign.md:429
#: ../../../ClangIRCleanupAndEHDesign.md:478
#: ../../../ClangIRCleanupAndEHDesign.md:522
#: ../../../ClangIRCleanupAndEHDesign.md:773
#: ../../../ClangIRCleanupAndEHDesign.md:860
#: ../../../ClangIRCleanupAndEHDesign.md:916
msgid "**C++**"
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:111
#: ../../../ClangIRCleanupAndEHDesign.md:156
#: ../../../ClangIRCleanupAndEHDesign.md:228
#: ../../../ClangIRCleanupAndEHDesign.md:321
#: ../../../ClangIRCleanupAndEHDesign.md:395
#: ../../../ClangIRCleanupAndEHDesign.md:443
#: ../../../ClangIRCleanupAndEHDesign.md:491
#: ../../../ClangIRCleanupAndEHDesign.md:535
#: ../../../ClangIRCleanupAndEHDesign.md:933
msgid "**CIR**"
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:128
msgid ""
"In this example, we create an instance of `SomeClass` which has a "
"constructor and a destructor. If an exception occurs within the constructor "
"call, it unwinds without any handling in this function. The cleanup scope is "
"not entered in that case. Once the object has been constructed, we enter a "
"cleanup scope which continues until the object goes out of scope, in this "
"case for the remainder of the function."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:135
msgid ""
"If an exception is thrown from within the `doSomething()` function, we "
"execute the cleanup region, calling the `SomeClass` destructor before "
"continuing to unwind the exception. If the call to `doSomething()` completes "
"successfully, the object goes out of scope and we execute the cleanup "
"region, calling the destructor, before continuing to the return operation."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:142
msgid "Example: Multiple automatic objects"
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:190
msgid ""
"In this example, we have three objects with automatic storage duration. The "
"destructor must be called for each object that has been constructed, and the "
"destructors must be called in reverse order of object creation. We guarantee "
"that by creating nested cleanup scopes as each object is constructed."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:196
msgid ""
"Normal execution control flows through the body region of each of the nested "
"cleanup scopes until the body of the innermost scope. Next, the cleanup "
"scopes are visited, calling the destructor once in each cleanup scope, in "
"reverse order of the object construction."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:203
msgid ""
"Branch through cleanups will be handled during flattening. In the structured "
"CIR representation, an operation like `cir.break`, `cir.return`, or `cir."
"continue` has well-defined behavior. We will need to define the semantics "
"such that they include visiting the cleanup region before continuing to "
"their currently defined destination."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:209
msgid "Example: Branch through cleanup"
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:279
msgid ""
"In this example we have a cleanup scope inside the body of a `while-loop`, "
"and multiple instructions that may exit the loop body with different "
"destinations. When the `cir.continue` operation is executed, it will "
"transfer control to the cleanup region, which calls the object destructor "
"before transferring control to the while condition region according to the "
"semantics of the `cir.continue` operation."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:286
msgid ""
"When the `cir.break` operation is executed, it will transfer control to the "
"cleanup region, which calls the object destructor before transferring "
"control to the operation following the while loop according to the semantics "
"of the `cir.break` operation."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:291
msgid ""
"If neither the `cir.continue` or `cir.break` operations are executed during "
"an iteration of the loop, when the end of the cleanup scope's body region is "
"reached, control will be transferred to the cleanup region, which calls the "
"object destructor before transferring control to the next operation "
"following the cleanup scope, in this case falling through to the `cir.yield` "
"operation to complete the loop iteration."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:298
msgid ""
"This control flow is implicit in the semantics of the CIR operations at this "
"point. When this CIR is flattened, explicit branches and a switch on "
"destination slots will be created, matching the LLVM IR control flow for "
"cleanup block sharing."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:303
msgid "Example: EH-only cleanup"
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:342
msgid ""
"In this example, the `Derived` constructor calls the `Base` constructor and "
"then calls a function which may throw an exception. If an exception is "
"thrown, we must call the `Base` destructor before continuing to unwind the "
"exception. However, if no exception is thrown, we do not call the "
"destructor. Therefore, this cleanup handler is marked as eh_only."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:348
msgid "Try Operations and Exception Handling"
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:350
msgid ""
"Try-catch blocks will be represented, as they are in the ClangIR incubator "
"project, using a `cir.try` operation."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:353
msgid ""
"The `cir.catch_param` operation is used to represent the capturing of the "
"exception object in an ABI-independent way. When the catch handler includes "
"a source variable representing the exception object, the result of the `cir."
"catch_param` operation will be stored to an alloca object for the source "
"variable.  If the handler is a catch-all, the `cir.catch_param` operation "
"will return a pointer to void, but this cannot be captured by a source "
"variable."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:360
msgid ""
"The first operation in a catch handler region must be a `cir.catch_param` "
"operation."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:376
msgid ""
"The operation consists of a try region, which contains the operations to be "
"executed during normal execution, and one or more handler regions, which "
"represent catch handlers or the fallback unwind for uncaught exceptions."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:381
msgid "Example: Simple try-catch"
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:417
msgid ""
"If the call to `f()` throws an exception that matches the handled type "
"(`std::exception&`), control will be transferred to the catch handler for "
"that type, which simply yields, continuing execution immediately after the "
"try operation."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:422
msgid ""
"If the call to `f()` throws any other type of exception, control will be "
"transferred to the unwind region, which simply continues unwinding the "
"exception at the next level, in this case, the handlers (if any) for the "
"function that called `someFunc()`."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:427
msgid "Example: Try-catch with catch all"
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:466
msgid ""
"In this case, if the call to `f()` throws an exception that matches the "
"handled type (`std::exception&`), everything works exactly as in the "
"previous example. Control will be transferred to the catch handler for that "
"type, which simply yields, continuing execution immediately after the try "
"operation."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:472
msgid ""
"If the call to `f()` throws any other type of exception, control will be "
"transferred to the catch all region, which also yields, continuing execution "
"immediately after the try operation."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:476
#: ../../../ClangIRCleanupAndEHDesign.md:771
#: ../../../ClangIRCleanupAndEHDesign.md:1115
#: ../../../ClangIRCleanupAndEHDesign.md:1331
msgid "Example: Try-catch with cleanup"
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:515
msgid ""
"In this case, an object that requires cleanup is instantiated inside the try "
"block scope. If the call to `doSomething()` throws an exception, the cleanup "
"region will be executed before control is transferred to the catch handler."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:520
msgid "Example: Try-catch within a cleanup region"
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:565
msgid ""
"In this case, the object that requires cleanup is instantiated outside the "
"try block scope, and not all exception types have catch handlers."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:568
msgid ""
"If the call to `doSomething()` throws an exception of type `std::"
"exception&`, control will be transferred to the catch handler, which will "
"simply continue execution at the point immediately following the try "
"operation, and the cleanup handler will be executed when the cleanup scope "
"is exited normally."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:574
msgid ""
"If the call to `doSomething()` throws any other exception of type, control "
"will be transferred to the unwind region, which executes `cir.resume` to "
"continue unwinding the exception. However, the cleanup region of the cleanup "
"scope will be executed before exception unwinding continues because we are "
"exiting the scope via the `cir.resume` operation."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:581
msgid "Partial Array Cleanup"
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:583
msgid ""
"Partial array cleanup is a special case because the details of array "
"construction and deletion are already encapsulated within high-level CIR "
"operations. When an array of objects is constructed, the constructor for "
"each object is called sequentially. If one of the constructors throws an "
"exception, we must call the destructor for each object that was previously "
"constructed in reverse order of their construction. In the high-level CIR "
"representation, we have a single operation, `cir.array.ctor` to represent "
"the array construction. Because the cleanup needed is entirely within the "
"scope of this operation, we can represent the cleanup by adding a cleanup "
"region to this operation."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:606
msgid ""
"This representation shows how a single instance of the object is initialized "
"and cleaned up. When the operation is transformed to a low-level form "
"(during `cir::LoweringPrepare`), these two regions will be expanded to a "
"loop within a `cir.cleanup.scope` for the initialization, and a loop within "
"the cleanup scope's cleanup region to perform the partial array cleanup, as "
"follows"
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:650
msgid ""
"Here, both the construction and cleanup loops use the same temporary pointer "
"variable to track their location. If an exception is thrown by one of the "
"constructor, the `__array_idx` variable will point to the object that was "
"being constructed when the exception was thrown. If the exception was thrown "
"during construction of the first object, `__array_idx` will point to the "
"start of the array, and so no destructor will be called. If an exception is "
"thrown during the constructor call for any other object, `__array_idx` will "
"not point to the start of the array, and so the cleanup region will "
"decrement the pointer, call the destructor for the previous object, and so "
"on until we reach the beginning of the array. This corresponds to the way "
"that partial array destruction is handled in Clang's LLVM IR codegen."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:663
msgid "CFG Flattening"
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:665
msgid ""
"Before CIR can be lowered to the LLVM dialect, the CFG must be flattened. "
"That is, functions must not contain nested regions, and all blocks in the "
"function must belong to the parent region. This state is formed by the `cir::"
"FlattenCFG` pass. This pass will need to transform the high-level CIR "
"representation described above to a flat form where cleanups and exception "
"handling are explicitly routed through blocks, which are shared as needed."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:673
msgid ""
"The CIR representation will remain ABI agnostic after the flattening pass. "
"The flattening pass will implement the semantics for branching through "
"cleanup regions using the same slot and dispatch mechanism used in Clang's "
"LLVM IR codegen."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:678
msgid "Exception Handling"
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:680
msgid ""
"Flattening the CIR for exception handling, including any cleanups that must "
"be performed during exception unwinding, requires some specialized CIR "
"operations. The operations that were used in the ClangIR incubator project "
"were closely matched to the Itanium exception handling ABI. In order to "
"achieve a representation that also works well for other ABIs, the following "
"new operations are being proposed: `cir.eh.initiate`, `cir.eh.dispatch`, "
"`cir.begin_cleanup`, `cir.end_cleanup`, `cir.begin_catch`, and `cir."
"end_catch`."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:689
msgid ""
"Any time a cir.call operation that may throw and exception appears within "
"the try region of a `cir.try` operation or within the body region of a `cir."
"cleanup.scope` with a cleanup region marked as an exception cleanup, the "
"call will be converted to a `cir.try_call` operation, with normal and unwind "
"destinations. The first operation in the unwind destination block must be a "
"`cir.eh.initiate` operation."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:696
msgid "`%eh_token = cir.eh.initiate [cleanup]`"
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:698
msgid ""
"If this destination includes cleanup code, the cleanup keyword will be "
"present, and the cleanup code will be executed before the exception is "
"dispatched to any handlers. The `cir.eh.initiate` operation returns a value "
"of type `!cir.eh_token`. This is an opaque value that will be used during "
"ABI-lowering. At this phase, it conceptually represents the exception that "
"was thrown and is passed as the argument to the `cir.begin_cleanup`, `cir."
"begin_catch`, and `cir.eh.dispatch` operations."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:719
msgid ""
"The `cir.eh.dispatch` operation behaves similarly to the LLVM IR switch "
"instruction. It takes as an argument a token that was returned by a previous "
"`cir.eh.initiate` operation. It then has a list of key-value pairs, where "
"the key is either a type identifier, the keyword catch_all, or the keyword "
"unwind and the value is a block to which execution should be transferred if "
"the key is matched. Although the example above shows both the catch_all and "
"unwind keyword, in practice only one or the other will be present, but the "
"operation is required to have one of these values."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:729
msgid ""
"When we are unwinding an exception with cleanups, the `cir.eh.initiate` "
"operation will be marked with the cleanup attribute and will be followed by "
"a branch to the cleanup block, passing the EH token as an operand to the "
"block. The cleanup block will begin with a call to `cir.begin_cleanup` which "
"returns a cleanup token."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:740
msgid ""
"This is followed by the operations to perform the cleanup and then a cir."
"end_cleanup operation."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:743
msgid "`cir.end_cleanup(%cleanup_token : !cir.cleanup_token)`"
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:745
msgid ""
"Finally, the cleanup block either branches to a catch dispatch block or "
"executes a `cir.resume` operation to continue unwinding the exception."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:748
msgid ""
"When an exception is caught, the catch block will receive the eh token for "
"the exception being caught as an argument, and the first operation of the "
"catch handling block must be a `cir.begin_catch` operation."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:757
msgid ""
"The `cir.begin_catch` operation returns two values: a new token that "
"uniquely identify this catch handler, and a pointer to the exception object. "
"All paths through the catch handler must converge on a single `cir."
"end_catch` operation, which marks the end of the handler. The `cir."
"begin_catch` replaces the `cir.catch_param` in the structured form, and the "
"exception object extracted from its return value should be stored to the "
"same alloca location as the return value of `cir.catch_param` was in the "
"structured representation."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:766
msgid "`cir.end_catch %catch_token`"
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:768
msgid ""
"The argument to the `cir.end_catch` operation is the token returned by the "
"`cir.begin_catch` operation."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:786
#: ../../../ClangIRCleanupAndEHDesign.md:869
msgid "**High-level CIR**"
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:810
#: ../../../ClangIRCleanupAndEHDesign.md:886
#: ../../../ClangIRCleanupAndEHDesign.md:984
#: ../../../ClangIRCleanupAndEHDesign.md:1117
#: ../../../ClangIRCleanupAndEHDesign.md:1192
#: ../../../ClangIRCleanupAndEHDesign.md:1333
#: ../../../ClangIRCleanupAndEHDesign.md:1395
msgid "**Flattened CIR**"
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:845
msgid ""
"In this example, the normal cleanup is performed in a different block than "
"the EH cleanup. This follows the pattern established by Clang's LLVM IR "
"codegen. Only the EH cleanup requires `cir.begin_cleanup` and `cir."
"end_cleanup` operations."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:850
msgid ""
"If the `SomeClass` constructor throws an exception, it unwinds to an EH "
"catch block (`^bb3`), which has excecutes a `cir.eh.initiate` operation "
"before branching to a shared catch dispatch block (`^bb6`)."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:854
msgid ""
"If the `doSomething()` function throws an exception, it unwinds to an EH "
"block `^bb4` that performs cleanup before branching to the shared catch "
"dispatch block (`^bb5`)."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:858
msgid "Example: Cleanup with unhandled exception"
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:909
msgid ""
"In this example, if `doSomething()` throws an exception, it unwinds to the "
"EH cleanup block (`^bb2`), which branches to `^bb3` to perform the cleanup, "
"but because we have no catch handler, we execute `cir.resume` after the "
"cleanup to unwind to the function that called `someFunc()`."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:914
msgid "Example: Shared cleanups"
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:1051
msgid ""
"In this example we have a cleanup scope inside the body of a while loop, and "
"multiple instructions that may exit the loop body with different "
"destinations. For simplicity, the example is shown without exception "
"handling."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:1056
msgid ""
"When any of the conditions that exit a loop iteration occur (continue, "
"break, or completion of an iteration), we set a cleanup destination slot to "
"a unique value and branch to a shared normal cleanup block. That block "
"performs the cleanup and then compares the cleanup destination slot value to "
"the set of expected constants and branches to the corresponding destination."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:1063
msgid ""
"For example, when the continue instruction is reached, we set the cleanup "
"destination slot (`%1`) to zero, branch to the shared cleanup block "
"(`^bb9`), which calls the `SomeClass` destructor, then uses `cir.switch."
"flat` to switch on the cleanup destination slot value and, finding it to be "
"zero, branches to the loop condition block (`^bb1`)."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:1069
msgid ""
"If none of the expected values is matched, the `cir.switch.flat` branches to "
"a block with a `cir.unreachable` operation. This corresponds to the behavior "
"of Clang's LLVM IR codegen."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:1073
msgid "ABI Lowering"
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:1075
msgid ""
"A new pass will be introduced to lower the flattened representation to lower "
"the ABI-agnostic flattened CIR representation to an ABI-specific form. This "
"will be a separate pass from the main CXXABI lowering pass, which runs "
"before CFG flattening. The ABI lowering pass will introduce personality "
"functions and ABI-specific exception handling operations."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:1081
msgid ""
"This new pass will make use of the `cir::CXXABI` interface class and ABI-"
"specific subclasses, but it will introduce a new set of interface methods "
"for use with the exception handling ABI."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:1085
msgid ""
"For each supported exception handling ABI, the operations and function calls "
"used will have a direct correspondence to the LLVM IR instructions and "
"runtime library functions used for that ABI. The LLVM IR exception handling "
"model is described in detail here: [LLVM Exception Handling](https://llvm."
"org/docs/ExceptionHandling.html)."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:1091
msgid ""
"A personality function attribute will be added to functions that require it "
"during the ABI lowering phase."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:1094
msgid "Itanium ABI Lowering"
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:1096
msgid ""
"The Itanium exception handling ABI representation replaces the `cir.eh."
"initiate` and `cir.eh.dispatch` operations with a `cir.eh.landingpad` "
"operation and a series of `cir.compare` and `cir.brcond` operations to model "
"the correct handling based on type IDs for the catch handlers. The `cir."
"begin_cleanup` and `cir.end_cleanup` operations are simply dropped. The `cir."
"begin_catch` operation becomes a call to `__cxa_begin_catch`. The `cir."
"end_catch` operation becomes a call to `__cxa_end_catch`."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:1105
msgid ""
"The only operation that is specific to Itanium exception handling is `cir.eh."
"landingpad`."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:1108
msgid ""
"`%exn_ptr_0, %type_id = cir.eh.landingpad [@_ZTISt9exception] : !cir.ptr<!"
"void>, !u32i`"
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:1110
msgid ""
"This operation corresponds directly to the LLVM IR landingpad instruction. "
"It may have a list of type IDs that the handler can catch (or null for \\"
"\"catch all\\\") or it may have the cleanup attribute if the handler "
"performs cleanup but does not catch any exceptions."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:1152
#: ../../../ClangIRCleanupAndEHDesign.md:1225
#: ../../../ClangIRCleanupAndEHDesign.md:1368
#: ../../../ClangIRCleanupAndEHDesign.md:1428
msgid "**ABI-lowered CIR**"
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:1183
msgid ""
"In this example, if an exception is thrown by the `SomeClass` constructor, "
"it unwinds to a landing pad block (`^bb3`), which branches to the shared "
"catch dispatch block (`^bb6`), which branches to the catch all handler block "
"(`^bb7`). The catch all handler calls `__cxa_begin_catch` and "
"`__cxa_end_catch` and then continues to the normal continuation block "
"(`^bb8`)."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:1190
#: ../../../ClangIRCleanupAndEHDesign.md:1393
msgid "Example: Try-catch with multiple catch handlers"
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:1260
msgid ""
"In this example, if an exception is thrown by the `f()` call, it unwinds to "
"a landing pad block (`^bb2`), which uses the `cir.eh.landingpad` operation "
"to capture the exception pointer and its type id, then branches to `^bb3` to "
"begin searching for a catch handler that handles the type id of the "
"exception. Each catch handler simply consumes the exception by calling "
"`__cxa_begin_catch` and `__cxa_end_catch` and then continues to the normal "
"continuation block (`^bb8`)."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:1268
msgid "Microsoft C++ ABI Lowering"
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:1270
msgid ""
"The Microsoft C++ exception handling ABI representation drops the `cir.eh."
"initiate` operation and replaces the `cir.eh.dispatch` operation with `cir."
"eh.catchswitch` operation. The `cir.begin_cleanup` and `cir.end_cleanup` "
"operations are replaced with `cir.cleanuppad` and `cir.cleanupret` "
"respectively, and the `cir.begin_catch` and `cir.end_catch` operations are "
"replaced with `cir.catchpad` and `cir.catchret`."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:1278
msgid ""
"Each of these operations corresponds directly to a similarly named "
"instruction in LLVM IR and have the same semantics. The first operation in "
"the unwind destination of a `cir.try_call` must be either `cir.eh."
"catchswitch` or `cir.cleanuppad`."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:1283
msgid "`%4 = cir.eh.catchswitch within none [^bb2, ^bb3] unwind to caller`"
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:1285
msgid ""
"The `cir.eh.catchswitch` operation takes an operand which specifies the "
"parent token, which may either be none or the token returned by a previous "
"`cir.catchpad` operation. This is followed by a list of blocks which contain "
"catch handlers. Each block in this list must begin with a `cir.catchpad` "
"operation. Finally, the unwind destination is provided to specify where "
"excution continues if the exception is not caught by any of the handlers, "
"with unwind to caller indicating that the unwind is not handled further in "
"the current function. This operation returns a token that is used as the "
"operand for `cir.catchpad` operations associated with this switch."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:1296
msgid "`%5 = cir.cleanuppad within none []`"
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:1298
msgid ""
"The `cir.cleanuppad` operation takes an operand which specifies the parent "
"token, which may either be none or the token returned by a previous `cir."
"catchpad` operation. This is followed by a arguments required by the "
"personality function. In the case of C++ exception handlers, the personality "
"function will be `__CxxFrameHandler3` and the argument list will be empty. "
"This operation returns a token that is used as the operand for the "
"associated `cir.cleanupret` operation."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:1306
msgid "`cir.cleanupret from %5 unwind to ^bb7`"
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:1308
msgid ""
"The `cir.cleanupret` operation takes an operand which specifies the `cir."
"cleanuppad` operation which is completed by this operation and a block at "
"which unwinding of the current exception continues (or unwind to caller if "
"there is no catch handling in the current function)."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:1313
msgid "`%8 = cir.catchpad within %4 [ptr @\"??_R0H@8\", i32 0, ptr %e]`"
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:1315
msgid ""
"The `cir.catchpad` operation takes an operand which specifies the parent "
"token, which must have been return by a previous `cir.catchswitch` "
"operation. This is followed by a list of arguments, beginning with the "
"typeid for the type of exception being caught (or null for catch all), "
"followed by a type info flag value, followed by a pointer to the in-flight "
"exception. This operation returns a token that is used as the operand for "
"the associated `cir.catchret` operation or as the parent for any `cir."
"catchswitch` or `cir.cleanuppad` operations that are nested within this "
"catch handler."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:1325
msgid "`cir.catchret from %8 to ^bb8`"
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:1327
msgid ""
"The `cir.catchret` operation takes an operand which specifies the `cir."
"catchpad` operation which is completed by this operation and a block at "
"which excution should be resumed."
msgstr ""

#: ../../../ClangIRCleanupAndEHDesign.md:1451
msgid ""
"In this example, if an exception is thrown by the `f()` call, it unwinds to "
"a catch dispatch block (`^bb2`), which uses the `cir.catchswitch` operation "
"to dispatch to a catch handler (`^bb3`, `^bb4`, or `^bb5`) based on the type "
"id of the exception. The actual comparisons in this case will be handled by "
"the personality function, using tables that are generated from the `cir."
"catchpad` operations. Each catch handler simply continues to the normal "
"continuation block (`^bb6`) using the `cir.catchret` operation."
msgstr ""
