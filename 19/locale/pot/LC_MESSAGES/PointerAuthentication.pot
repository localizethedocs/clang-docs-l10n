# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2025, The Clang Team
# This file is distributed under the same license as the Clang package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Clang 19\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-13 13:41+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../PointerAuthentication.rst:2
msgid "Pointer Authentication"
msgstr ""

#: ../../../PointerAuthentication.rst:8
msgid "Introduction"
msgstr ""

#: ../../../PointerAuthentication.rst:10
msgid ""
"Pointer authentication is a technology which offers strong probabilistic "
"protection against exploiting a broad class of memory bugs to take control "
"of program execution.  When adopted consistently in a language ABI, it "
"provides a form of relatively fine-grained control flow integrity (CFI) "
"check that resists both return-oriented programming (ROP) and jump-oriented "
"programming (JOP) attacks."
msgstr ""

#: ../../../PointerAuthentication.rst:17
msgid ""
"While pointer authentication can be implemented purely in software, direct "
"hardware support (e.g. as provided by Armv8.3 PAuth) can dramatically "
"improve performance and code size.  Similarly, while pointer authentication "
"can be implemented on any architecture, taking advantage of the (typically) "
"excess addressing range of a target with 64-bit pointers minimizes the "
"impact on memory performance and can allow interoperation with existing code "
"(by disabling pointer authentication dynamically).  This document will "
"generally attempt to present the pointer authentication feature independent "
"of any hardware implementation or ABI.  Considerations that are "
"implementation-specific are clearly identified throughout."
msgstr ""

#: ../../../PointerAuthentication.rst:28
msgid "Note that there are several different terms in use:"
msgstr ""

#: ../../../PointerAuthentication.rst:30
msgid "**Pointer authentication** is a target-independent language technology."
msgstr ""

#: ../../../PointerAuthentication.rst:32
msgid ""
"**PAuth** (sometimes referred to as **PAC**, for Pointer Authentication "
"Codes) is an AArch64 architecture extension that provides hardware support "
"for pointer authentication.  Additional extensions either modify some of the "
"PAuth instruction behavior (notably FPAC), or provide new instruction "
"variants (PAuth_LR)."
msgstr ""

#: ../../../PointerAuthentication.rst:38
msgid ""
"**Armv8.3** is an AArch64 architecture revision that makes PAuth mandatory."
msgstr ""

#: ../../../PointerAuthentication.rst:40
msgid ""
"**arm64e** is a specific ABI (not yet fully stable) for implementing pointer "
"authentication using PAuth on certain Apple operating systems."
msgstr ""

#: ../../../PointerAuthentication.rst:43
msgid "This document serves four purposes:"
msgstr ""

#: ../../../PointerAuthentication.rst:45
msgid "It describes the basic ideas of pointer authentication."
msgstr ""

#: ../../../PointerAuthentication.rst:47
msgid ""
"It documents several language extensions that are useful on targets using "
"pointer authentication."
msgstr ""

#: ../../../PointerAuthentication.rst:50
msgid ""
"It will eventually present a theory of operation for the security "
"mitigation, describing the basic requirements for correctness, various "
"weaknesses in the mechanism, and ways in which programmers can strengthen "
"its protections (including recommendations for language implementors)."
msgstr ""

#: ../../../PointerAuthentication.rst:55
msgid ""
"It will eventually document the language ABIs currently used for C, C++, "
"Objective-C, and Swift on arm64e, although these are not yet stable on any "
"target."
msgstr ""

#: ../../../PointerAuthentication.rst:60
msgid "Basic Concepts"
msgstr ""

#: ../../../PointerAuthentication.rst:62
msgid ""
"The simple address of an object or function is a **raw pointer**.  A raw "
"pointer can be **signed** to produce a **signed pointer**.  A signed pointer "
"can be then **authenticated** in order to verify that it was **validly "
"signed** and extract the original raw pointer.  These terms reflect the most "
"likely implementation technique: computing and storing a cryptographic "
"signature along with the pointer."
msgstr ""

#: ../../../PointerAuthentication.rst:69
msgid ""
"An **abstract signing key** is a name which refers to a secret key which is "
"used to sign and authenticate pointers.  The concrete key value for a "
"particular name is consistent throughout a process."
msgstr ""

#: ../../../PointerAuthentication.rst:73
msgid ""
"A **discriminator** is an arbitrary value used to **diversify** signed "
"pointers so that one validly-signed pointer cannot simply be copied over "
"another. A discriminator is simply opaque data of some implementation-"
"defined size that is included in the signature as a salt (see "
"`Discriminators`_ for details.)"
msgstr ""

#: ../../../PointerAuthentication.rst:78
msgid ""
"Nearly all aspects of pointer authentication use just these two primary "
"operations:"
msgstr ""

#: ../../../PointerAuthentication.rst:81
msgid ""
"``sign(raw_pointer, key, discriminator)`` produces a signed pointer given a "
"raw pointer, an abstract signing key, and a discriminator."
msgstr ""

#: ../../../PointerAuthentication.rst:84
msgid ""
"``auth(signed_pointer, key, discriminator)`` produces a raw pointer given a "
"signed pointer, an abstract signing key, and a discriminator."
msgstr ""

#: ../../../PointerAuthentication.rst:87
msgid ""
"``auth(sign(raw_pointer, key, discriminator), key, discriminator)`` must "
"succeed and produce ``raw_pointer``.  ``auth`` applied to a value that was "
"ultimately produced in any other way is expected to fail, which halts the "
"program either:"
msgstr ""

#: ../../../PointerAuthentication.rst:92
msgid ""
"immediately, on implementations that enforce ``auth`` success (e.g., when "
"using compiler-generated ``auth`` failure checks, or Armv8.3 with the FPAC "
"extension), or"
msgstr ""

#: ../../../PointerAuthentication.rst:96
msgid ""
"when the resulting pointer value is used, on implementations that don't."
msgstr ""

#: ../../../PointerAuthentication.rst:98
msgid ""
"However, regardless of the implementation's handling of ``auth`` failures, "
"it is permitted for ``auth`` to fail to detect that a signed pointer was not "
"produced in this way, in which case it may return anything; this is what "
"makes pointer authentication a probabilistic mitigation rather than a "
"perfect one."
msgstr ""

#: ../../../PointerAuthentication.rst:103
msgid ""
"There are two secondary operations which are required only to implement "
"certain intrinsics in ``<ptrauth.h>``:"
msgstr ""

#: ../../../PointerAuthentication.rst:106
msgid ""
"``strip(signed_pointer, key)`` produces a raw pointer given a signed pointer "
"and a key without verifying its validity, unlike ``auth``.  This is useful "
"for certain kinds of tooling, such as crash backtraces; it should generally "
"not be used in the basic language ABI except in very careful ways."
msgstr ""

#: ../../../PointerAuthentication.rst:111
msgid ""
"``sign_generic(value)`` produces a cryptographic signature for arbitrary "
"data, not necessarily a pointer.  This is useful for efficiently verifying "
"that non-pointer data has not been tampered with."
msgstr ""

#: ../../../PointerAuthentication.rst:115
msgid ""
"Whenever any of these operations is called for, the key value must be known "
"statically.  This is because the layout of a signed pointer may vary "
"according to the signing key.  (For example, in Armv8.3, the layout of a "
"signed pointer depends on whether Top Byte Ignore (TBI) is enabled, which "
"can be set independently for I and D keys.)"
msgstr ""

#: ../../../PointerAuthentication.rst:121
msgid "Note for API designers and language implementors"
msgstr ""

#: ../../../PointerAuthentication.rst:123
msgid ""
"These are the *primitive* operations of pointer authentication, provided for "
"clarity of description.  They are not suitable either as high-level "
"interfaces or as primitives in a compiler IR because they expose raw "
"pointers.  Raw pointers require special attention in the language "
"implementation to avoid the accidental creation of exploitable code "
"sequences."
msgstr ""

#: ../../../PointerAuthentication.rst:130
msgid "The following details are all implementation-defined:"
msgstr ""

#: ../../../PointerAuthentication.rst:132
msgid "the nature of a signed pointer"
msgstr ""

#: ../../../PointerAuthentication.rst:133
msgid "the size of a discriminator"
msgstr ""

#: ../../../PointerAuthentication.rst:134
msgid "the number and nature of the signing keys"
msgstr ""

#: ../../../PointerAuthentication.rst:135
msgid ""
"the implementation of the ``sign``, ``auth``, ``strip``, and "
"``sign_generic`` operations"
msgstr ""

#: ../../../PointerAuthentication.rst:138
msgid ""
"While the use of the terms \"sign\" and \"signed pointer\" suggest the use "
"of a cryptographic signature, other implementations may be possible.  See "
"`Alternative implementations`_ for an exploration of implementation options."
msgstr ""

#: ../../../PointerAuthentication.rst:142
msgid "Implementation example: Armv8.3"
msgstr ""

#: ../../../PointerAuthentication.rst:144
msgid ""
"Readers may find it helpful to know how these terms map to Armv8.3 PAuth:"
msgstr ""

#: ../../../PointerAuthentication.rst:146
msgid ""
"A signed pointer is a pointer with a signature stored in the otherwise-"
"unused high bits.  The kernel configures the address width based on the "
"system's addressing needs, and enables TBI for I or D keys as needed.  The "
"bits above the address bits and below the TBI bits (if enabled) are unused.  "
"The signature width then depends on this addressing configuration."
msgstr ""

#: ../../../PointerAuthentication.rst:153
msgid ""
"A discriminator is a 64-bit integer.  Constant discriminators are 16-bit "
"integers.  Blending a constant discriminator into an address consists of "
"replacing the top 16 bits of the pointer containing the address with the "
"constant.  Pointers used for blending purposes should only have address "
"bits, since higher bits will be at least partially overwritten with the "
"constant discriminator."
msgstr ""

#: ../../../PointerAuthentication.rst:160
msgid ""
"There are five 128-bit signing-key registers, each of which can only be "
"directly read or set by privileged code.  Of these, four are used for "
"signing pointers, and the fifth is used only for ``sign_generic``.  The key "
"data is simply a pepper added to the hash, not an encryption key, and so can "
"be initialized using random data."
msgstr ""

#: ../../../PointerAuthentication.rst:166
msgid ""
"``sign`` computes a cryptographic hash of the pointer, discriminator, and "
"signing key, and stores it in the high bits as the signature. ``auth`` "
"removes the signature, computes the same hash, and compares the result with "
"the stored signature.  ``strip`` removes the signature without "
"authenticating it.  While ``aut*`` instructions do not themselves trap on "
"failure in Armv8.3 PAuth, they do with the later optional FPAC extension. An "
"implementation can also choose to emulate this trapping behavior by emitting "
"additional instructions around ``aut*``."
msgstr ""

#: ../../../PointerAuthentication.rst:175
msgid ""
"``sign_generic`` corresponds to the ``pacga`` instruction, which takes two "
"64-bit values and produces a 64-bit cryptographic hash. Implementations of "
"this instruction are not required to produce meaningful data in all bits of "
"the result."
msgstr ""

#: ../../../PointerAuthentication.rst:181
msgid "Discriminators"
msgstr ""

#: ../../../PointerAuthentication.rst:183
msgid ""
"A discriminator is arbitrary extra data which alters the signature "
"calculated for a pointer.  When two pointers are signed differently --- "
"either with different keys or with different discriminators --- an attacker "
"cannot simply replace one pointer with the other."
msgstr ""

#: ../../../PointerAuthentication.rst:188
msgid ""
"To use standard cryptographic terminology, a discriminator acts as a `salt "
"<https://en.wikipedia.org/wiki/Salt_(cryptography)>`_ in the signing of a "
"pointer, and the key data acts as a `pepper <https://en.wikipedia.org/wiki/"
"Pepper_(cryptography)>`_.  That is, both the discriminator and key data are "
"ultimately just added as inputs to the signing algorithm along with the "
"pointer, but they serve significantly different roles.  The key data is a "
"common secret added to every signature, whereas the discriminator is a value "
"that can be derived from the context in which a specific pointer is signed.  "
"However, unlike a password salt, it's important that discriminators be "
"*independently* derived from the circumstances of the signing; they should "
"never simply be stored alongside a pointer.  Discriminators are then re-"
"derived in authentication operations."
msgstr ""

#: ../../../PointerAuthentication.rst:201
msgid ""
"The intrinsic interface in ``<ptrauth.h>`` allows an arbitrary discriminator "
"value to be provided, but can only be used when running normal code.  The "
"discriminators used by language ABIs must be restricted to make it feasible "
"for the loader to sign pointers stored in global memory without needing "
"excessive amounts of metadata.  Under these restrictions, a discriminator "
"may consist of either or both of the following:"
msgstr ""

#: ../../../PointerAuthentication.rst:208
msgid ""
"The address at which the pointer is stored in memory.  A pointer signed with "
"a discriminator which incorporates its storage address is said to have "
"**address diversity**.  In general, using address diversity means that a "
"pointer cannot be reliably copied by an attacker to or from a different "
"memory location.  However, an attacker may still be able to attack a larger "
"call sequence if they can alter the address through which the pointer is "
"accessed.  Furthermore, some situations cannot use address diversity because "
"of language or other restrictions."
msgstr ""

#: ../../../PointerAuthentication.rst:217
msgid ""
"A constant integer, called a **constant discriminator**. A pointer signed "
"with a non-zero constant discriminator is said to have **constant "
"diversity**.  If the discriminator is specific to a single declaration, it "
"is said to have **declaration diversity**; if the discriminator is specific "
"to a type of value, it is said to have **type diversity**.  For example, C++ "
"v-tables on arm64e sign their component functions using a hash of their "
"method names and signatures, which provides declaration diversity; "
"similarly, C++ member function pointers sign their invocation functions "
"using a hash of the member pointer type, which provides type diversity."
msgstr ""

#: ../../../PointerAuthentication.rst:227
msgid ""
"The implementation may need to restrict constant discriminators to be "
"significantly smaller than the full size of a discriminator.  For example, "
"on arm64e, constant discriminators are only 16-bit values.  This is believed "
"to not significantly weaken the mitigation, since collisions remain uncommon."
msgstr ""

#: ../../../PointerAuthentication.rst:232
msgid ""
"The algorithm for blending a constant discriminator with a storage address "
"is implementation-defined."
msgstr ""

#: ../../../PointerAuthentication.rst:238
msgid "Signing Schemas"
msgstr ""

#: ../../../PointerAuthentication.rst:240
msgid ""
"Correct use of pointer authentication requires the signing code and the "
"authenticating code to agree about the **signing schema** for the pointer:"
msgstr ""

#: ../../../PointerAuthentication.rst:243
msgid "the abstract signing key with which the pointer should be signed and"
msgstr ""

#: ../../../PointerAuthentication.rst:244
msgid "an algorithm for computing the discriminator."
msgstr ""

#: ../../../PointerAuthentication.rst:246
msgid ""
"As described in the section above on `Discriminators`_, in most situations, "
"the discriminator is produced by taking a constant discriminator and "
"optionally blending it with the storage address of the pointer.  In these "
"situations, the signing schema breaks down even more simply:"
msgstr ""

#: ../../../PointerAuthentication.rst:251
msgid "the abstract signing key,"
msgstr ""

#: ../../../PointerAuthentication.rst:252
msgid "a constant discriminator, and"
msgstr ""

#: ../../../PointerAuthentication.rst:253
msgid "whether to use address diversity."
msgstr ""

#: ../../../PointerAuthentication.rst:255
msgid ""
"It is important that the signing schema be independently derived at all "
"signing and authentication sites.  Preferably, the schema should be hard-"
"coded everywhere it is needed, but at the very least, it must not be derived "
"by inspecting information stored along with the pointer."
msgstr ""

#: ../../../PointerAuthentication.rst:261
msgid "Language Features"
msgstr ""

#: ../../../PointerAuthentication.rst:263
msgid "There is currently one main pointer authentication language feature:"
msgstr ""

#: ../../../PointerAuthentication.rst:265
msgid ""
"The language provides the ``<ptrauth.h>`` intrinsic interface for manually "
"signing and authenticating pointers in code.  These can be used in "
"circumstances where very specific behavior is required."
msgstr ""

#: ../../../PointerAuthentication.rst:271
msgid "Language Extensions"
msgstr ""

#: ../../../PointerAuthentication.rst:274
msgid "Feature Testing"
msgstr ""

#: ../../../PointerAuthentication.rst:276
msgid ""
"Whether the current target uses pointer authentication can be tested for "
"with a number of different tests."
msgstr ""

#: ../../../PointerAuthentication.rst:279
msgid ""
"``__has_feature(ptrauth_intrinsics)`` is true if ``<ptrauth.h>`` provides "
"its normal interface.  This may be true even on targets where pointer "
"authentication is not enabled by default."
msgstr ""

#: ../../../PointerAuthentication.rst:284
msgid "``<ptrauth.h>``"
msgstr ""

#: ../../../PointerAuthentication.rst:286
msgid "This header defines the following types and operations:"
msgstr ""

#: ../../../PointerAuthentication.rst:289
msgid "``ptrauth_key``"
msgstr ""

#: ../../../PointerAuthentication.rst:291
msgid ""
"This ``enum`` is the type of abstract signing keys.  In addition to defining "
"the set of implementation-specific signing keys (for example, Armv8.3 "
"defines ``ptrauth_key_asia``), it also defines some portable aliases for "
"those keys. For example, ``ptrauth_key_function_pointer`` is the key "
"generally used for C function pointers, which will generally be suitable for "
"other function-signing schemas."
msgstr ""

#: ../../../PointerAuthentication.rst:298
msgid ""
"In all the operation descriptions below, key values must be constant values "
"corresponding to one of the implementation-specific abstract signing keys "
"from this ``enum``."
msgstr ""

#: ../../../PointerAuthentication.rst:303
msgid "``ptrauth_extra_data_t``"
msgstr ""

#: ../../../PointerAuthentication.rst:305
msgid ""
"This is a ``typedef`` of a standard integer type of the correct size to hold "
"a discriminator value."
msgstr ""

#: ../../../PointerAuthentication.rst:308
msgid ""
"In the signing and authentication operation descriptions below, "
"discriminator values must have either pointer type or integer type. If the "
"discriminator is an integer, it will be coerced to ``ptrauth_extra_data_t``."
msgstr ""

#: ../../../PointerAuthentication.rst:313
msgid "``ptrauth_blend_discriminator``"
msgstr ""

#: ../../../PointerAuthentication.rst:319
msgid ""
"Produce a discriminator value which blends information from the given "
"pointer and the given integer."
msgstr ""

#: ../../../PointerAuthentication.rst:322
msgid ""
"Implementations may ignore some bits from each value, which is to say, the "
"blending algorithm may be chosen for speed and convenience over theoretical "
"strength as a hash-combining algorithm.  For example, arm64e simply "
"overwrites the high 16 bits of the pointer with the low 16 bits of the "
"integer, which can be done in a single instruction with an immediate integer."
msgstr ""

#: ../../../PointerAuthentication.rst:328
msgid ""
"``pointer`` must have pointer type, and ``integer`` must have integer type. "
"The result has type ``ptrauth_extra_data_t``."
msgstr ""

#: ../../../PointerAuthentication.rst:332
msgid "``ptrauth_string_discriminator``"
msgstr ""

#: ../../../PointerAuthentication.rst:338
msgid "Compute a constant discriminator from the given string."
msgstr ""

#: ../../../PointerAuthentication.rst:340
msgid ""
"``string`` must be a string literal of ``char`` character type.  The result "
"has type ``ptrauth_extra_data_t``."
msgstr ""

#: ../../../PointerAuthentication.rst:343
msgid ""
"The result value is never zero and always within range for both the "
"``__ptrauth`` qualifier and ``ptrauth_blend_discriminator``."
msgstr ""

#: ../../../PointerAuthentication.rst:346
#: ../../../PointerAuthentication.rst:376
msgid "This can be used in constant expressions."
msgstr ""

#: ../../../PointerAuthentication.rst:349
msgid "``ptrauth_strip``"
msgstr ""

#: ../../../PointerAuthentication.rst:355
msgid ""
"Given that ``signedPointer`` matches the layout for signed pointers signed "
"with the given key, extract the raw pointer from it.  This operation does "
"not trap and cannot fail, even if the pointer is not validly signed."
msgstr ""

#: ../../../PointerAuthentication.rst:360
msgid "``ptrauth_sign_constant``"
msgstr ""

#: ../../../PointerAuthentication.rst:366
msgid ""
"Return a signed pointer for a constant address in a manner which guarantees "
"a non-attackable sequence."
msgstr ""

#: ../../../PointerAuthentication.rst:369
msgid ""
"``pointer`` must be a constant expression of pointer type which evaluates to "
"a non-null pointer. ``key``  must be a constant expression of type "
"``ptrauth_key``. ``discriminator`` must be a constant expression of pointer "
"or integer type; if an integer, it will be coerced to "
"``ptrauth_extra_data_t``. The result will have the same type as ``pointer``."
msgstr ""

#: ../../../PointerAuthentication.rst:379
msgid "``ptrauth_sign_unauthenticated``"
msgstr ""

#: ../../../PointerAuthentication.rst:385
msgid ""
"Produce a signed pointer for the given raw pointer without applying any "
"authentication or extra treatment.  This operation is not required to have "
"the same behavior on a null pointer that the language implementation would."
msgstr ""

#: ../../../PointerAuthentication.rst:389
msgid ""
"This is a treacherous operation that can easily result in signing oracles. "
"Programs should use it seldom and carefully."
msgstr ""

#: ../../../PointerAuthentication.rst:393
msgid "``ptrauth_auth_and_resign``"
msgstr ""

#: ../../../PointerAuthentication.rst:399
msgid ""
"Authenticate that ``pointer`` is signed with ``oldKey`` and "
"``oldDiscriminator`` and then resign the raw-pointer result of that "
"authentication with ``newKey`` and ``newDiscriminator``."
msgstr ""

#: ../../../PointerAuthentication.rst:403
msgid ""
"``pointer`` must have pointer type.  The result will have the same type as "
"``pointer``.  This operation is not required to have the same behavior on a "
"null pointer that the language implementation would."
msgstr ""

#: ../../../PointerAuthentication.rst:407
msgid ""
"The code sequence produced for this operation must not be directly "
"attackable. However, if the discriminator values are not constant integers, "
"their computations may still be attackable.  In the future, Clang should be "
"enhanced to guaranteed non-attackability if these expressions are safely-"
"derived."
msgstr ""

#: ../../../PointerAuthentication.rst:413
msgid "``ptrauth_auth_data``"
msgstr ""

#: ../../../PointerAuthentication.rst:419
msgid ""
"Authenticate that ``pointer`` is signed with ``key`` and ``discriminator`` "
"and remove the signature."
msgstr ""

#: ../../../PointerAuthentication.rst:422
msgid ""
"``pointer`` must have object pointer type.  The result will have the same "
"type as ``pointer``.  This operation is not required to have the same "
"behavior on a null pointer that the language implementation would."
msgstr ""

#: ../../../PointerAuthentication.rst:426
msgid ""
"In the future when Clang makes safe derivation guarantees, the result of "
"this operation should be considered safely-derived."
msgstr ""

#: ../../../PointerAuthentication.rst:430
msgid "``ptrauth_sign_generic_data``"
msgstr ""

#: ../../../PointerAuthentication.rst:436
msgid ""
"Computes a signature for the given pair of values, incorporating a secret "
"signing key."
msgstr ""

#: ../../../PointerAuthentication.rst:439
msgid ""
"This operation can be used to verify that arbitrary data has not been "
"tampered with by computing a signature for the data, storing that signature, "
"and then repeating this process and verifying that it yields the same "
"result.  This can be reasonably done in any number of ways; for example, a "
"library could compute an ordinary checksum of the data and just sign the "
"result in order to get the tamper-resistance advantages of the secret "
"signing key (since otherwise an attacker could reliably overwrite both the "
"data and the checksum)."
msgstr ""

#: ../../../PointerAuthentication.rst:447
msgid ""
"``value1`` and ``value2`` must be either pointers or integers.  If the "
"integers are larger than ``uintptr_t`` then data not representable in "
"``uintptr_t`` may be discarded."
msgstr ""

#: ../../../PointerAuthentication.rst:451
msgid ""
"The result will have type ``ptrauth_generic_signature_t``, which is an "
"integer type.  Implementations are not required to make all bits of the "
"result equally significant; in particular, some implementations are known to "
"not leave meaningful data in the low bits."
msgstr ""

#: ../../../PointerAuthentication.rst:459
msgid "Alternative Implementations"
msgstr ""

#: ../../../PointerAuthentication.rst:462
msgid "Signature Storage"
msgstr ""

#: ../../../PointerAuthentication.rst:464
msgid ""
"It is not critical for the security of pointer authentication that the "
"signature be stored \"together\" with the pointer, as it is in Armv8.3. An "
"implementation could just as well store the signature in a separate word, so "
"that the ``sizeof`` a signed pointer would be larger than the ``sizeof`` a "
"raw pointer."
msgstr ""

#: ../../../PointerAuthentication.rst:470
msgid ""
"Storing the signature in the high bits, as Armv8.3 does, has several trade-"
"offs:"
msgstr ""

#: ../../../PointerAuthentication.rst:472
msgid ""
"Disadvantage: there are substantially fewer bits available for the "
"signature, weakening the mitigation by making it much easier for an attacker "
"to simply guess the correct signature."
msgstr ""

#: ../../../PointerAuthentication.rst:476
msgid ""
"Disadvantage: future growth of the address space will necessarily further "
"weaken the mitigation."
msgstr ""

#: ../../../PointerAuthentication.rst:479
msgid ""
"Advantage: memory layouts don't change, so it's possible for pointer-"
"authentication-enabled code (for example, in a system library) to "
"efficiently interoperate with existing code, as long as pointer "
"authentication can be disabled dynamically."
msgstr ""

#: ../../../PointerAuthentication.rst:484
msgid ""
"Advantage: the size of a signed pointer doesn't grow, which might "
"significantly increase memory requirements, code size, and register pressure."
msgstr ""

#: ../../../PointerAuthentication.rst:487
msgid ""
"Advantage: the size of a signed pointer is the same as a raw pointer, so "
"generic APIs which work in types like `void *` (such as `dlsym`) can still "
"return signed pointers.  This means that clients of these APIs will not "
"require insecure code in order to correctly receive a function pointer."
msgstr ""

#: ../../../PointerAuthentication.rst:493
msgid "Hashing vs. Encrypting Pointers"
msgstr ""

#: ../../../PointerAuthentication.rst:495
msgid ""
"Armv8.3 implements ``sign`` by computing a cryptographic hash and storing "
"that in the spare bits of the pointer.  This means that there are relatively "
"few possible values for the valid signed pointer, since the bits "
"corresponding to the raw pointer are known.  Together with an ``auth`` "
"oracle, this can make it computationally feasible to discover the correct "
"signature with brute force. (The implementation should of course endeavor "
"not to introduce ``auth`` oracles, but this can be difficult, and attackers "
"can be devious.)"
msgstr ""

#: ../../../PointerAuthentication.rst:503
msgid ""
"If the implementation can instead *encrypt* the pointer during ``sign`` and "
"*decrypt* it during ``auth``, this brute-force attack becomes far less "
"feasible, even with an ``auth`` oracle.  However, there are several problems "
"with this idea:"
msgstr ""

#: ../../../PointerAuthentication.rst:508
msgid ""
"It's unclear whether this kind of encryption is even possible without "
"increasing the storage size of a signed pointer.  If the storage size can be "
"increased, brute-force atacks can be equally well mitigated by simply "
"storing a larger signature."
msgstr ""

#: ../../../PointerAuthentication.rst:513
msgid ""
"It would likely be impossible to implement a ``strip`` operation, which "
"might make debuggers and other out-of-process tools far more difficult to "
"write, as well as generally making primitive debugging more challenging."
msgstr ""

#: ../../../PointerAuthentication.rst:517
msgid ""
"Implementations can benefit from being able to extract the raw pointer "
"immediately from a signed pointer.  An Armv8.3 processor executing an "
"``auth``-and-load instruction can perform the load and ``auth`` in parallel; "
"a processor which instead encrypted the pointer would be forced to perform "
"these operations serially."
msgstr ""
