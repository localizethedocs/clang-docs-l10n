# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2025, The Clang Team
# This file is distributed under the same license as the Clang package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Clang 19\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-13 13:41+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../StandardCPlusPlusModules.rst:3
msgid "Standard C++ Modules"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:9
msgid "Introduction"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:11
msgid ""
"The term ``module`` is ambiguous, as it is used to mean multiple things in "
"Clang. For Clang users, a module may refer to an ``Objective-C Module``, "
"`Clang Module <Modules.html>`_ (also called a ``Clang Header Module``) or a "
"``C++20 Module`` (or a ``Standard C++ Module``). The implementation of all "
"these kinds of modules in Clang shares a lot of code, but from the "
"perspective of users their semantics and command line interfaces are very "
"different. This document is an introduction to the use of C++20 modules in "
"Clang. In the remainder of this document, the term ``module`` will refer to "
"Standard C++20 modules and the term ``Clang module`` will refer to the Clang "
"Modules extension."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:22
msgid ""
"In terms of the C++ Standard, modules consist of two components: \"Named "
"Modules\" or \"Header Units\". This document covers both."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:26
msgid "Standard C++ Named modules"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:28
msgid ""
"In order to better understand the compiler's behavior, it is helpful to "
"understand some terms and definitions for readers who are not familiar with "
"the C++ feature. This document is not a tutorial on C++; it only introduces "
"necessary concepts to better understand use of modules in a project."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:34
msgid "Background and terminology"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:37
msgid "Module and module unit"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:39
msgid ""
"A module consists of one or more module units. A module unit is a special "
"kind of translation unit. A module unit should almost always start with a "
"module declaration. The syntax of the module declaration is:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:47
msgid ""
"Terms enclosed in ``[]`` are optional. ``module_name`` and "
"``partition_name`` follow the rules for a C++ identifier, except that they "
"may contain one or more period (``.``) characters. Note that a ``.`` in the "
"name has no semantic meaning and does not imply any hierarchy."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:52
msgid "In this document, module units are classified as:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:54
msgid "Primary module interface unit"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:55
msgid "Module implementation unit"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:56
msgid "Module partition interface unit"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:57
msgid "Internal module partition unit"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:59
msgid ""
"A primary module interface unit is a module unit whose module declaration is "
"``export module module_name;`` where ``module_name`` denotes the name of the "
"module. A module should have one and only one primary module interface unit."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:63
msgid ""
"A module implementation unit is a module unit whose module declaration is "
"``module module_name;``. Multiple module implementation units can be "
"declared in the same module."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:67
msgid ""
"A module partition interface unit is a module unit whose module declaration "
"is ``export module module_name:partition_name;``. The ``partition_name`` "
"should be unique within any given module."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:71
msgid ""
"An internal module partition unit is a module unit whose module declaration "
"is ``module module_name:partition_name;``. The ``partition_name`` should be "
"unique within any given module."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:75
msgid "In this document, we use the following terms:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:77
msgid ""
"A ``module interface unit`` refers to either a ``primary module interface "
"unit`` or a ``module partition interface unit``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:80
msgid ""
"An ``importable module unit`` refers to either a ``module interface unit`` "
"or an ``internal module partition unit``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:83
msgid ""
"A ``module partition unit`` refers to either a ``module partition interface "
"unit`` or an ``internal module partition unit``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:87
msgid "Built Module Interface"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:89
msgid ""
"A ``Built Module Interface`` (or ``BMI``) is the precompiled result of an "
"importable module unit."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:93
msgid "Global module fragment"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:95
msgid ""
"The ``global module fragment`` (or ``GMF``) is the code between the ``module;"
"`` and the module declaration within a module unit."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:100
msgid "How to build projects using modules"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:103
#: ../../../StandardCPlusPlusModules.rst:1473
msgid "Quick Start"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:105
msgid "Let's see a \"hello world\" example that uses modules."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:124
msgid "Then, on the command line, invoke Clang like:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:133
msgid ""
"In this example, we make and use a simple module ``Hello`` which contains "
"only a primary module interface unit named ``Hello.cppm``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:136
msgid ""
"A more complex \"hello world\" example which uses the 4 kinds of module "
"units is:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:178
msgid "Then, back on the command line, invoke Clang with:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:197
msgid "We explain the options in the following sections."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:200
msgid "How to enable standard C++ modules"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:202
msgid ""
"Standard C++ modules are enabled automatically when the language standard "
"mode is ``-std=c++20`` or newer."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:206
msgid "How to produce a BMI"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:208
msgid ""
"To generate a BMI for an importable module unit, use either the ``--"
"precompile`` or ``-fmodule-output`` command line options."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:211
msgid ""
"The ``--precompile`` option generates the BMI as the output of the "
"compilation with the output path specified using the ``-o`` option."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:214
msgid ""
"The ``-fmodule-output`` option generates the BMI as a by-product of the "
"compilation. If ``-fmodule-output=`` is specified, the BMI will be emitted "
"to the specified location. If ``-fmodule-output`` and ``-c`` are specified, "
"the BMI will be emitted in the directory of the output file with the name of "
"the input file with the extension ``.pcm``. Otherwise, the BMI will be "
"emitted in the working directory with the name of the input file with the "
"extension ``.pcm``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:222
msgid ""
"Generating BMIs with ``--precompile`` is referred to as two-phase "
"compilation because it takes two steps to compile a source file to an object "
"file. Generating BMIs with ``-fmodule-output`` is called one-phase "
"compilation. The one-phase compilation model is simpler for build systems to "
"implement while the two-phase compilation has the potential to compile "
"faster due to higher parallelism. As an example, if there are two module "
"units ``A`` and ``B``, and ``B`` depends on ``A``, the one-phase compilation "
"model needs to compile them serially, whereas the two-phase compilation "
"model is able to be compiled as soon as ``A.pcm`` is available, and thus can "
"be compiled simultaneously as the ``A.pcm`` to ``A.o`` compilation step."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:234
msgid "File name requirements"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:236
msgid ""
"By convention, ``importable module unit`` files should use ``.cppm`` (or ``."
"ccm``, ``.cxxm``, or ``.c++m``) as a file extension. ``Module implementation "
"unit`` files should use ``.cpp`` (or ``.cc``, ``.cxx``, or ``.c++``) as a "
"file extension."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:241
msgid ""
"A BMI should use ``.pcm`` as a file extension. The file name of the BMI for "
"a ``primary module interface unit`` should be ``module_name.pcm``. The file "
"name of a BMI for a ``module partition unit`` should be ``module_name-"
"partition_name.pcm``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:246
msgid ""
"Clang may fail to build the module if different extensions are used. For "
"example, if the filename of an ``importable module unit`` ends with ``.cpp`` "
"instead of ``.cppm``, then Clang cannot generate a BMI for the ``importable "
"module unit`` with the ``--precompile`` option because the ``--precompile`` "
"option would only run the preprocessor (``-E``). If using a different "
"extension than the conventional one for an ``importable module unit`` you "
"can specify ``-x c++-module`` before the file. For example,"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:271
msgid ""
"In this example, the extension used by the ``module interface`` is ``.cpp`` "
"instead of ``.cppm``, so it cannot be compiled like the previous example, "
"but it can be compiled with:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:283
msgid "Module name requirements"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:287
msgid "[module.unit]p1:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:289
msgid ""
"All module-names either beginning with an identifier consisting of std "
"followed by zero or more digits or containing a reserved identifier ([lex."
"name]) are reserved and shall not be specified in a module-declaration; no "
"diagnostic is required. If any identifier in a reserved module-name is a "
"reserved identifier, the module name is reserved for use by C++ "
"implementations; otherwise it is reserved for future standardization."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:295
msgid "Therefore, none of the following names are valid by default:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:305
msgid ""
"Using a reserved module name is strongly discouraged, but ``-Wno-reserved-"
"module-identifier`` can be used to suppress the warning."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:309
msgid "Specifying dependent BMIs"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:311
msgid "There are 3 ways to specify a dependent BMI:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:313
msgid "``-fprebuilt-module-path=<path/to/directory>``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:314
msgid "``-fmodule-file=<path/to/BMI>`` (Deprecated)."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:315
msgid "``-fmodule-file=<module-name>=<path/to/BMI>``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:317
msgid ""
"The ``-fprebuilt-module-path`` option specifies the path to search for "
"dependent BMIs. Multiple paths may be specified, similar to using ``-I`` to "
"specify a search path for header files. When importing a module ``M``, the "
"compiler looks for ``M.pcm`` in the directories specified by ``-fprebuilt-"
"module-path``. Similarly, when importing a partition module unit ``M:P``, "
"the compiler looks for ``M-P.pcm`` in the directories specified by ``-"
"fprebuilt-module-path``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:325
msgid ""
"The ``-fmodule-file=<path/to/BMI>`` option causes the compiler to load the "
"specified BMI directly. The ``-fmodule-file=<module-name>=<path/to/BMI>`` "
"option causes the compiler to load the specified BMI for the module "
"specified by ``<module-name>`` when necessary. The main difference is that "
"``-fmodule-file=<path/to/BMI>`` will load the BMI eagerly, whereas ``-"
"fmodule-file=<module-name>=<path/to/BMI>`` will only load the BMI lazily, as "
"will ``-fprebuilt-module-path``. The ``-fmodule-file=<path/to/BMI>`` option "
"for named modules is deprecated and will be removed in a future version of "
"Clang."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:335
msgid ""
"When these options are specified in the same invocation of the compiler, the "
"``-fmodule-file=<path/to/BMI>`` option takes precedence over ``-fmodule-"
"file=<module-name>=<path/to/BMI>``, which takes precedence over ``-fprebuilt-"
"module-path=<path/to/directory>``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:340
msgid ""
"Note: all dependant BMIs must be specified explicitly, either directly or "
"indirectly dependent BMIs explicitly. See https://github.com/llvm/llvm-"
"project/issues/62707 for details."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:344
msgid ""
"When compiling a ``module implementation unit``, the BMI of the "
"corresponding ``primary module interface unit`` must be specified because a "
"module implementation unit implicitly imports the primary module interface "
"unit."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:348
msgid "[module.unit]p8"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:350
msgid ""
"A module-declaration that contains neither an export-keyword nor a module-"
"partition implicitly imports the primary module interface unit of the module "
"as if by a module-import-declaration."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:353
msgid ""
"The ``-fprebuilt-module-path=<path/to/directory>``, ``-fmodule-file=<path/to/"
"BMI>``, and ``-fmodule-file=<module-name>=<path/to/BMI>`` options may be "
"specified multiple times. For example, the command line to compile ``M."
"cppm`` in the previous example could be rewritten as:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:362
msgid ""
"When there are multiple ``-fmodule-file=<module-name>=`` options for the "
"same ``<module-name>``, the last ``-fmodule-file=<module-name>=`` overrides "
"the previous ``-fmodule-file=<module-name>=`` option."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:367
msgid "Remember that module units still have an object counterpart to the BMI"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:369
msgid ""
"While module interfaces resemble traditional header files, they still "
"require compilation. Module units are translation units, and need to be "
"compiled to object files, which then need to be linked together as the "
"following examples show."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:374
msgid ""
"For example, the traditional compilation processes for headers are like:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:383
msgid "And the compilation process for module units are like:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:392
msgid ""
"As the diagrams show, we need to compile the BMI from module units to object "
"files and then link the object files. (However, this cannot be done for the "
"BMI from header units. See the section on :ref:`header units <header-units>` "
"for more details."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:397
msgid ""
"BMIs cannot be shipped in an archive to create a module library. Instead, "
"the BMIs(``*.pcm``) are compiled into object files(``*.o``) and those object "
"files are added to the archive instead."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:402
msgid "clang-cl"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:404
msgid ""
"``clang-cl`` supports the same options as ``clang++`` for modules as "
"detailed above; there is no need to prefix these options with ``/clang:``. "
"Note that ``cl.exe`` `options to emit/consume IFC files <https://devblogs."
"microsoft.com/cppblog/using-cpp-modules-in-msvc-from-the-command-line-part-1/"
">` are *not* supported. The resultant precompiled modules are also not "
"compatible for use with ``cl.exe``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:409
msgid ""
"We recommend that build system authors use the above-mentioned ``clang++`` "
"options  with ``clang-cl`` to build modules."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:412
msgid "Consistency Requirements"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:414
msgid ""
"Modules can be viewed as a kind of cache to speed up compilation. Thus, like "
"other caching techniques, it is important to maintain cache consistency "
"which is why Clang does very strict checking for consistency."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:419
msgid "Options consistency"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:421
msgid ""
"Compiler options related to the language dialect for a module unit and its "
"non-module-unit uses need to be consistent. Consider the following example:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:437
msgid ""
"Clang rejects the example due to the inconsistent language standard modes. "
"Not all compiler options are language dialect options, though. For example:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:448
msgid ""
"Although the optimization and debugging levels are inconsistent, these "
"compilations are accepted because the compiler options do not impact the "
"language dialect."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:452
msgid ""
"Note that the compiler **currently** doesn't reject inconsistent macro "
"definitions (this may change in the future). For example:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:461
msgid ""
"Currently, Clang accepts the above example, though it may produce surprising "
"results if the debugging code depends on consistent use of ``NDEBUG`` in "
"other translation units."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:466
msgid "Object definition consistency"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:468
msgid ""
"The C++ language requires that declarations of the same entity in different "
"translation units have the same definition, which is known as the One "
"Definition Rule (ODR). Without modules, the compiler cannot perform strong "
"ODR violation checking because it only sees one translation unit at a time. "
"With the use of modules, the compiler can perform checks for ODR violations "
"across translation units."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:475
msgid ""
"However, the current ODR checking mechanisms are not perfect. There are a "
"significant number of false positive ODR violation diagnostics, where the "
"compiler incorrectly diagnoses two identical declarations as having "
"different definitions. Further, true positive ODR violations are not always "
"reported."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:480
msgid ""
"To give a better user experience, improve compilation performance, and for "
"consistency with MSVC, ODR checking of declarations in the global module "
"fragment is disabled by default. These checks can be enabled by specifying "
"``-Xclang -fno-skip-odr-check-in-gmf`` when compiling. If the check is "
"enabled and you encounter incorrect or missing diagnostics, please report "
"them via the `community issue tracker <https://github.com/llvm/llvm-project/"
"issues/>`_."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:488
msgid "ABI Impacts"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:490
msgid ""
"This section describes the new ABI changes brought by modules. Only changes "
"to the Itanium C++ ABI are covered."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:494
msgid "Name Mangling"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:496
msgid ""
"The declarations in a module unit which are not in the global module "
"fragment have new linkage names."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:499
#: ../../../StandardCPlusPlusModules.rst:1260
msgid "For example,"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:508
msgid ""
"The linkage name of ``NS::foo()`` is ``_ZN2NSW1M3fooEv``. This couldn't be "
"demangled by previous versions of the debugger or demangler. As of LLVM 15."
"x, ``llvm-cxxfilt`` can be used to demangle this:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:517
msgid "The result should be read as ``NS::foo()`` in module ``M``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:519
msgid ""
"The ABI implies that something cannot be declared in a module unit and "
"defined in a non-module unit (or vice-versa), as this would result in "
"linking errors."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:522
msgid ""
"Despite this, it is possible to implement declarations with a compatible ABI "
"in a module unit by using a language linkage specifier because the "
"declarations in the language linkage specifier are attached to the global "
"module fragment. For example:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:534
msgid "Now the linkage name of ``NS::foo()`` will be ``_ZN2NS3fooEv``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:537
msgid "Module Initializers"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:539
msgid ""
"All importable module units are required to emit an initializer function to "
"handle the dynamic initialization of non-inline variables in the module "
"unit. The importable module unit has to emit the initializer even if there "
"is no dynamic initialization; otherwise, the importer may call a nonexistent "
"function. The initializer function emits calls to imported modules first "
"followed by calls to all to of the dynamic initializers in the current "
"module unit."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:547
msgid ""
"Translation units that explicitly or implicitly import a named module must "
"call the initializer functions of the imported named module within the "
"sequence of the dynamic initializers in the translation unit. "
"Initializations of entities at namespace scope are appearance-ordered. This "
"(recursively) extends to imported modules at the point of appearance of the "
"import declaration."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:553
msgid ""
"If the imported module is known to be empty, the call to its initializer may "
"be omitted. Additionally, if the imported module is known to have already "
"been imported, the call to its initializer may be omitted."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:558
msgid "Reduced BMI"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:560
msgid ""
"To support the two-phase compilation model, Clang puts everything needed to "
"produce an object into the BMI. However, other consumers of the BMI "
"generally don't need that information. This makes the BMI larger and may "
"introduce unnecessary dependencies for the BMI. To mitigate the problem, "
"Clang has a compiler option to reduce the information contained in the BMI. "
"These two formats are known as Full BMI and Reduced BMI, respectively."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:567
msgid ""
"Users can use the ``-fexperimental-modules-reduced-bmi`` option to produce a "
"Reduced BMI."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:570
msgid ""
"For the one-phase compilation model (CMake implements this model), with ``-"
"fexperimental-modules-reduced-bmi``, the generated BMI will be a Reduced BMI "
"automatically. (The output path of the BMI is specified by ``-fmodule-"
"output=`` as usual with the one-phase compilation model)."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:575
msgid ""
"It is also possible to produce a Reduced BMI with the two-phase compilation "
"model. When ``-fexperimental-modules-reduced-bmi``, ``--precompile``, and ``-"
"fmodule-output=`` are specified, the generated BMI specified by ``-o`` will "
"be a full BMI and the BMI specified by ``-fmodule-output=`` will be a "
"Reduced BMI. The dependency graph in this case would look like:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:590
msgid ""
"Clang does not emit diagnostics when ``-fexperimental-modules-reduced-bmi`` "
"is used with a non-module unit. This design permits users of the one-phase "
"compilation model to try using reduced BMIs without needing to modify the "
"build system. The two-phase compilation module requires build system support."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:595
msgid ""
"In a Reduced BMI, Clang does not emit unreachable entities from the global "
"module fragment, or definitions of non-inline functions and non-inline "
"variables. This may not be a transparent change."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:599
msgid "Consider the following example:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:647
msgid ""
"In the above example, the function definition of ``N::g`` is elided from the "
"Reduced BMI of ``M.cppm``. Then the use of ``use_g<int>`` in ``M-impl.cpp`` "
"fails to instantiate. For such issues, users can add references to ``N::g`` "
"in the `module purview <https://eel.is/c++draft/module.unit#5>`_ of ``M."
"cppm`` to ensure it is reachable, e.g. ``using N::g;``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:653
msgid ""
"Support for Reduced BMIs is still experimental, but it may become the "
"default in the future. The expected roadmap for Reduced BMIs as of Clang 19."
"x is:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:656
msgid ""
"``-fexperimental-modules-reduced-bmi`` is opt-in for 1~2 releases. The "
"period depends on user feedback and may be extended."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:658
msgid ""
"Announce that Reduced BMIs are no longer experimental and introduce ``-"
"fmodules-reduced-bmi`` as a new option, and recommend use of the new option. "
"This transition is expected to take 1~2 additional releases as well."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:661
msgid ""
"Finally, ``-fmodules-reduced-bmi`` will be the default. When that time "
"comes, the term BMI will refer to the Reduced BMI and the Full BMI will only "
"be meaningful to build systems which elect to support two-phase compilation."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:666
msgid "Experimental Non-Cascading Changes"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:668
msgid ""
"This section is primarily for build system vendors. For end compiler users, "
"if you don't want to read it all, this is helpful to reduce recompilations. "
"We encourage build system vendors and end users try this out and bring "
"feedback."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:672
msgid ""
"Before Clang 19, a change in BMI of any (transitive) dependency would cause "
"the outputs of the BMI to change. Starting with Clang 19, changes to non-"
"direct dependencies should not directly affect the output BMI, unless they "
"affect the results of the compilations. We expect that there are many more "
"opportunities for this optimization than we currently have realized and "
"would appreaciate feedback about missed optimization opportunities. For "
"example,"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:706
msgid "To compile the project (for brevity, some commands are omitted.):"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:717
msgid "If the interface of ``m-partA.cppm`` is changed to:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:725
msgid "and the BMI for ``useBOnly`` is recompiled as in:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:736
msgid ""
"then the contents of ``useBOnly.pcm`` remain unchanged. Consequently, if the "
"build system only bases recompilation decisions on directly imported "
"modules, it becomes possible to skip the recompilation of ``Use.cc``. It "
"should be fine because the altered interfaces do not affect ``Use.cc`` in "
"any way; the changes do not cascade."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:742
msgid ""
"When ``Clang`` generates a BMI, it records the hash values of all "
"potentially contributory BMIs for the BMI being produced. This ensures that "
"build systems are not required to consider transitively imported modules "
"when deciding whether to recompile."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:746
msgid ""
"What is considered to be a potential contributory BMIs is currently "
"unspecified. However, it is a severe bug for a BMI to remain unchanged "
"following an observable change that affects its consumers."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:750
msgid ""
"Build systems may utilize this optimization by doing an update-if-changed "
"operation to the BMI that is consumed from the BMI that is output by the "
"compiler."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:753
msgid ""
"We encourage build systems to add an experimental mode that reuses the "
"cached BMI when **direct** dependencies did not change, even if "
"**transitive** dependencies did change."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:757
msgid ""
"Given there are potential compiler bugs, we recommend that build systems "
"support this feature as a configurable option so that users can go back to "
"the transitive change mode safely at any time."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:762
msgid "Interactions with Reduced BMI"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:764
msgid ""
"With reduced BMI, non-cascading changes can be more powerful. For example,"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:784
msgid "And let's change the implementation for ``A.cppm`` into:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:792
msgid "and recompile the example:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:801
msgid ""
"We should find the contents of ``B.pcm`` remains the same. In this case, the "
"build system is allowed to skip recompilations of TUs which solely and "
"directly depend on module ``B``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:804
msgid ""
"This only happens with a reduced BMI. With reduced BMIs, we won't record the "
"function body of ``int b()`` in the BMI for ``B`` so that the module ``A`` "
"doesn't contribute to the BMI of ``B`` and we have less dependencies."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:809
msgid "Performance Tips"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:812
msgid "Reduce duplications"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:814
msgid ""
"While it is valid to have duplicated declarations in the global module "
"fragments of different module units, it is not free for Clang to deal with "
"the duplicated declarations. A translation unit will compile more slowly if "
"there is a lot of duplicated declarations between the translation unit and "
"modules it imports. For example:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:854
msgid ""
"When ``big.header.h`` is big enough and there are a lot of partitions, the "
"compilation of ``use.cpp`` may be significantly slower than the following "
"approach:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:894
msgid ""
"Reducing the duplication from textual includes is what improves compile-time "
"performance."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:898
msgid "Transitioning to modules"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:900
msgid ""
"It is best for new code and libraries to use modules from the start if "
"possible. However, it may be a breaking change for existing code or "
"libraries to switch to modules. As a result, many existing libraries need to "
"provide both headers and module interfaces for a while to not break existing "
"users."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:905
msgid ""
"This section suggests some suggestions on how to ease the transition process "
"for existing libraries. **Note that this information is only intended as "
"guidance, rather than as requirements to use modules in Clang.** It presumes "
"the project is starting with no module-based dependencies."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:911
msgid "ABI non-breaking styles"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:914
msgid "export-using style"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:931
msgid ""
"This example shows how to include all the headers containing declarations "
"which need to be exported, and uses `using` declarations in an `export` "
"block to produce the module interface."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:936
msgid "export extern-C++ style"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:954
msgid ""
"Headers (from ``header_1.h`` to ``header_n.h``) need to define the macro:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:964
msgid "and put ``EXPORT`` on the declarations you want to export."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:966
msgid ""
"Also, it is recommended to refactor headers to include third-party headers "
"conditionally:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:979
msgid ""
"This can be helpful because it gives better diagnostic messages if the "
"module interface unit is not properly updated when modifying code."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:982
msgid ""
"This approach works because the declarations with language linkage are "
"attached to the global module. Thus, the ABI of the modular form of the "
"library does not change."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:986
msgid ""
"While this style is more involved than the export-using style, it makes it "
"easier to further refactor the library to other styles."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:990
msgid "ABI breaking style"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:992
msgid ""
"The term ``ABI breaking`` may sound like a bad approach. However, this style "
"forces consumers of the library use it in a consistent way. e.g., either "
"always include headers for the library or always import modules. The style "
"prevents the ability to mix includes and imports for the library."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:997
msgid ""
"The pattern for ABI breaking style is similar to the export extern-C++ style."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1030
msgid ""
"(And add `EXPORT` and conditional include to the headers as suggested in the "
"export extern-C++ style section.)"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1033
msgid ""
"The ABI with modules is different and thus we need to compile the source "
"files into the new ABI. This is done by an additional part of the interface "
"unit:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1055
msgid ""
"If the number of source files is small, everything can be put in the private "
"module fragment directly (it is recommended to add conditional includes to "
"the source files as well). However, compile time performance will be bad if "
"there are a lot of source files to compile."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1060
msgid ""
"**Note that the private module fragment can only be in the primary module "
"interface unit and the primary module interface unit containing the private "
"module fragment should be the only module unit of the corresponding module.**"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1064
msgid ""
"In this case, source files (.cpp files) must be converted to module "
"implementation units:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1081
msgid ""
"The module implementation unit will import the primary module implicitly. Do "
"not include any headers in the module implementation units as it avoids "
"duplicated declarations between translation units. This is why non-exported "
"using declarations should be added from third-party libraries in the primary "
"module interface unit."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1087
msgid ""
"If the library is provided as ``libyour_library.so``, a modular library (e."
"g., ``libyour_library_modules.so``) may also need to be provided for ABI "
"compatibility."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1092
msgid "What if there are headers only included by the source files"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1094
msgid ""
"The above practice may be problematic if there are headers only included by "
"the source files. When using a private module fragment, this issue may be "
"solved by including those headers in the private module fragment. While it "
"is OK to solve it by including the implementation headers in the module "
"purview when using implementation module units, it may be suboptimal because "
"the primary module interface units now contain entities that do not belong "
"to the interface."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1101
msgid ""
"This can potentially be improved by introducing a module partition "
"implementation unit. An internal module partition unit is an importable "
"module unit which is internal to the module itself."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1106
msgid "Providing a header to skip parsing redundant headers"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1108
msgid ""
"Many redeclarations shared between translation units causes Clang to have "
"slower compile-time performance. Further, there are known issues with "
"`include after import <https://github.com/llvm/llvm-project/issues/61465>`_. "
"Even when that issue is resolved, users may still get slower compilation "
"speed and larger BMIs. For these reasons, it is recommended to not include "
"headers after importing the corresponding module. However, it is not always "
"easy if the library is included by other dependencies, as in:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1121
msgid "or"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1128
msgid ""
"For such cases, it is best if the library providing both module and header "
"interfaces also provides a header which skips parsing so that the library "
"can be imported with the following approach that skips redundant "
"redeclarations:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1138
msgid ""
"The implementation of ``your_library_imported.h`` can be a set of "
"controlling macros or an overall controlling macro if using `#pragma once`. "
"Then headers can be refactored to:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1149
msgid ""
"If the modules imported by the library provide such headers, remember to add "
"them to ``your_library_imported.h`` too."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1153
msgid "Importing modules"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1155
msgid ""
"When there are dependent libraries providing modules, they should be "
"imported in your module as well. Many existing libraries will fall into this "
"category once the ``std`` module is more widely available."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1160
msgid "All dependent libraries providing modules"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1162
msgid ""
"Of course, most of the complexity disappears if all the dependent libraries "
"provide modules."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1165
msgid ""
"Headers need to be converted to include third-party headers conditionally. "
"Then, for the export-using style:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1185
msgid "or, for the export extern-C++ style:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1199
msgid "or, for the ABI-breaking style,"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1219
msgid ""
"Non-exported ``using`` declarations are unnecessary if using implementation "
"module units. Instead, third-party modules can be imported directly in "
"implementation module units."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1224
msgid "Partial dependent libraries providing modules"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1226
msgid ""
"If the library has to mix the use of ``include`` and ``import`` in its "
"module, the primary goal is still the removal of duplicated declarations in "
"translation units as much as possible. If the imported modules provide "
"headers to skip parsing their headers, those should be included after the "
"import. If the imported modules don't provide such a header, one can be made "
"manually for improved compile time performance."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1234
msgid "Known Issues"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1236
msgid ""
"The following describes issues in the current implementation of modules. "
"Please see `the issues list for modules <https://github.com/llvm/llvm-"
"project/labels/clang%3Amodules>`_ for a list of issues or to file a new "
"issue if you don't find an existing one. When creating a new issue for "
"standard C++ modules, please start the title with ``[C++20] [Modules]`` (or "
"``[C++23] [Modules]``, etc) and add the label ``clang:modules`` if possible."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1244
msgid ""
"A high-level overview of support for standards features, including modules, "
"can be found on the `C++ Feature Status <https://clang.llvm.org/cxx_status."
"html>`_ page."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1249
msgid "Missing VTables for classes attached to modules"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1251
msgid ""
"Now the compiler may miss emitting the definition of vtables for classes "
"attached to modules, if the definition of the class doesn't contain any key "
"function in that module units (The key function is the first non-pure "
"virtual function that is not inline at the point of class definition.)"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1257
msgid ""
"(Note: technically, the key function is not a thing for modules. We use the "
"concept here for convinient.)"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1285
msgid ""
"For the above example, we can't find the definition for the vtable of class "
"``Banana`` in any object files."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1288
msgid ""
"The expected behavior is, for dynamic classes attached to named modules, the "
"vtable should always be emitted to the module units the class attaches to."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1292
msgid ""
"To workaround the problem, users can add the key function manually in the "
"corresponding module units. e.g.,"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1313
msgid ""
"This is tracked by `#70585 <https://github.com/llvm/llvm-project/"
"issues/70585>`_."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1317
msgid "Including headers after import is not well-supported"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1319
msgid "The following example is accepted:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1332
msgid ""
"but if the order of ``#include <iostream>`` and ``import foo;`` is reversed, "
"then the code is currently rejected:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1346
msgid "Both of the above examples should be accepted."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1348
msgid ""
"This is a limitation of the implementation. In the first example, the "
"compiler will see and parse ``<iostream>`` first then it will see the "
"``import``. In this case, ODR checking and declaration merging will happen "
"in the deserializer. In the second example, the compiler will see the "
"``import`` first and the ``#include`` second which results in ODR checking "
"and declarations merging happening in the semantic analyzer. This is due to "
"a divergence in the implementation path. This is tracked by `#61465 <https://"
"github.com/llvm/llvm-project/issues/61465>`_."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1358
msgid "Ignored ``preferred_name`` Attribute"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1360
msgid ""
"When Clang writes BMIs, it will ignore the ``preferred_name`` attribute on "
"declarations which use it. Thus, the preferred name will not be displayed in "
"the debugger as expected. This is tracked by `#56490 <https://github.com/"
"llvm/llvm-project/issues/56490>`_."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1366
msgid "Don't emit macros about module declaration"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1368
msgid ""
"This is covered by `P1857R3 <https://wg21.link/P1857R3>`_. It is mentioned "
"here because we want users to be aware that we don't yet implement it."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1371
msgid ""
"A direct approach to write code that can be compiled by both modules and non-"
"module builds may look like:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1382
msgid ""
"The intent of this is that this file can be compiled like a module unit or a "
"non-module unit depending on the definition of some macros. However, this "
"usage is forbidden by P1857R3 which is not yet implemented in Clang. This "
"means that is possible to write invalid modules which will no longer be "
"accepted once P1857R3 is implemented. This is tracked by `#56917 <https://"
"github.com/llvm/llvm-project/issues/56917>`_."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1389
msgid ""
"Until then, it is recommended not to mix macros with module declarations."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1393
msgid "In consistent filename suffix requirement for importable module units"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1395
msgid ""
"Currently, Clang requires the file name of an ``importable module unit`` to "
"have ``.cppm`` (or ``.ccm``, ``.cxxm``, ``.c++m``) as the file extension. "
"However, the behavior is inconsistent with other compilers. This is tracked "
"by `#57416 <https://github.com/llvm/llvm-project/issues/57416>`_."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1401
msgid "Incorrect ODR violation diagnostics"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1403
msgid ""
"ODR violations are a common issue when using modules. Clang sometimes "
"produces false-positive diagnostics or fails to produce true-positive "
"diagnostics of the One Definition Rule. One often-reported example is:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1433
msgid ""
"Currently the compiler incorrectly diagnoses the inconsistent definition of "
"``fun()`` in two module units. Because both definitions of ``fun()`` have "
"the same spelling and ``T`` refers to the same type entity, there is no ODR "
"violation. This is tracked by `#78850 <https://github.com/llvm/llvm-project/"
"issues/78850>`_."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1440
msgid "Using TU-local entity in other units"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1442
msgid ""
"Module units are translation units, so the entities which should be local to "
"the module unit itself should never be used by other units."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1445
msgid ""
"The C++ standard defines the concept of ``TU-local`` and ``exposure`` in "
"`basic.link/p14 <https://eel.is/c++draft/basic.link#14>`_, `basic.link/p15 "
"<https://eel.is/c++draft/basic.link#15>`_, `basic.link/p16 <https://eel.is/c+"
"+draft/basic.link#16>`_, `basic.link/p17 <https://eel.is/c++draft/basic."
"link#17>`_, and `basic.link/p18 <https://eel.is/c++draft/basic.link#18>`_."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1452
msgid ""
"However, Clang doesn't formally support these two concepts. This results in "
"unclear or confusing diagnostic messages. Further, Clang may import ``TU-"
"local`` entities to other units without any diagnostics. This is tracked by "
"`#78173 <https://github.com/llvm/llvm-project/issues/78173>`_."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1460
msgid "Header Units"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1463
msgid "How to build projects using header units"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1467
msgid ""
"The support for header units, including related command line options, is "
"experimental. There are still many unanswered question about how tools "
"should interact with header units. The details described here may change in "
"the future."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1475
msgid "The following example:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1484
#: ../../../StandardCPlusPlusModules.rst:1517
msgid "could be compiled with:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1492
msgid "How to produce BMIs"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1494
msgid ""
"Similar to named modules, ``--precompile`` can be used to produce a BMI. "
"However, that requires specifying that the input file is a header by using "
"``-xc++-system-header`` or ``-xc++-user-header``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1498
msgid ""
"The ``-fmodule-header={user,system}`` option can also be used to produce a "
"BMI for header units which have a file extension like `.h` or `.hh`. The "
"argument to ``-fmodule-header`` specifies either the user search path or the "
"system search path. The default value for ``-fmodule-header`` is ``user``. "
"For example:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1524
msgid ""
"For headers which do not have a file extension, ``-xc++-header`` (or ``-xc++-"
"system-header``, ``-xc++-user-header``) must be used to specify the file as "
"a header. For example:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1542
msgid "How to specify dependent BMIs"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1544
msgid ""
"``-fmodule-file`` can be used to specify a dependent BMI (or multiple times "
"for more than one dependent BMI)."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1547
msgid ""
"With the existing implementation, ``-fprebuilt-module-path`` cannot be used "
"for header units (because they are nominally anonymous). For header units, "
"use ``-fmodule-file`` to include the relevant PCM file for each header unit."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1551
msgid ""
"This is expect to be solved in a future version of Clang either by the "
"compiler finding and specifying ``-fmodule-file`` automatically, or by the "
"use of a module-mapper that understands how to map the header name to their "
"PCMs."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1556
msgid "Compiling a header unit to an object file"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1558
msgid ""
"A header unit cannot be compiled to an object file due to the semantics of "
"header units. For example:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1568
msgid "Include translation"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1570
msgid ""
"The C++ standard allows vendors to convert ``#include header-name`` to "
"``import header-name;`` when possible. Currently, Clang does this "
"translation for the ``#include`` in the global module fragment. For example, "
"the following example:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1584
msgid "is the same as this example:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1600
msgid ""
"In the latter example, Clang can find the BMI for ``<iostream>`` and so it "
"tries to replace the ``#include <iostream>`` with ``import <iostream>;`` "
"automatically."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1606
msgid "Differences between Clang modules and header units"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1608
msgid ""
"Header units have similar semantics to Clang modules. The semantics of both "
"are like headers. Therefore, header units can be mimicked by Clang modules "
"as in the following example:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1623
msgid "This example is simplified when using libc++:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1629
msgid ""
"because libc++ already supplies a `module map <https://github.com/llvm/llvm-"
"project/blob/main/libcxx/include/module.modulemap.in>`_."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1632
msgid ""
"This raises the question: why are header units not implemented through Clang "
"modules?"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1635
msgid ""
"This is primarily because Clang modules have more hierarchical semantics "
"when wrapping multiple headers together as one module, which is not "
"supported by Standard C++ Header units. We want to avoid the impression that "
"these additional semantics get interpreted as Standard C++ behavior."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1640
msgid ""
"Another reason is that there are proposals to introduce module mappers to "
"the C++ standard (for example, https://wg21.link/p1184r2). Reusing Clang's "
"``modulemap`` may be more difficult if we need to introduce another module "
"mapper."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1646
msgid "Discovering Dependencies"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1648
msgid ""
"Without use of modules, all the translation units in a project can be "
"compiled in parallel. However, the presence of module units requires "
"compiling the translation units in a topological order."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1652
msgid ""
"The ``clang-scan-deps`` tool can extract dependency information and produce "
"a JSON file conforming to the specification described in `P1689 <https://www."
"open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1689r5.html>`_. Only named "
"modules are supported currently."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1657
msgid ""
"A compilation database is needed when using ``clang-scan-deps``. See `JSON "
"Compilation Database Format Specification <JSONCompilationDatabase.html>`_ "
"for more information about compilation databases. Note that the ``output`` "
"JSON attribute is necessary for ``clang-scan-deps`` to scan using the P1689 "
"format. For example:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1704
msgid "And here is the compilation database:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1741
msgid "To get the dependency information in P1689 format, use:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1747
msgid "to get:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1825
msgid "See the P1689 paper for the meaning of the fields."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1827
msgid ""
"Getting dependency information per file with finer-grained control (such as "
"scanning generated source files) is possible. For example:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1834
#: ../../../StandardCPlusPlusModules.rst:1876
msgid "will produce:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1860
msgid ""
"Individual command line options can be specified after ``--``. ``clang-scan-"
"deps`` will extract the necessary information from the specified options. "
"Note that the path to the compiler executable needs to be specified "
"explicitly instead of using ``clang++`` directly."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1865
msgid ""
"Users may want the scanner to get the transitional dependency information "
"for headers. Otherwise, the project has to be scanned twice, once for "
"headers and once for modules. To address this, ``clang-scan-deps`` will "
"recognize the specified preprocessor options in the given command line and "
"generate the corresponding dependency information. For example:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1888
msgid ""
"When ``clang-scan-deps`` detects the ``-MF`` option, it will try to write "
"the dependency information for headers to the file specified by ``-MF``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1892
msgid "Possible Issues: Failed to find system headers"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1894
msgid ""
"If encountering an error like ``fatal error: 'stddef.h' file not found``, "
"the specified ``<path-to-compiler-executable>/clang++`` probably refers to a "
"symlink instead a real binary. There are four potential solutions to the "
"problem:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1899
msgid ""
"Point the specified compiler executable to the real binary instead of the "
"symlink."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1901
msgid ""
"Invoke ``<path-to-compiler-executable>/clang++ -print-resource-dir`` to get "
"the corresponding resource directory for your compiler and add that "
"directory to the include search paths manually in the build scripts."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1904
msgid ""
"For build systems that use a compilation database as the input for ``clang-"
"scan-deps``, the build system can add the ``--resource-dir-recipe invoke-"
"compiler`` option when executing ``clang-scan-deps`` to calculate the "
"resource directory dynamically. The calculation happens only once for a "
"unique ``<path-to-compiler-executable>/clang++``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1909
msgid ""
"For build systems that invoke ``clang-scan-deps`` per file, repeatedly "
"calculating the resource directory may be inefficient. In such cases, the "
"build system can cache the resource directory and specify ``-resource-dir "
"<resource-dir>`` explicitly, as in:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1920
msgid "Import modules with clang-repl"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1922
msgid "``clang-repl`` supports importing C++20 named modules. For example:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1932
msgid "The named module still needs to be compiled ahead of time."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1940
msgid ""
"Note that the module unit needs to be compiled as a dynamic library so that "
"``clang-repl`` can load the object files of the module units. Then it is "
"possible to import module ``M`` in clang-repl."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1956
msgid "Possible Questions"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1959
msgid "How modules speed up compilation"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1961
msgid ""
"A classic theory for the reason why modules speed up the compilation is: if "
"there are ``n`` headers and ``m`` source files and each header is included "
"by each source file, then the complexity of the compilation is ``O(n*m)``. "
"However, if there are ``n`` module interfaces and ``m`` source files, the "
"complexity of the compilation is ``O(n+m)``. Therefore, using modules would "
"be a significant improvement at scale. More simply, use of modules causes "
"many of the redundant compilations to no longer be necessary."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1969
msgid ""
"While this is accurate at a high level, this depends greatly on the "
"optimization level, as illustrated below."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1972
msgid ""
"First is ``-O0``. The compilation process is described in the following "
"graph."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1994
msgid ""
"In this case, the source file (which could be a non-module unit or a module "
"unit) would get processed by the entire pipeline. However, the imported code "
"would only get involved in semantic analysis, which, for the most part, is "
"name lookup, overload resolution, and template instantiation. All of these "
"processes are fast relative to the whole compilation process. More "
"importantly, the imported code only needs to be processed once during "
"frontend code generation, as well as the whole middle end and backend. So we "
"could get a big win for the compilation time in ``-O0``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2003
msgid ""
"But with optimizations, things are different (the ``code generation`` part "
"for each end is omitted due to limited space):"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2025
msgid ""
"It would be very unfortunate if we end up with worse performance when using "
"modules. The main concern is that when a source file is compiled, the "
"compiler needs to see the body of imported module units so that it can "
"perform IPO (InterProcedural Optimization, primarily inlining in practice) "
"to optimize functions in the current source file with the help of the "
"information provided by the imported module units. In other words, the "
"imported code would be processed again and again in importee units by "
"optimizations (including IPO itself). The optimizations before IPO and IPO "
"itself are the most time-consuming part in whole compilation process. So "
"from this perspective, it might not be possible to get the compile time "
"improvements described, but there could be time savings for optimizations "
"after IPO and the whole backend."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2037
msgid ""
"Overall, at ``-O0`` the implementations of functions defined in a module "
"will not impact module users, but at higher optimization levels the "
"definitions of such functions are provided to user compilations for the "
"purposes of optimization (but definitions of these functions are still not "
"included in the use's object file). This means the build speedup at higher "
"optimization levels may be lower than expected given ``-O0`` experience, but "
"does provide more optimization opportunities."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2046
msgid "Interoperability with Clang Modules"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:2048
msgid ""
"We **wish** to support Clang modules and standard C++ modules at the same "
"time, but the mixing them together is not well used/tested yet. Please file "
"new GitHub issues as you find interoperability problems."
msgstr ""
