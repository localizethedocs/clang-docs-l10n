# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2025, The Clang Team
# This file is distributed under the same license as the Clang package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Clang 9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-13 13:42+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../ControlFlowIntegrity.rst:3
msgid "Control Flow Integrity"
msgstr ""

#: ../../../ControlFlowIntegrity.rst:14
msgid "Introduction"
msgstr ""

#: ../../../ControlFlowIntegrity.rst:16
msgid ""
"Clang includes an implementation of a number of control flow integrity (CFI) "
"schemes, which are designed to abort the program upon detecting certain "
"forms of undefined behavior that can potentially allow attackers to subvert "
"the program's control flow. These schemes have been optimized for "
"performance, allowing developers to enable them in release builds."
msgstr ""

#: ../../../ControlFlowIntegrity.rst:22
msgid ""
"To enable Clang's available CFI schemes, use the flag ``-fsanitize=cfi``. "
"You can also enable a subset of available :ref:`schemes <cfi-schemes>`. As "
"currently implemented, all schemes rely on link-time optimization (LTO); so "
"it is required to specify ``-flto``, and the linker used must support LTO, "
"for example via the `gold plugin`_."
msgstr ""

#: ../../../ControlFlowIntegrity.rst:28
msgid ""
"To allow the checks to be implemented efficiently, the program must be "
"structured such that certain object files are compiled with CFI enabled, and "
"are statically linked into the program. This may preclude the use of shared "
"libraries in some cases."
msgstr ""

#: ../../../ControlFlowIntegrity.rst:33
msgid ""
"The compiler will only produce CFI checks for a class if it can infer hidden "
"LTO visibility for that class. LTO visibility is a property of a class that "
"is inferred from flags and attributes. For more details, see the "
"documentation for :doc:`LTO visibility <LTOVisibility>`."
msgstr ""

#: ../../../ControlFlowIntegrity.rst:38
msgid ""
"The ``-fsanitize=cfi-{vcall,nvcall,derived-cast,unrelated-cast}`` flags "
"require that a ``-fvisibility=`` flag also be specified. This is because the "
"default visibility setting is ``-fvisibility=default``, which would disable "
"CFI checks for classes without visibility attributes. Most users will want "
"to specify ``-fvisibility=hidden``, which enables CFI checks for such "
"classes."
msgstr ""

#: ../../../ControlFlowIntegrity.rst:44
msgid ""
"Experimental support for :ref:`cross-DSO control flow integrity <cfi-cross-"
"dso>` exists that does not require classes to have hidden LTO visibility. "
"This cross-DSO support has unstable ABI at this time."
msgstr ""

#: ../../../ControlFlowIntegrity.rst:53
msgid "Available schemes"
msgstr ""

#: ../../../ControlFlowIntegrity.rst:55
msgid "Available schemes are:"
msgstr ""

#: ../../../ControlFlowIntegrity.rst:57
msgid ""
"``-fsanitize=cfi-cast-strict``: Enables :ref:`strict cast checks <cfi-"
"strictness>`."
msgstr ""

#: ../../../ControlFlowIntegrity.rst:59
msgid ""
"``-fsanitize=cfi-derived-cast``: Base-to-derived cast to the wrong dynamic "
"type."
msgstr ""

#: ../../../ControlFlowIntegrity.rst:61
msgid ""
"``-fsanitize=cfi-unrelated-cast``: Cast from ``void*`` or another unrelated "
"type to the wrong dynamic type."
msgstr ""

#: ../../../ControlFlowIntegrity.rst:63
msgid ""
"``-fsanitize=cfi-nvcall``: Non-virtual call via an object whose vptr is of "
"the wrong dynamic type."
msgstr ""

#: ../../../ControlFlowIntegrity.rst:65
msgid ""
"``-fsanitize=cfi-vcall``: Virtual call via an object whose vptr is of the "
"wrong dynamic type."
msgstr ""

#: ../../../ControlFlowIntegrity.rst:67
msgid ""
"``-fsanitize=cfi-icall``: Indirect call of a function with wrong dynamic "
"type."
msgstr ""

#: ../../../ControlFlowIntegrity.rst:69
msgid ""
"``-fsanitize=cfi-mfcall``: Indirect call via a member function pointer with "
"wrong dynamic type."
msgstr ""

#: ../../../ControlFlowIntegrity.rst:72
msgid ""
"You can use ``-fsanitize=cfi`` to enable all the schemes and use ``-fno-"
"sanitize`` flag to narrow down the set of schemes as desired. For example, "
"you can build your program with ``-fsanitize=cfi -fno-sanitize=cfi-nvcall,"
"cfi-icall`` to use all schemes except for non-virtual member function call "
"and indirect call checking."
msgstr ""

#: ../../../ControlFlowIntegrity.rst:79
msgid ""
"Remember that you have to provide ``-flto`` if at least one CFI scheme is "
"enabled."
msgstr ""

#: ../../../ControlFlowIntegrity.rst:83
msgid "Trapping and Diagnostics"
msgstr ""

#: ../../../ControlFlowIntegrity.rst:85
msgid ""
"By default, CFI will abort the program immediately upon detecting a control "
"flow integrity violation. You can use the :ref:`-fno-sanitize-trap= "
"<controlling-code-generation>` flag to cause CFI to print a diagnostic "
"similar to the one below before the program aborts."
msgstr ""

#: ../../../ControlFlowIntegrity.rst:97
msgid ""
"If diagnostics are enabled, you can also configure CFI to continue program "
"execution instead of aborting by using the :ref:`-fsanitize-recover= "
"<controlling-code-generation>` flag."
msgstr ""

#: ../../../ControlFlowIntegrity.rst:102
msgid "Forward-Edge CFI for Virtual Calls"
msgstr ""

#: ../../../ControlFlowIntegrity.rst:104
msgid ""
"This scheme checks that virtual calls take place using a vptr of the correct "
"dynamic type; that is, the dynamic type of the called object must be a "
"derived class of the static type of the object used to make the call. This "
"CFI scheme can be enabled on its own using ``-fsanitize=cfi-vcall``."
msgstr ""

#: ../../../ControlFlowIntegrity.rst:109 ../../../ControlFlowIntegrity.rst:156
#: ../../../ControlFlowIntegrity.rst:172 ../../../ControlFlowIntegrity.rst:279
msgid ""
"For this scheme to work, all translation units containing the definition of "
"a virtual member function (whether inline or not), other than members of :"
"ref:`blacklisted <cfi-blacklist>` types or types with public :doc:`LTO "
"visibility <LTOVisibility>`, must be compiled with ``-flto`` or ``-"
"flto=thin`` enabled and be statically linked into the program."
msgstr ""

#: ../../../ControlFlowIntegrity.rst:116
msgid "Performance"
msgstr ""

#: ../../../ControlFlowIntegrity.rst:118
msgid ""
"A performance overhead of less than 1% has been measured by running the "
"Dromaeo benchmark suite against an instrumented version of the Chromium web "
"browser. Another good performance benchmark for this mechanism is the "
"virtual-call-heavy SPEC 2006 xalancbmk."
msgstr ""

#: ../../../ControlFlowIntegrity.rst:123
msgid ""
"Note that this scheme has not yet been optimized for binary size; an "
"increase of up to 15% has been observed for Chromium."
msgstr ""

#: ../../../ControlFlowIntegrity.rst:127
msgid "Bad Cast Checking"
msgstr ""

#: ../../../ControlFlowIntegrity.rst:129
msgid ""
"This scheme checks that pointer casts are made to an object of the correct "
"dynamic type; that is, the dynamic type of the object must be a derived "
"class of the pointee type of the cast. The checks are currently only "
"introduced where the class being casted to is a polymorphic class."
msgstr ""

#: ../../../ControlFlowIntegrity.rst:134
msgid ""
"Bad casts are not in themselves control flow integrity violations, but they "
"can also create security vulnerabilities, and the implementation uses many "
"of the same mechanisms."
msgstr ""

#: ../../../ControlFlowIntegrity.rst:138
msgid ""
"There are two types of bad cast that may be forbidden: bad casts from a base "
"class to a derived class (which can be checked with ``-fsanitize=cfi-derived-"
"cast``), and bad casts from a pointer of type ``void*`` or another unrelated "
"type (which can be checked with ``-fsanitize=cfi-unrelated-cast``)."
msgstr ""

#: ../../../ControlFlowIntegrity.rst:144
msgid ""
"The difference between these two types of casts is that the first is defined "
"by the C++ standard to produce an undefined value, while the second is not "
"in itself undefined behavior (it is well defined to cast the pointer back to "
"its original type) unless the object is uninitialized and the cast is a "
"``static_cast`` (see C++14 [basic.life]p5)."
msgstr ""

#: ../../../ControlFlowIntegrity.rst:150
msgid ""
"If a program as a matter of policy forbids the second type of cast, that "
"restriction can normally be enforced. However it may in some cases be "
"necessary for a function to perform a forbidden cast to conform with an "
"external API (e.g. the ``allocate`` member function of a standard library "
"allocator). Such functions may be :ref:`blacklisted <cfi-blacklist>`."
msgstr ""

#: ../../../ControlFlowIntegrity.rst:163
msgid "Non-Virtual Member Function Call Checking"
msgstr ""

#: ../../../ControlFlowIntegrity.rst:165
msgid ""
"This scheme checks that non-virtual calls take place using an object of the "
"correct dynamic type; that is, the dynamic type of the called object must be "
"a derived class of the static type of the object used to make the call. The "
"checks are currently only introduced where the object is of a polymorphic "
"class type.  This CFI scheme can be enabled on its own using ``-"
"fsanitize=cfi-nvcall``."
msgstr ""

#: ../../../ControlFlowIntegrity.rst:181
msgid "Strictness"
msgstr ""

#: ../../../ControlFlowIntegrity.rst:183
msgid ""
"If a class has a single non-virtual base and does not introduce or override "
"virtual member functions or fields other than an implicitly defined virtual "
"destructor, it will have the same layout and virtual function semantics as "
"its base. By default, casts to such classes are checked as if they were made "
"to the least derived such class."
msgstr ""

#: ../../../ControlFlowIntegrity.rst:189
msgid ""
"Casting an instance of a base class to such a derived class is technically "
"undefined behavior, but it is a relatively common hack for introducing "
"member functions on class instances with specific properties that works "
"under most compilers and should not have security implications, so we allow "
"it by default. It can be disabled with ``-fsanitize=cfi-cast-strict``."
msgstr ""

#: ../../../ControlFlowIntegrity.rst:196
msgid "Indirect Function Call Checking"
msgstr ""

#: ../../../ControlFlowIntegrity.rst:198
msgid ""
"This scheme checks that function calls take place using a function of the "
"correct dynamic type; that is, the dynamic type of the function must match "
"the static type used at the call. This CFI scheme can be enabled on its own "
"using ``-fsanitize=cfi-icall``."
msgstr ""

#: ../../../ControlFlowIntegrity.rst:203
msgid ""
"For this scheme to work, each indirect function call in the program, other "
"than calls in :ref:`blacklisted <cfi-blacklist>` functions, must call a "
"function which was either compiled with ``-fsanitize=cfi-icall`` enabled, or "
"whose address was taken by a function in a translation unit compiled with ``-"
"fsanitize=cfi-icall``."
msgstr ""

#: ../../../ControlFlowIntegrity.rst:209
msgid ""
"If a function in a translation unit compiled with ``-fsanitize=cfi-icall`` "
"takes the address of a function not compiled with ``-fsanitize=cfi-icall``, "
"that address may differ from the address taken by a function in a "
"translation unit not compiled with ``-fsanitize=cfi-icall``. This is "
"technically a violation of the C and C++ standards, but it should not affect "
"most programs."
msgstr ""

#: ../../../ControlFlowIntegrity.rst:215
msgid ""
"Each translation unit compiled with ``-fsanitize=cfi-icall`` must be "
"statically linked into the program or shared library, and calls across "
"shared library boundaries are handled as if the callee was not compiled with "
"``-fsanitize=cfi-icall``."
msgstr ""

#: ../../../ControlFlowIntegrity.rst:220
msgid ""
"This scheme is currently only supported on the x86 and x86_64 architectures."
msgstr ""

#: ../../../ControlFlowIntegrity.rst:223
msgid "``-fsanitize-cfi-icall-generalize-pointers``"
msgstr ""

#: ../../../ControlFlowIntegrity.rst:225
msgid ""
"Mismatched pointer types are a common cause of cfi-icall check failures. "
"Translation units compiled with the ``-fsanitize-cfi-icall-generalize-"
"pointers`` flag relax pointer type checking for call sites in that "
"translation unit, applied across all functions compiled with ``-"
"fsanitize=cfi-icall``."
msgstr ""

#: ../../../ControlFlowIntegrity.rst:230
msgid ""
"Specifically, pointers in return and argument types are treated as "
"equivalent as long as the qualifiers for the type they point to match. For "
"example, ``char*``, ``char**``, and ``int*`` are considered equivalent "
"types. However, ``char*`` and ``const char*`` are considered separate types."
msgstr ""

#: ../../../ControlFlowIntegrity.rst:235
msgid ""
"``-fsanitize-cfi-icall-generalize-pointers`` is not compatible with ``-"
"fsanitize-cfi-cross-dso``."
msgstr ""

#: ../../../ControlFlowIntegrity.rst:240
msgid "``-fsanitize=cfi-icall`` and ``-fsanitize=function``"
msgstr ""

#: ../../../ControlFlowIntegrity.rst:242
msgid ""
"This tool is similar to ``-fsanitize=function`` in that both tools check the "
"types of function calls. However, the two tools occupy different points on "
"the design space; ``-fsanitize=function`` is a developer tool designed to "
"find bugs in local development builds, whereas ``-fsanitize=cfi-icall`` is a "
"security hardening mechanism designed to be deployed in release builds."
msgstr ""

#: ../../../ControlFlowIntegrity.rst:248
msgid ""
"``-fsanitize=function`` has a higher space and time overhead due to a more "
"complex type check at indirect call sites, as well as a need for run-time "
"type information (RTTI), which may make it unsuitable for deployment. "
"Because of the need for RTTI, ``-fsanitize=function`` can only be used with "
"C++ programs, whereas ``-fsanitize=cfi-icall`` can protect both C and C++ "
"programs."
msgstr ""

#: ../../../ControlFlowIntegrity.rst:254
msgid ""
"On the other hand, ``-fsanitize=function`` conforms more closely with the C+"
"+ standard and user expectations around interaction with shared libraries; "
"the identity of function pointers is maintained, and calls across shared "
"library boundaries are no different from calls within a single program or "
"shared library."
msgstr ""

#: ../../../ControlFlowIntegrity.rst:261
msgid "Member Function Pointer Call Checking"
msgstr ""

#: ../../../ControlFlowIntegrity.rst:263
msgid ""
"This scheme checks that indirect calls via a member function pointer take "
"place using an object of the correct dynamic type. Specifically, we check "
"that the dynamic type of the member function referenced by the member "
"function pointer matches the \"function pointer\" part of the member "
"function pointer, and that the member function's class type is related to "
"the base type of the member function. This CFI scheme can be enabled on its "
"own using ``-fsanitize=cfi-mfcall``."
msgstr ""

#: ../../../ControlFlowIntegrity.rst:271
msgid ""
"The compiler will only emit a full CFI check if the member function "
"pointer's base type is complete. This is because the complete definition of "
"the base type contains information that is necessary to correctly compile "
"the CFI check. To ensure that the compiler always emits a full CFI check, it "
"is recommended to also pass the flag ``-fcomplete-member-pointers``, which "
"enables a non-conforming language extension that requires member pointer "
"base types to be complete if they may be used for a call."
msgstr ""

#: ../../../ControlFlowIntegrity.rst:285
msgid ""
"This scheme is currently not compatible with cross-DSO CFI or the Microsoft "
"ABI."
msgstr ""

#: ../../../ControlFlowIntegrity.rst:291
msgid "Blacklist"
msgstr ""

#: ../../../ControlFlowIntegrity.rst:293
msgid ""
"A :doc:`SanitizerSpecialCaseList` can be used to relax CFI checks for "
"certain source files, functions and types using the ``src``, ``fun`` and "
"``type`` entity types. Specific CFI modes can be be specified using "
"``[section]`` headers."
msgstr ""

#: ../../../ControlFlowIntegrity.rst:318
msgid "Shared library support"
msgstr ""

#: ../../../ControlFlowIntegrity.rst:320
msgid ""
"Use **-f[no-]sanitize-cfi-cross-dso** to enable the cross-DSO control flow "
"integrity mode, which allows all CFI schemes listed above to apply across "
"DSO boundaries. As in the regular CFI, each DSO must be built with ``-flto``."
msgstr ""

#: ../../../ControlFlowIntegrity.rst:325
msgid ""
"Normally, CFI checks will only be performed for classes that have hidden LTO "
"visibility. With this flag enabled, the compiler will emit cross-DSO CFI "
"checks for all classes, except for those which appear in the CFI blacklist "
"or which use a ``no_sanitize`` attribute."
msgstr ""

#: ../../../ControlFlowIntegrity.rst:331
msgid "Design"
msgstr ""

#: ../../../ControlFlowIntegrity.rst:333
msgid "Please refer to the :doc:`design document<ControlFlowIntegrityDesign>`."
msgstr ""

#: ../../../ControlFlowIntegrity.rst:336
msgid "Publications"
msgstr ""

#: ../../../ControlFlowIntegrity.rst:338
msgid ""
"`Control-Flow Integrity: Principles, Implementations, and Applications "
"<https://research.microsoft.com/pubs/64250/ccs05.pdf>`_. Martin Abadi, Mihai "
"Budiu, Úlfar Erlingsson, Jay Ligatti."
msgstr ""

#: ../../../ControlFlowIntegrity.rst:341
msgid ""
"`Enforcing Forward-Edge Control-Flow Integrity in GCC & LLVM <http://www.pcc."
"me.uk/~peter/acad/usenix14.pdf>`_. Caroline Tice, Tom Roeder, Peter "
"Collingbourne, Stephen Checkoway, Úlfar Erlingsson, Luis Lozano, Geoff Pike."
msgstr ""
