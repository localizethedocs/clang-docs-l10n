# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2025, The Clang Team
# This file is distributed under the same license as the Clang package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Clang 16\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-13 13:42+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../analyzer/developer-docs/nullability.rst:3
msgid "Nullability Checks"
msgstr ""

#: ../../../analyzer/developer-docs/nullability.rst:5
msgid ""
"This document is a high level description of the nullablility checks. These "
"checks intended to use the annotations that is described in this RFC: "
"https://discourse.llvm.org/t/rfc-nullability-qualifiers/35672 (`Mailman "
"<https://lists.llvm.org/pipermail/cfe-dev/2015-March/041779.html>`_)"
msgstr ""

#: ../../../analyzer/developer-docs/nullability.rst:10
msgid "Let's consider the following 2 categories:"
msgstr ""

#: ../../../analyzer/developer-docs/nullability.rst:12
msgid "**1) nullable**"
msgstr ""

#: ../../../analyzer/developer-docs/nullability.rst:14
msgid ""
"If a pointer ``p`` has a nullable annotation and no explicit null check or "
"assert, we should warn in the following cases:"
msgstr ""

#: ../../../analyzer/developer-docs/nullability.rst:16
msgid ""
"``p`` gets implicitly converted into nonnull pointer, for example, we are "
"passing it to a function that takes a nonnull parameter."
msgstr ""

#: ../../../analyzer/developer-docs/nullability.rst:17
msgid "``p`` gets dereferenced"
msgstr ""

#: ../../../analyzer/developer-docs/nullability.rst:19
msgid ""
"Taking a branch on nullable pointers are the same like taking branch on null "
"unspecified pointers."
msgstr ""

#: ../../../analyzer/developer-docs/nullability.rst:21
msgid "Explicit cast from nullable to nonnul:"
msgstr ""

#: ../../../analyzer/developer-docs/nullability.rst:30
msgid ""
"Because bar corresponds to the same symbol all the time it is not easy to "
"implement the checker that way the cast only suppress the first call but not "
"the second. For this reason in the first implementation after a "
"contradictory cast happens, I will treat bar as nullable unspecified, this "
"way all of the warnings will be suppressed. Treating the symbol as nullable "
"unspecified also has an advantage that in case the takesNonNull function "
"body is being inlined, the will be no warning, when the symbol is "
"dereferenced. In case I have time after the initial version I might spend "
"additional time to try to find a more sophisticated solution, in which we "
"would produce the second warning (*)."
msgstr ""

#: ../../../analyzer/developer-docs/nullability.rst:32
msgid "**2) nonnull**"
msgstr ""

#: ../../../analyzer/developer-docs/nullability.rst:34
msgid "Dereferencing a nonnull, or sending message to it is ok."
msgstr ""

#: ../../../analyzer/developer-docs/nullability.rst:35
msgid "Converting nonnull to nullable is Ok."
msgstr ""

#: ../../../analyzer/developer-docs/nullability.rst:36
msgid ""
"When there is an explicit cast from nonnull to nullable I will trust the "
"cast (it is probable there for a reason, because this cast does not suppress "
"any warnings or errors)."
msgstr ""

#: ../../../analyzer/developer-docs/nullability.rst:37
msgid "But what should we do about null checks?:"
msgstr ""

#: ../../../analyzer/developer-docs/nullability.rst:50
msgid "There are these directions:"
msgstr ""

#: ../../../analyzer/developer-docs/nullability.rst:52
msgid "We can either take the branch; this way the branch is analyzed"
msgstr ""

#: ../../../analyzer/developer-docs/nullability.rst:53
msgid ""
"Should we not warn about any nullability issues in that branch? Probably "
"not, it is ok to break the nullability postconditions when the nullability "
"preconditions are violated."
msgstr ""

#: ../../../analyzer/developer-docs/nullability.rst:54
msgid ""
"We can assume that these pointers are not null and we lose coverage with the "
"analyzer. (This can be implemented either in constraint solver or in the "
"checker itself.)"
msgstr ""

#: ../../../analyzer/developer-docs/nullability.rst:56
msgid "Other Issues to keep in mind/take care of:"
msgstr ""

#: ../../../analyzer/developer-docs/nullability.rst:58
msgid "Messaging:"
msgstr ""

#: ../../../analyzer/developer-docs/nullability.rst:60
msgid "Sending a message to a nullable pointer"
msgstr ""

#: ../../../analyzer/developer-docs/nullability.rst:63
msgid ""
"Even though the method might return a nonnull pointer, when it was sent to a "
"nullable pointer the return type will be nullable."
msgstr ""

#: ../../../analyzer/developer-docs/nullability.rst:63
msgid "The result is nullable unless the receiver is known to be non null."
msgstr ""

#: ../../../analyzer/developer-docs/nullability.rst:65
msgid "Sending a message to a unspecified or nonnull pointer"
msgstr ""

#: ../../../analyzer/developer-docs/nullability.rst:67
msgid ""
"If the pointer is not assumed to be nil, we should be optimistic and use the "
"nullability implied by the method."
msgstr ""

#: ../../../analyzer/developer-docs/nullability.rst:69
msgid ""
"This will not happen automatically, since the AST will have null unspecified "
"in this case."
msgstr ""

#: ../../../analyzer/developer-docs/nullability.rst:72
msgid "Inlining"
msgstr ""

#: ../../../analyzer/developer-docs/nullability.rst:74
msgid ""
"A symbol may need to be treated differently inside an inlined body. For "
"example, consider these conversions from nonnull to nullable in presence of "
"inlining:"
msgstr ""

#: ../../../analyzer/developer-docs/nullability.rst:86
msgid ""
"With no special treatment, when the takesNullable is inlined the analyzer "
"will not warn when the obj symbol is dereferenced. One solution for this is "
"to reanalyze takesNullable as a top level function to get possible "
"violations. The alternative method, deducing nullability information from "
"the arguments after inlining is not robust enough (for example there might "
"be more parameters with different nullability, but in the given path the two "
"parameters might end up being the same symbol or there can be nested "
"functions that take different view of the nullability of the same symbol). "
"So the symbol will remain nonnull to avoid false positives but the functions "
"that takes nullable parameters will be analyzed separately as well without "
"inlining."
msgstr ""

#: ../../../analyzer/developer-docs/nullability.rst:89
msgid "Annotations on multi level pointers"
msgstr ""

#: ../../../analyzer/developer-docs/nullability.rst:91
msgid ""
"Tracking multiple levels of annotations for pointers pointing to pointers "
"would make the checker more complicated, because this way a vector of "
"nullability qualifiers would be needed to be tracked for each symbol. This "
"is not a big caveat, since once the top level pointer is dereferenced, the "
"symvol for the inner pointer will have the nullability information. The lack "
"of multi level annotation tracking only observable, when multiple levels of "
"pointers are passed to a function which has a parameter with multiple levels "
"of annotations. So for now the checker support the top level nullability "
"qualifiers only.:"
msgstr ""

#: ../../../analyzer/developer-docs/nullability.rst:100
msgid "Implementation notes"
msgstr ""

#: ../../../analyzer/developer-docs/nullability.rst:102
msgid "What to track?"
msgstr ""

#: ../../../analyzer/developer-docs/nullability.rst:104
msgid ""
"The checker would track memory regions, and to each relevant region a "
"qualifier information would be attached which is either nullable, nonnull or "
"null unspecified (or contradicted to suppress warnings for a specific "
"region)."
msgstr ""

#: ../../../analyzer/developer-docs/nullability.rst:105
msgid ""
"On a branch, where a nullable pointer is known to be non null, the checker "
"treat it as a same way as a pointer annotated as nonnull."
msgstr ""

#: ../../../analyzer/developer-docs/nullability.rst:106
msgid ""
"When there is an explicit cast from a null unspecified to either nonnull or "
"nullable I will trust the cast."
msgstr ""

#: ../../../analyzer/developer-docs/nullability.rst:107
msgid ""
"Unannotated pointers are treated the same way as pointers annotated with "
"nullability unspecified qualifier, unless the region is wrapped in "
"ASSUME_NONNULL macros."
msgstr ""

#: ../../../analyzer/developer-docs/nullability.rst:108
msgid ""
"We might want to implement a callback for entry points to top level "
"functions, where the pointer nullability assumptions would be made."
msgstr ""
