<!DOCTYPE html>

<html lang="fr-FR" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>SanitizerCoverage &#8212; Documentation Clang 4</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=d75fae25" />
    <link rel="stylesheet" type="text/css" href="_static/haiku.css?v=fce32b03" />
    <script src="_static/documentation_options.js?v=2dfbda0a"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/translations.js?v=aa914e54"></script>
    <link rel="canonical" href="https://projects.localizethedocs.org/clang-docs-l10n/SanitizerCoverage.html" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Recherche" href="search.html" />
    <link rel="next" title="SanitizerStats" href="SanitizerStats.html" />
    <link rel="prev" title="LeakSanitizer" href="LeakSanitizer.html" />
<script type="text/javascript" src="ltd-provenance.js"></script>
<script type="text/javascript" src="ltd-current.js"></script>
<script type="text/javascript" src="../../ltd-config.js"></script>
<script type="text/javascript" src="../../ltd-flyout.js"></script>

  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Documentation Clang 4</span></a></h1>
        <h2 class="heading"><span>SanitizerCoverage</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="Top">
      
        <p>
        «&#160;&#160;<a href="LeakSanitizer.html">LeakSanitizer</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contenu</a>
        &#160;&#160;::&#160;&#160;
        <a href="SanitizerStats.html">SanitizerStats</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="sanitizercoverage">
<h1>SanitizerCoverage<a class="headerlink" href="#sanitizercoverage" title="Lien vers cette rubrique">¶</a></h1>
<nav class="contents local" id="sommaire">
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id1">Introduction</a></p></li>
<li><p><a class="reference internal" href="#how-to-build-and-run" id="id2">How to build and run</a></p></li>
<li><p><a class="reference internal" href="#postprocessing" id="id3">Postprocessing</a></p></li>
<li><p><a class="reference internal" href="#sancov-tool" id="id4">Sancov Tool</a></p></li>
<li><p><a class="reference internal" href="#coverage-reports-experimental" id="id5">Coverage Reports (Experimental)</a></p></li>
<li><p><a class="reference internal" href="#how-good-is-the-coverage" id="id6">How good is the coverage?</a></p></li>
<li><p><a class="reference internal" href="#edge-coverage" id="id7">Edge coverage</a></p></li>
<li><p><a class="reference internal" href="#bitset" id="id8">Bitset</a></p></li>
<li><p><a class="reference internal" href="#caller-callee-coverage" id="id9">Caller-callee coverage</a></p></li>
<li><p><a class="reference internal" href="#coverage-counters" id="id10">Coverage counters</a></p></li>
<li><p><a class="reference internal" href="#tracing-basic-blocks" id="id11">Tracing basic blocks</a></p></li>
<li><p><a class="reference internal" href="#tracing-pcs" id="id12">Tracing PCs</a></p></li>
<li><p><a class="reference internal" href="#tracing-pcs-with-guards" id="id13">Tracing PCs with guards</a></p></li>
<li><p><a class="reference internal" href="#tracing-data-flow" id="id14">Tracing data flow</a></p></li>
<li><p><a class="reference internal" href="#output-directory" id="id15">Output directory</a></p></li>
<li><p><a class="reference internal" href="#sudden-death" id="id16">Sudden death</a></p></li>
<li><p><a class="reference internal" href="#in-process-fuzzing" id="id17">In-process fuzzing</a></p></li>
<li><p><a class="reference internal" href="#performance" id="id18">Performance</a></p></li>
<li><p><a class="reference internal" href="#why-another-coverage" id="id19">Why another coverage?</a></p></li>
</ul>
</nav>
<section id="introduction">
<h2><a class="toc-backref" href="#id1" role="doc-backlink">Introduction</a><a class="headerlink" href="#introduction" title="Lien vers cette rubrique">¶</a></h2>
<p>Sanitizer tools have a very simple code coverage tool built in. It allows to
get function-level, basic-block-level, and edge-level coverage at a very low
cost.</p>
</section>
<section id="how-to-build-and-run">
<h2><a class="toc-backref" href="#id2" role="doc-backlink">How to build and run</a><a class="headerlink" href="#how-to-build-and-run" title="Lien vers cette rubrique">¶</a></h2>
<p>SanitizerCoverage can be used with <a class="reference internal" href="AddressSanitizer.html"><span class="doc">AddressSanitizer</span></a>,
<a class="reference internal" href="LeakSanitizer.html"><span class="doc">LeakSanitizer</span></a>, <a class="reference internal" href="MemorySanitizer.html"><span class="doc">MemorySanitizer</span></a>,
UndefinedBehaviorSanitizer, or without any sanitizer.  Pass one of the
following compile-time flags:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">-fsanitize-coverage=func</span></code> for function-level coverage (very fast).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-fsanitize-coverage=bb</span></code> for basic-block-level coverage (may add up to 30%
<strong>extra</strong> slowdown).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-fsanitize-coverage=edge</span></code> for edge-level coverage (up to 40% slowdown).</p></li>
</ul>
<p>You may also specify <code class="docutils literal notranslate"><span class="pre">-fsanitize-coverage=indirect-calls</span></code> for
additional <a class="reference internal" href="#caller-callee-coverage">caller-callee coverage</a>.</p>
<p>At run time, pass <code class="docutils literal notranslate"><span class="pre">coverage=1</span></code> in <code class="docutils literal notranslate"><span class="pre">ASAN_OPTIONS</span></code>,
<code class="docutils literal notranslate"><span class="pre">LSAN_OPTIONS</span></code>, <code class="docutils literal notranslate"><span class="pre">MSAN_OPTIONS</span></code> or <code class="docutils literal notranslate"><span class="pre">UBSAN_OPTIONS</span></code>, as
appropriate. For the standalone coverage mode, use <code class="docutils literal notranslate"><span class="pre">UBSAN_OPTIONS</span></code>.</p>
<p>To get <a class="reference internal" href="#coverage-counters">Coverage counters</a>, add <code class="docutils literal notranslate"><span class="pre">-fsanitize-coverage=8bit-counters</span></code>
to one of the above compile-time flags. At runtime, use
<code class="docutils literal notranslate"><span class="pre">*SAN_OPTIONS=coverage=1:coverage_counters=1</span></code>.</p>
<p>Example:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">% </span>cat<span class="w"> </span>-n<span class="w"> </span>cov.cc
<span class="go">     1  #include &lt;stdio.h&gt;</span>
<span class="go">     2  __attribute__((noinline))</span>
<span class="go">     3  void foo() { printf(&quot;foo\n&quot;); }</span>
<span class="go">     4</span>
<span class="go">     5  int main(int argc, char **argv) {</span>
<span class="go">     6    if (argc == 2)</span>
<span class="go">     7      foo();</span>
<span class="go">     8    printf(&quot;main\n&quot;);</span>
<span class="go">     9  }</span>
<span class="gp">% </span>clang++<span class="w"> </span>-g<span class="w"> </span>cov.cc<span class="w"> </span>-fsanitize<span class="o">=</span>address<span class="w"> </span>-fsanitize-coverage<span class="o">=</span>func
<span class="gp">% </span><span class="nv">ASAN_OPTIONS</span><span class="o">=</span><span class="nv">coverage</span><span class="o">=</span><span class="m">1</span><span class="w"> </span>./a.out<span class="p">;</span><span class="w"> </span>ls<span class="w"> </span>-l<span class="w"> </span>*sancov
<span class="go">main</span>
<span class="go">-rw-r----- 1 kcc eng 4 Nov 27 12:21 a.out.22673.sancov</span>
<span class="gp">% </span><span class="nv">ASAN_OPTIONS</span><span class="o">=</span><span class="nv">coverage</span><span class="o">=</span><span class="m">1</span><span class="w"> </span>./a.out<span class="w"> </span>foo<span class="w"> </span><span class="p">;</span><span class="w"> </span>ls<span class="w"> </span>-l<span class="w"> </span>*sancov
<span class="go">foo</span>
<span class="go">main</span>
<span class="go">-rw-r----- 1 kcc eng 4 Nov 27 12:21 a.out.22673.sancov</span>
<span class="go">-rw-r----- 1 kcc eng 8 Nov 27 12:21 a.out.22679.sancov</span>
</pre></div>
</div>
<p>Every time you run an executable instrumented with SanitizerCoverage
one <code class="docutils literal notranslate"><span class="pre">*.sancov</span></code> file is created during the process shutdown.
If the executable is dynamically linked against instrumented DSOs,
one <code class="docutils literal notranslate"><span class="pre">*.sancov</span></code> file will be also created for every DSO.</p>
</section>
<section id="postprocessing">
<h2><a class="toc-backref" href="#id3" role="doc-backlink">Postprocessing</a><a class="headerlink" href="#postprocessing" title="Lien vers cette rubrique">¶</a></h2>
<p>The format of <code class="docutils literal notranslate"><span class="pre">*.sancov</span></code> files is very simple: the first 8 bytes is the magic,
one of <code class="docutils literal notranslate"><span class="pre">0xC0BFFFFFFFFFFF64</span></code> and <code class="docutils literal notranslate"><span class="pre">0xC0BFFFFFFFFFFF32</span></code>. The last byte of the
magic defines the size of the following offsets. The rest of the data is the
offsets in the corresponding binary/DSO that were executed during the run.</p>
<p>A simple script
<code class="docutils literal notranslate"><span class="pre">$LLVM/projects/compiler-rt/lib/sanitizer_common/scripts/sancov.py</span></code> is
provided to dump these offsets.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">% </span>sancov.py<span class="w"> </span>print<span class="w"> </span>a.out.22679.sancov<span class="w"> </span>a.out.22673.sancov
<span class="go">sancov.py: read 2 PCs from a.out.22679.sancov</span>
<span class="go">sancov.py: read 1 PCs from a.out.22673.sancov</span>
<span class="go">sancov.py: 2 files merged; 2 PCs total</span>
<span class="go">0x465250</span>
<span class="go">0x4652a0</span>
</pre></div>
</div>
<p>You can then filter the output of <code class="docutils literal notranslate"><span class="pre">sancov.py</span></code> through <code class="docutils literal notranslate"><span class="pre">addr2line</span> <span class="pre">--exe</span>
<span class="pre">ObjectFile</span></code> or <code class="docutils literal notranslate"><span class="pre">llvm-symbolizer</span> <span class="pre">--obj</span> <span class="pre">ObjectFile</span></code> to get file names and line
numbers:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">% </span>sancov.py<span class="w"> </span>print<span class="w"> </span>a.out.22679.sancov<span class="w"> </span>a.out.22673.sancov<span class="w"> </span><span class="m">2</span>&gt;<span class="w"> </span>/dev/null<span class="w"> </span><span class="p">|</span><span class="w"> </span>llvm-symbolizer<span class="w"> </span>--obj<span class="w"> </span>a.out
<span class="go">cov.cc:3</span>
<span class="go">cov.cc:5</span>
</pre></div>
</div>
</section>
<section id="sancov-tool">
<h2><a class="toc-backref" href="#id4" role="doc-backlink">Sancov Tool</a><a class="headerlink" href="#sancov-tool" title="Lien vers cette rubrique">¶</a></h2>
<p>A new experimental <code class="docutils literal notranslate"><span class="pre">sancov</span></code> tool is developed to process coverage files.
The tool is part of LLVM project and is currently supported only on Linux.
It can handle symbolization tasks autonomously without any extra support
from the environment. You need to pass .sancov files (named
<code class="docutils literal notranslate"><span class="pre">&lt;module_name&gt;.&lt;pid&gt;.sancov</span></code> and paths to all corresponding binary elf files.
Sancov matches these files using module names and binaries file names.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">USAGE: sancov [options] &lt;action&gt; (&lt;binary file&gt;|&lt;.sancov file&gt;)...</span>

<span class="go">Action (required)</span>
<span class="go">  -print                    - Print coverage addresses</span>
<span class="go">  -covered-functions        - Print all covered functions.</span>
<span class="go">  -not-covered-functions    - Print all not covered functions.</span>
<span class="go">  -symbolize                - Symbolizes the report.</span>

<span class="go">Options</span>
<span class="go">  -blacklist=&lt;string&gt;         - Blacklist file (sanitizer blacklist format).</span>
<span class="go">  -demangle                   - Print demangled function name.</span>
<span class="go">  -strip_path_prefix=&lt;string&gt; - Strip this prefix from file paths in reports</span>
</pre></div>
</div>
</section>
<section id="coverage-reports-experimental">
<h2><a class="toc-backref" href="#id5" role="doc-backlink">Coverage Reports (Experimental)</a><a class="headerlink" href="#coverage-reports-experimental" title="Lien vers cette rubrique">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">.sancov</span></code> files do not contain enough information to generate a source-level
coverage report. The missing information is contained
in debug info of the binary. Thus the <code class="docutils literal notranslate"><span class="pre">.sancov</span></code> has to be symbolized
to produce a <code class="docutils literal notranslate"><span class="pre">.symcov</span></code> file first:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">sancov -symbolize my_program.123.sancov my_program &gt; my_program.123.symcov</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">.symcov</span></code> file can be browsed overlayed over the source code by
running <code class="docutils literal notranslate"><span class="pre">tools/sancov/coverage-report-server.py</span></code> script that will start
an HTTP server.</p>
</section>
<section id="how-good-is-the-coverage">
<h2><a class="toc-backref" href="#id6" role="doc-backlink">How good is the coverage?</a><a class="headerlink" href="#how-good-is-the-coverage" title="Lien vers cette rubrique">¶</a></h2>
<p>It is possible to find out which PCs are not covered, by subtracting the covered
set from the set of all instrumented PCs. The latter can be obtained by listing
all callsites of <code class="docutils literal notranslate"><span class="pre">__sanitizer_cov()</span></code> in the binary. On Linux, <code class="docutils literal notranslate"><span class="pre">sancov.py</span></code>
can do this for you. Just supply the path to binary and a list of covered PCs:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">% </span>sancov.py<span class="w"> </span>print<span class="w"> </span>a.out.12345.sancov<span class="w"> </span>&gt;<span class="w"> </span>covered.txt
<span class="go">sancov.py: read 2 64-bit PCs from a.out.12345.sancov</span>
<span class="go">sancov.py: 1 file merged; 2 PCs total</span>
<span class="gp">% </span>sancov.py<span class="w"> </span>missing<span class="w"> </span>a.out<span class="w"> </span>&lt;<span class="w"> </span>covered.txt
<span class="go">sancov.py: found 3 instrumented PCs in a.out</span>
<span class="go">sancov.py: read 2 PCs from stdin</span>
<span class="go">sancov.py: 1 PCs missing from coverage</span>
<span class="go">0x4cc61c</span>
</pre></div>
</div>
</section>
<section id="edge-coverage">
<h2><a class="toc-backref" href="#id7" role="doc-backlink">Edge coverage</a><a class="headerlink" href="#edge-coverage" title="Lien vers cette rubrique">¶</a></h2>
<p>Consider this code:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="w">    </span><span class="o">*</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>It contains 3 basic blocks, let’s name them A, B, C:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>A
|\
| \
|  B
| /
|/
C
</pre></div>
</div>
<p>If blocks A, B, and C are all covered we know for certain that the edges A=&gt;B
and B=&gt;C were executed, but we still don’t know if the edge A=&gt;C was executed.
Such edges of control flow graph are called
<a class="reference external" href="http://en.wikipedia.org/wiki/Control_flow_graph#Special_edges">critical</a>. The
edge-level coverage (<code class="docutils literal notranslate"><span class="pre">-fsanitize-coverage=edge</span></code>) simply splits all critical
edges by introducing new dummy blocks and then instruments those blocks:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>A
|\
| \
D  B
| /
|/
C
</pre></div>
</div>
</section>
<section id="bitset">
<h2><a class="toc-backref" href="#id8" role="doc-backlink">Bitset</a><a class="headerlink" href="#bitset" title="Lien vers cette rubrique">¶</a></h2>
<p>When <code class="docutils literal notranslate"><span class="pre">coverage_bitset=1</span></code> run-time flag is given, the coverage will also be
dumped as a bitset (text file with 1 for blocks that have been executed and 0
for blocks that were not).</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">% </span>clang++<span class="w"> </span>-fsanitize<span class="o">=</span>address<span class="w"> </span>-fsanitize-coverage<span class="o">=</span>edge<span class="w"> </span>cov.cc
<span class="gp">% </span><span class="nv">ASAN_OPTIONS</span><span class="o">=</span><span class="s2">&quot;coverage=1:coverage_bitset=1&quot;</span><span class="w"> </span>./a.out
<span class="go">main</span>
<span class="gp">% </span><span class="nv">ASAN_OPTIONS</span><span class="o">=</span><span class="s2">&quot;coverage=1:coverage_bitset=1&quot;</span><span class="w"> </span>./a.out<span class="w"> </span><span class="m">1</span>
<span class="go">foo</span>
<span class="go">main</span>
<span class="gp">% </span>head<span class="w"> </span>*bitset*
<span class="go">==&gt; a.out.38214.bitset-sancov &lt;==</span>
<span class="go">01101</span>
<span class="go">==&gt; a.out.6128.bitset-sancov &lt;==</span>
<span class="go">11011%</span>
</pre></div>
</div>
<p>For a given executable the length of the bitset is always the same (well,
unless dlopen/dlclose come into play), so the bitset coverage can be
easily used for bitset-based corpus distillation.</p>
</section>
<section id="caller-callee-coverage">
<h2><a class="toc-backref" href="#id9" role="doc-backlink">Caller-callee coverage</a><a class="headerlink" href="#caller-callee-coverage" title="Lien vers cette rubrique">¶</a></h2>
<p>(Experimental!)
Every indirect function call is instrumented with a run-time function call that
captures caller and callee.  At the shutdown time the process dumps a separate
file called <code class="docutils literal notranslate"><span class="pre">caller-callee.PID.sancov</span></code> which contains caller/callee pairs as
pairs of lines (odd lines are callers, even lines are callees)</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">a.out 0x4a2e0c</span>
<span class="go">a.out 0x4a6510</span>
<span class="go">a.out 0x4a2e0c</span>
<span class="go">a.out 0x4a87f0</span>
</pre></div>
</div>
<p>Current limitations:</p>
<ul class="simple">
<li><p>Only the first 14 callees for every caller are recorded, the rest are silently
ignored.</p></li>
<li><p>The output format is not very compact since caller and callee may reside in
different modules and we need to spell out the module names.</p></li>
<li><p>The routine that dumps the output is not optimized for speed</p></li>
<li><p>Only Linux x86_64 is tested so far.</p></li>
<li><p>Sandboxes are not supported.</p></li>
</ul>
</section>
<section id="coverage-counters">
<h2><a class="toc-backref" href="#id10" role="doc-backlink">Coverage counters</a><a class="headerlink" href="#coverage-counters" title="Lien vers cette rubrique">¶</a></h2>
<p>This experimental feature is inspired by
<a class="reference external" href="http://lcamtuf.coredump.cx/afl/technical_details.txt">AFL</a>’s coverage
instrumentation. With additional compile-time and run-time flags you can get
more sensitive coverage information.  In addition to boolean values assigned to
every basic block (edge) the instrumentation will collect imprecise counters.
On exit, every counter will be mapped to a 8-bit bitset representing counter
ranges: <code class="docutils literal notranslate"><span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4-7,</span> <span class="pre">8-15,</span> <span class="pre">16-31,</span> <span class="pre">32-127,</span> <span class="pre">128+</span></code> and those 8-bit bitsets will
be dumped to disk.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">% </span>clang++<span class="w"> </span>-g<span class="w"> </span>cov.cc<span class="w"> </span>-fsanitize<span class="o">=</span>address<span class="w"> </span>-fsanitize-coverage<span class="o">=</span>edge,8bit-counters
<span class="gp">% </span><span class="nv">ASAN_OPTIONS</span><span class="o">=</span><span class="s2">&quot;coverage=1:coverage_counters=1&quot;</span><span class="w"> </span>./a.out
<span class="gp">% </span>ls<span class="w"> </span>-l<span class="w"> </span>*counters-sancov
<span class="go">... a.out.17110.counters-sancov</span>
<span class="gp">% </span>xxd<span class="w"> </span>*counters-sancov
<span class="go">0000000: 0001 0100 01</span>
</pre></div>
</div>
<p>These counters may also be used for in-process coverage-guided fuzzers. See
<code class="docutils literal notranslate"><span class="pre">include/sanitizer/coverage_interface.h</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// The coverage instrumentation may optionally provide imprecise counters.</span>
<span class="c1">// Rather than exposing the counter values to the user we instead map</span>
<span class="c1">// the counters to a bitset.</span>
<span class="c1">// Every counter is associated with 8 bits in the bitset.</span>
<span class="c1">// We define 8 value ranges: 1, 2, 3, 4-7, 8-15, 16-31, 32-127, 128+</span>
<span class="c1">// The i-th bit is set to 1 if the counter value is in the i-th range.</span>
<span class="c1">// This counter-based coverage implementation is *not* thread-safe.</span>

<span class="c1">// Returns the number of registered coverage counters.</span>
<span class="kt">uintptr_t</span><span class="w"> </span><span class="nf">__sanitizer_get_number_of_counters</span><span class="p">();</span>
<span class="c1">// Updates the counter &#39;bitset&#39;, clears the counters and returns the number of</span>
<span class="c1">// new bits in &#39;bitset&#39;.</span>
<span class="c1">// If &#39;bitset&#39; is nullptr, only clears the counters.</span>
<span class="c1">// Otherwise &#39;bitset&#39; should be at least</span>
<span class="c1">// __sanitizer_get_number_of_counters bytes long and 8-aligned.</span>
<span class="kt">uintptr_t</span>
<span class="nf">__sanitizer_update_counter_bitset_and_clear_counters</span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">bitset</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="tracing-basic-blocks">
<h2><a class="toc-backref" href="#id11" role="doc-backlink">Tracing basic blocks</a><a class="headerlink" href="#tracing-basic-blocks" title="Lien vers cette rubrique">¶</a></h2>
<p>Experimental support for basic block (or edge) tracing.
With <code class="docutils literal notranslate"><span class="pre">-fsanitize-coverage=trace-bb</span></code> the compiler will insert
<code class="docutils literal notranslate"><span class="pre">__sanitizer_cov_trace_basic_block(s32</span> <span class="pre">*id)</span></code> before every function, basic block, or edge
(depending on the value of <code class="docutils literal notranslate"><span class="pre">-fsanitize-coverage=[func,bb,edge]</span></code>).
Example:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">% </span>clang<span class="w"> </span>-g<span class="w"> </span>-fsanitize<span class="o">=</span>address<span class="w"> </span>-fsanitize-coverage<span class="o">=</span>edge,trace-bb<span class="w"> </span>foo.cc
<span class="gp">% </span><span class="nv">ASAN_OPTIONS</span><span class="o">=</span><span class="nv">coverage</span><span class="o">=</span><span class="m">1</span><span class="w"> </span>./a.out
</pre></div>
</div>
<p>This will produce two files after the process exit:
<cite>trace-points.PID.sancov</cite> and <cite>trace-events.PID.sancov</cite>.
The first file will contain a textual description of all the instrumented points in the program
in the form that you can feed into llvm-symbolizer (e.g. <cite>a.out 0x4dca89</cite>), one per line.
The second file will contain the actual execution trace as a sequence of 4-byte integers
– these integers are the indices into the array of instrumented points (the first file).</p>
<p>Basic block tracing is currently supported only for single-threaded applications.</p>
</section>
<section id="tracing-pcs">
<h2><a class="toc-backref" href="#id12" role="doc-backlink">Tracing PCs</a><a class="headerlink" href="#tracing-pcs" title="Lien vers cette rubrique">¶</a></h2>
<p><em>Experimental</em> feature similar to tracing basic blocks, but with a different API.
With <code class="docutils literal notranslate"><span class="pre">-fsanitize-coverage=trace-pc</span></code> the compiler will insert
<code class="docutils literal notranslate"><span class="pre">__sanitizer_cov_trace_pc()</span></code> on every edge.
With an additional <code class="docutils literal notranslate"><span class="pre">...=trace-pc,indirect-calls</span></code> flag
<code class="docutils literal notranslate"><span class="pre">__sanitizer_cov_trace_pc_indirect(void</span> <span class="pre">*callee)</span></code> will be inserted on every indirect call.
These callbacks are not implemented in the Sanitizer run-time and should be defined
by the user. So, these flags do not require the other sanitizer to be used.
This mechanism is used for fuzzing the Linux kernel (<a class="reference external" href="https://github.com/google/syzkaller">https://github.com/google/syzkaller</a>)
and can be used with <a class="reference external" href="http://lcamtuf.coredump.cx/afl">AFL</a>.</p>
</section>
<section id="tracing-pcs-with-guards">
<h2><a class="toc-backref" href="#id13" role="doc-backlink">Tracing PCs with guards</a><a class="headerlink" href="#tracing-pcs-with-guards" title="Lien vers cette rubrique">¶</a></h2>
<p>Another <em>experimental</em> feature that tries to combine the functionality of <cite>trace-pc</cite>,
<cite>8bit-counters</cite> and boolean coverage.</p>
<p>With <code class="docutils literal notranslate"><span class="pre">-fsanitize-coverage=trace-pc-guard</span></code> the compiler will insert the following code
on every edge:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if (guard_variable)
  __sanitizer_cov_trace_pc_guard(&amp;guard_variable)
</pre></div>
</div>
<p>Every edge will have its own <cite>guard_variable</cite> (uint32_t).</p>
<p>The compler will also insert a module constructor that will call</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// The guards are [start, stop).</span>
<span class="c1">// This function may be called multiple times with the same values of start/stop.</span>
<span class="n">__sanitizer_cov_trace_pc_guard_init</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">stop</span><span class="p">);</span>
</pre></div>
</div>
<p>Similarly to <cite>trace-pc,indirect-calls</cite>, with <cite>trace-pc-guards,indirect-calls</cite>
<code class="docutils literal notranslate"><span class="pre">__sanitizer_cov_trace_pc_indirect(void</span> <span class="pre">*callee)</span></code> will be inserted on every indirect call.</p>
<p>The functions <cite>__sanitizer_cov_trace_pc_*</cite> should be defined by the user.</p>
<p>Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// trace-pc-guard-cb.cc</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdint.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;sanitizer/coverage_interface.h&gt;</span>

<span class="c1">// This callback is inserted by the compiler as a module constructor</span>
<span class="c1">// into every compilation unit. &#39;start&#39; and &#39;stop&#39; correspond to the</span>
<span class="c1">// beginning and end of the section with the guards for the entire</span>
<span class="c1">// binary (executable or DSO) and so it will be called multiple times</span>
<span class="c1">// with the same parameters.</span>
<span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">__sanitizer_cov_trace_pc_guard_init</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">start</span><span class="p">,</span>
<span class="w">                                                    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">stop</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w">  </span><span class="c1">// Counter for the guards.</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">start</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">stop</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">*</span><span class="n">start</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="p">;</span><span class="w">  </span><span class="c1">// Initialize only once.</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;INIT: %p %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">stop</span><span class="p">);</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">start</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">stop</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="o">*</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">++</span><span class="n">N</span><span class="p">;</span><span class="w">  </span><span class="c1">// Guards should start from 1.</span>
<span class="p">}</span>

<span class="c1">// This callback is inserted by the compiler on every edge in the</span>
<span class="c1">// control flow (some optimizations apply).</span>
<span class="c1">// Typically, the compiler will emit the code like this:</span>
<span class="c1">//    if(*guard)</span>
<span class="c1">//      __sanitizer_cov_trace_pc_guard(guard);</span>
<span class="c1">// But for large functions it will emit a simple call:</span>
<span class="c1">//    __sanitizer_cov_trace_pc_guard(guard);</span>
<span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">__sanitizer_cov_trace_pc_guard</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">guard</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!*</span><span class="n">guard</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="p">;</span><span class="w">  </span><span class="c1">// Duplicate the guard check.</span>
<span class="w">  </span><span class="c1">// If you set *guard to 0 this code will not be called again for this edge.</span>
<span class="w">  </span><span class="c1">// Now you can get the PC and do whatever you want:</span>
<span class="w">  </span><span class="c1">//   store it somewhere or symbolize it and print right away.</span>
<span class="w">  </span><span class="c1">// The values of `*guard` are as you set them in</span>
<span class="w">  </span><span class="c1">// __sanitizer_cov_trace_pc_guard_init and so you can make them consecutive</span>
<span class="w">  </span><span class="c1">// and use them to dereference an array or a bit vector.</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">PC</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_return_address</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">PcDescr</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
<span class="w">  </span><span class="c1">// This function is a part of the sanitizer run-time.</span>
<span class="w">  </span><span class="c1">// To use it, link with AddressSanitizer or other sanitizer.</span>
<span class="w">  </span><span class="n">__sanitizer_symbolize_pc</span><span class="p">(</span><span class="n">PC</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;%p %F %L&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">PcDescr</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">PcDescr</span><span class="p">));</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;guard: %p %x PC %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">guard</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">guard</span><span class="p">,</span><span class="w"> </span><span class="n">PcDescr</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// trace-pc-guard-example.cc</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">argv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">argc</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">foo</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">clang++ -g  -fsanitize-coverage=trace-pc-guard trace-pc-guard-example.cc -c</span>
<span class="go">clang++ trace-pc-guard-cb.cc trace-pc-guard-example.o -fsanitize=address</span>
<span class="go">ASAN_OPTIONS=strip_path_prefix=`pwd`/ ./a.out</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">INIT: 0x71bcd0 0x71bce0</span>
<span class="go">guard: 0x71bcd4 2 PC 0x4ecd5b in main trace-pc-guard-example.cc:2</span>
<span class="go">guard: 0x71bcd8 3 PC 0x4ecd9e in main trace-pc-guard-example.cc:3:7</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">ASAN_OPTIONS=strip_path_prefix=`pwd`/ ./a.out with-foo</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">INIT: 0x71bcd0 0x71bce0</span>
<span class="go">guard: 0x71bcd4 2 PC 0x4ecd5b in main trace-pc-guard-example.cc:3</span>
<span class="go">guard: 0x71bcdc 4 PC 0x4ecdc7 in main trace-pc-guard-example.cc:4:17</span>
<span class="go">guard: 0x71bcd0 1 PC 0x4ecd20 in foo() trace-pc-guard-example.cc:2:14</span>
</pre></div>
</div>
</section>
<section id="tracing-data-flow">
<h2><a class="toc-backref" href="#id14" role="doc-backlink">Tracing data flow</a><a class="headerlink" href="#tracing-data-flow" title="Lien vers cette rubrique">¶</a></h2>
<p>Support for data-flow-guided fuzzing.
With <code class="docutils literal notranslate"><span class="pre">-fsanitize-coverage=trace-cmp</span></code> the compiler will insert extra instrumentation
around comparison instructions and switch statements.
Similarly, with <code class="docutils literal notranslate"><span class="pre">-fsanitize-coverage=trace-div</span></code> the compiler will instrument
integer division instructions (to capture the right argument of division)
and with  <code class="docutils literal notranslate"><span class="pre">-fsanitize-coverage=trace-gep</span></code> –
the <a class="reference external" href="http://llvm.org/docs/GetElementPtr.html">LLVM GEP instructions</a>
(to capture array indices).</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Called before a comparison instruction.</span>
<span class="c1">// Arg1 and Arg2 are arguments of the comparison.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">__sanitizer_cov_trace_cmp1</span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">Arg1</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">Arg2</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">__sanitizer_cov_trace_cmp2</span><span class="p">(</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">Arg1</span><span class="p">,</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">Arg2</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">__sanitizer_cov_trace_cmp4</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">Arg1</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">Arg2</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">__sanitizer_cov_trace_cmp8</span><span class="p">(</span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">Arg1</span><span class="p">,</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">Arg2</span><span class="p">);</span>

<span class="c1">// Called before a switch statement.</span>
<span class="c1">// Val is the switch operand.</span>
<span class="c1">// Cases[0] is the number of case constants.</span>
<span class="c1">// Cases[1] is the size of Val in bits.</span>
<span class="c1">// Cases[2:] are the case constants.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">__sanitizer_cov_trace_switch</span><span class="p">(</span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">Val</span><span class="p">,</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="o">*</span><span class="n">Cases</span><span class="p">);</span>

<span class="c1">// Called before a division statement.</span>
<span class="c1">// Val is the second argument of division.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">__sanitizer_cov_trace_div4</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">Val</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">__sanitizer_cov_trace_div8</span><span class="p">(</span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">Val</span><span class="p">);</span>

<span class="c1">// Called before a GetElemementPtr (GEP) instruction</span>
<span class="c1">// for every non-constant array index.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">__sanitizer_cov_trace_gep</span><span class="p">(</span><span class="kt">uintptr_t</span><span class="w"> </span><span class="n">Idx</span><span class="p">);</span>
</pre></div>
</div>
<p>This interface is a subject to change.
The current implementation is not thread-safe and thus can be safely used only for single-threaded targets.</p>
</section>
<section id="output-directory">
<h2><a class="toc-backref" href="#id15" role="doc-backlink">Output directory</a><a class="headerlink" href="#output-directory" title="Lien vers cette rubrique">¶</a></h2>
<p>By default, .sancov files are created in the current working directory.
This can be changed with <code class="docutils literal notranslate"><span class="pre">ASAN_OPTIONS=coverage_dir=/path</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">% </span><span class="nv">ASAN_OPTIONS</span><span class="o">=</span><span class="s2">&quot;coverage=1:coverage_dir=/tmp/cov&quot;</span><span class="w"> </span>./a.out<span class="w"> </span>foo
<span class="gp">% </span>ls<span class="w"> </span>-l<span class="w"> </span>/tmp/cov/*sancov
<span class="go">-rw-r----- 1 kcc eng 4 Nov 27 12:21 a.out.22673.sancov</span>
<span class="go">-rw-r----- 1 kcc eng 8 Nov 27 12:21 a.out.22679.sancov</span>
</pre></div>
</div>
</section>
<section id="sudden-death">
<h2><a class="toc-backref" href="#id16" role="doc-backlink">Sudden death</a><a class="headerlink" href="#sudden-death" title="Lien vers cette rubrique">¶</a></h2>
<p>Normally, coverage data is collected in memory and saved to disk when the
program exits (with an <code class="docutils literal notranslate"><span class="pre">atexit()</span></code> handler), when a SIGSEGV is caught, or when
<code class="docutils literal notranslate"><span class="pre">__sanitizer_cov_dump()</span></code> is called.</p>
<p>If the program ends with a signal that ASan does not handle (or can not handle
at all, like SIGKILL), coverage data will be lost. This is a big problem on
Android, where SIGKILL is a normal way of evicting applications from memory.</p>
<p>With <code class="docutils literal notranslate"><span class="pre">ASAN_OPTIONS=coverage=1:coverage_direct=1</span></code> coverage data is written to a
memory-mapped file as soon as it collected.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">% </span><span class="nv">ASAN_OPTIONS</span><span class="o">=</span><span class="s2">&quot;coverage=1:coverage_direct=1&quot;</span><span class="w"> </span>./a.out
<span class="go">main</span>
<span class="gp">% </span>ls
<span class="go">7036.sancov.map  7036.sancov.raw  a.out</span>
<span class="gp">% </span>sancov.py<span class="w"> </span>rawunpack<span class="w"> </span><span class="m">7036</span>.sancov.raw
<span class="go">sancov.py: reading map 7036.sancov.map</span>
<span class="go">sancov.py: unpacking 7036.sancov.raw</span>
<span class="go">writing 1 PCs to a.out.7036.sancov</span>
<span class="gp">% </span>sancov.py<span class="w"> </span>print<span class="w"> </span>a.out.7036.sancov
<span class="go">sancov.py: read 1 PCs from a.out.7036.sancov</span>
<span class="go">sancov.py: 1 files merged; 1 PCs total</span>
<span class="go">0x4b2bae</span>
</pre></div>
</div>
<p>Note that on 64-bit platforms, this method writes 2x more data than the default,
because it stores full PC values instead of 32-bit offsets.</p>
</section>
<section id="in-process-fuzzing">
<h2><a class="toc-backref" href="#id17" role="doc-backlink">In-process fuzzing</a><a class="headerlink" href="#in-process-fuzzing" title="Lien vers cette rubrique">¶</a></h2>
<p>Coverage data could be useful for fuzzers and sometimes it is preferable to run
a fuzzer in the same process as the code being fuzzed (in-process fuzzer).</p>
<p>You can use <code class="docutils literal notranslate"><span class="pre">__sanitizer_get_total_unique_coverage()</span></code> from
<code class="docutils literal notranslate"><span class="pre">&lt;sanitizer/coverage_interface.h&gt;</span></code> which returns the number of currently
covered entities in the program. This will tell the fuzzer if the coverage has
increased after testing every new input.</p>
<p>If a fuzzer finds a bug in the ASan run, you will need to save the reproducer
before exiting the process.  Use <code class="docutils literal notranslate"><span class="pre">__asan_set_death_callback</span></code> from
<code class="docutils literal notranslate"><span class="pre">&lt;sanitizer/asan_interface.h&gt;</span></code> to do that.</p>
<p>An example of such fuzzer can be found in <a class="reference external" href="http://llvm.org/viewvc/llvm-project/llvm/trunk/lib/Fuzzer/README.txt?view=markup">the LLVM tree</a>.</p>
</section>
<section id="performance">
<h2><a class="toc-backref" href="#id18" role="doc-backlink">Performance</a><a class="headerlink" href="#performance" title="Lien vers cette rubrique">¶</a></h2>
<p>This coverage implementation is <strong>fast</strong>. With function-level coverage
(<code class="docutils literal notranslate"><span class="pre">-fsanitize-coverage=func</span></code>) the overhead is not measurable. With
basic-block-level coverage (<code class="docutils literal notranslate"><span class="pre">-fsanitize-coverage=bb</span></code>) the overhead varies
between 0 and 25%.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>benchmark</p></th>
<th class="head"><p>cov0</p></th>
<th class="head"><p>cov1</p></th>
<th class="head"><p>diff 0-1</p></th>
<th class="head"><p>cov2</p></th>
<th class="head"><p>diff 0-2</p></th>
<th class="head"><p>diff 1-2</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>400.perlbench</p></td>
<td><p>1296.00</p></td>
<td><p>1307.00</p></td>
<td><p>1.01</p></td>
<td><p>1465.00</p></td>
<td><p>1.13</p></td>
<td><p>1.12</p></td>
</tr>
<tr class="row-odd"><td><p>401.bzip2</p></td>
<td><p>858.00</p></td>
<td><p>854.00</p></td>
<td><p>1.00</p></td>
<td><p>1010.00</p></td>
<td><p>1.18</p></td>
<td><p>1.18</p></td>
</tr>
<tr class="row-even"><td><p>403.gcc</p></td>
<td><p>613.00</p></td>
<td><p>617.00</p></td>
<td><p>1.01</p></td>
<td><p>683.00</p></td>
<td><p>1.11</p></td>
<td><p>1.11</p></td>
</tr>
<tr class="row-odd"><td><p>429.mcf</p></td>
<td><p>605.00</p></td>
<td><p>582.00</p></td>
<td><p>0.96</p></td>
<td><p>610.00</p></td>
<td><p>1.01</p></td>
<td><p>1.05</p></td>
</tr>
<tr class="row-even"><td><p>445.gobmk</p></td>
<td><p>896.00</p></td>
<td><p>880.00</p></td>
<td><p>0.98</p></td>
<td><p>1050.00</p></td>
<td><p>1.17</p></td>
<td><p>1.19</p></td>
</tr>
<tr class="row-odd"><td><p>456.hmmer</p></td>
<td><p>892.00</p></td>
<td><p>892.00</p></td>
<td><p>1.00</p></td>
<td><p>918.00</p></td>
<td><p>1.03</p></td>
<td><p>1.03</p></td>
</tr>
<tr class="row-even"><td><p>458.sjeng</p></td>
<td><p>995.00</p></td>
<td><p>1009.00</p></td>
<td><p>1.01</p></td>
<td><p>1217.00</p></td>
<td><p>1.22</p></td>
<td><p>1.21</p></td>
</tr>
<tr class="row-odd"><td><p>462.libquantum</p></td>
<td><p>497.00</p></td>
<td><p>492.00</p></td>
<td><p>0.99</p></td>
<td><p>534.00</p></td>
<td><p>1.07</p></td>
<td><p>1.09</p></td>
</tr>
<tr class="row-even"><td><p>464.h264ref</p></td>
<td><p>1461.00</p></td>
<td><p>1467.00</p></td>
<td><p>1.00</p></td>
<td><p>1543.00</p></td>
<td><p>1.06</p></td>
<td><p>1.05</p></td>
</tr>
<tr class="row-odd"><td><p>471.omnetpp</p></td>
<td><p>575.00</p></td>
<td><p>590.00</p></td>
<td><p>1.03</p></td>
<td><p>660.00</p></td>
<td><p>1.15</p></td>
<td><p>1.12</p></td>
</tr>
<tr class="row-even"><td><p>473.astar</p></td>
<td><p>658.00</p></td>
<td><p>652.00</p></td>
<td><p>0.99</p></td>
<td><p>715.00</p></td>
<td><p>1.09</p></td>
<td><p>1.10</p></td>
</tr>
<tr class="row-odd"><td><p>483.xalancbmk</p></td>
<td><p>471.00</p></td>
<td><p>491.00</p></td>
<td><p>1.04</p></td>
<td><p>582.00</p></td>
<td><p>1.24</p></td>
<td><p>1.19</p></td>
</tr>
<tr class="row-even"><td><p>433.milc</p></td>
<td><p>616.00</p></td>
<td><p>627.00</p></td>
<td><p>1.02</p></td>
<td><p>627.00</p></td>
<td><p>1.02</p></td>
<td><p>1.00</p></td>
</tr>
<tr class="row-odd"><td><p>444.namd</p></td>
<td><p>602.00</p></td>
<td><p>601.00</p></td>
<td><p>1.00</p></td>
<td><p>654.00</p></td>
<td><p>1.09</p></td>
<td><p>1.09</p></td>
</tr>
<tr class="row-even"><td><p>447.dealII</p></td>
<td><p>630.00</p></td>
<td><p>634.00</p></td>
<td><p>1.01</p></td>
<td><p>653.00</p></td>
<td><p>1.04</p></td>
<td><p>1.03</p></td>
</tr>
<tr class="row-odd"><td><p>450.soplex</p></td>
<td><p>365.00</p></td>
<td><p>368.00</p></td>
<td><p>1.01</p></td>
<td><p>395.00</p></td>
<td><p>1.08</p></td>
<td><p>1.07</p></td>
</tr>
<tr class="row-even"><td><p>453.povray</p></td>
<td><p>427.00</p></td>
<td><p>434.00</p></td>
<td><p>1.02</p></td>
<td><p>495.00</p></td>
<td><p>1.16</p></td>
<td><p>1.14</p></td>
</tr>
<tr class="row-odd"><td><p>470.lbm</p></td>
<td><p>357.00</p></td>
<td><p>375.00</p></td>
<td><p>1.05</p></td>
<td><p>370.00</p></td>
<td><p>1.04</p></td>
<td><p>0.99</p></td>
</tr>
<tr class="row-even"><td><p>482.sphinx3</p></td>
<td><p>927.00</p></td>
<td><p>928.00</p></td>
<td><p>1.00</p></td>
<td><p>1000.00</p></td>
<td><p>1.08</p></td>
<td><p>1.08</p></td>
</tr>
</tbody>
</table>
</section>
<section id="why-another-coverage">
<h2><a class="toc-backref" href="#id19" role="doc-backlink">Why another coverage?</a><a class="headerlink" href="#why-another-coverage" title="Lien vers cette rubrique">¶</a></h2>
<dl class="simple">
<dt>Why did we implement yet another code coverage?</dt><dd><ul class="simple">
<li><p>We needed something that is lightning fast, plays well with
AddressSanitizer, and does not significantly increase the binary size.</p></li>
<li><p>Traditional coverage implementations based in global counters
<a class="reference external" href="https://groups.google.com/forum/#!topic/llvm-dev/cDqYgnxNEhY">suffer from contention on counters</a>.</p></li>
</ul>
</dd>
</dl>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="Bottom">
      
        <p>
        «&#160;&#160;<a href="LeakSanitizer.html">LeakSanitizer</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contenu</a>
        &#160;&#160;::&#160;&#160;
        <a href="SanitizerStats.html">SanitizerStats</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
    &#169; Copyright 2007-2026, The Clang Team.
      Créé en utilisant <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3.
    </div>
  </body>
</html>