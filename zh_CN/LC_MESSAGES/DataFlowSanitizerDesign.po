# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2025, The Clang Team
# This file is distributed under the same license as the Clang package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Clang 9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-13 13:42+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../DataFlowSanitizerDesign.rst:2
msgid "DataFlowSanitizer Design Document"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:4
msgid ""
"This document sets out the design for DataFlowSanitizer, a general dynamic "
"data flow analysis.  Unlike other Sanitizer tools, this tool is not designed "
"to detect a specific class of bugs on its own. Instead, it provides a "
"generic dynamic data flow analysis framework to be used by clients to help "
"detect application-specific issues within their own code."
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:11
msgid ""
"DataFlowSanitizer is a program instrumentation which can associate a number "
"of taint labels with any data stored in any memory region accessible by the "
"program. The analysis is dynamic, which means that it operates on a running "
"program, and tracks how the labels propagate through that program. The tool "
"shall support a large (>100) number of labels, such that programs which "
"operate on large numbers of data items may be analysed with each data item "
"being tracked separately."
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:20
msgid "Use Cases"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:22
msgid ""
"This instrumentation can be used as a tool to help monitor how data flows "
"from a program's inputs (sources) to its outputs (sinks). This has "
"applications from a privacy/security perspective in that one can audit how a "
"sensitive data item is used within a program and ensure it isn't exiting the "
"program anywhere it shouldn't be."
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:29
msgid "Interface"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:31
msgid ""
"A number of functions are provided which will create taint labels, attach "
"labels to memory regions and extract the set of labels associated with a "
"specific memory region. These functions are declared in the header file "
"``sanitizer/dfsan_interface.h``."
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:67
msgid "Taint label representation"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:69
msgid ""
"As stated above, the tool must track a large number of taint labels. This "
"poses an implementation challenge, as most multiple-label tainting systems "
"assign one label per bit to shadow storage, and union taint labels using a "
"bitwise or operation. This will not scale to clients which use hundreds or "
"thousands of taint labels, as the label union operation becomes O(n) in the "
"number of supported labels, and data associated with it will quickly "
"dominate the live variable set, causing register spills and hampering "
"performance."
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:78
msgid ""
"Instead, a low overhead approach is proposed which is best-case O(log\\ :sub:"
"`2` n) during execution. The underlying assumption is that the required "
"space of label unions is sparse, which is a reasonable assumption to make "
"given that we are optimizing for the case where applications mostly copy "
"data from one place to another, without often invoking the need for an "
"actual union operation. The representation of a taint label is a 16-bit "
"integer, and new labels are allocated sequentially from a pool. The label "
"identifier 0 is special, and means that the data item is unlabelled."
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:88
msgid ""
"When a label union operation is requested at a join point (any arithmetic or "
"logical operation with two or more operands, such as addition), the code "
"checks whether a union is required, whether the same union has been "
"requested before, and whether one union label subsumes the other. If so, it "
"returns the previously allocated union label. If not, it allocates a new "
"union label from the same pool used for new labels."
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:96
msgid ""
"Specifically, the instrumentation pass will insert code like this to decide "
"the union label ``lu`` for a pair of labels ``l1`` and ``l2``:"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:107
msgid ""
"The equality comparison is outlined, to provide an early exit in the common "
"cases where the program is processing unlabelled data, or where the two data "
"items have the same label.  ``__dfsan_union`` is a runtime library function "
"which performs all other union computation."
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:112
msgid ""
"Further optimizations are possible, for example if ``l1`` is known at "
"compile time to be zero (e.g. it is derived from a constant), ``l2`` can be "
"used for ``lu``, and vice versa."
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:117
msgid "Memory layout and label management"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:119
msgid "The following is the current memory layout for Linux/x86\\_64:"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:122
msgid "Start"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:122
msgid "End"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:122
msgid "Use"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:124
#: ../../../DataFlowSanitizerDesign.rst:126
msgid "0x700000008000"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:124
msgid "0x800000000000"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:124
msgid "application memory"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:126
#: ../../../DataFlowSanitizerDesign.rst:128
msgid "0x200200000000"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:126
msgid "unused"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:128
#: ../../../DataFlowSanitizerDesign.rst:130
msgid "0x200000000000"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:128
msgid "union table"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:130
#: ../../../DataFlowSanitizerDesign.rst:132
msgid "0x000000010000"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:130
msgid "shadow memory"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:132
msgid "0x000000000000"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:132
msgid "reserved by kernel"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:135
msgid ""
"Each byte of application memory corresponds to two bytes of shadow memory, "
"which are used to store its taint label. As for LLVM SSA registers, we have "
"not found it necessary to associate a label with each byte or bit of data, "
"as some other tools do. Instead, labels are associated directly with "
"registers.  Loads will result in a union of all shadow labels corresponding "
"to bytes loaded (which most of the time will be short circuited by the "
"initial comparison) and stores will result in a copy of the label to the "
"shadow of all bytes stored to."
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:145
msgid "Propagating labels through arguments"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:147
msgid ""
"In order to propagate labels through function arguments and return values, "
"DataFlowSanitizer changes the ABI of each function in the translation unit. "
"There are currently two supported ABIs:"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:151
msgid ""
"Args -- Argument and return value labels are passed through additional "
"arguments and by modifying the return type."
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:154
msgid ""
"TLS -- Argument and return value labels are passed through TLS variables "
"``__dfsan_arg_tls`` and ``__dfsan_retval_tls``."
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:157
msgid ""
"The main advantage of the TLS ABI is that it is more tolerant of ABI "
"mismatches (TLS storage is not shared with any other form of storage, "
"whereas extra arguments may be stored in registers which under the native "
"ABI are not used for parameter passing and thus could contain arbitrary "
"values).  On the other hand the args ABI is more efficient and allows ABI "
"mismatches to be more easily identified by checking for nonzero labels in "
"nominally unlabelled programs."
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:165
msgid "Implementing the ABI list"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:167
msgid ""
"The `ABI list <DataFlowSanitizer.html#abi-list>`_ provides a list of "
"functions which conform to the native ABI, each of which is callable from an "
"instrumented program.  This is implemented by replacing each reference to a "
"native ABI function with a reference to a function which uses the "
"instrumented ABI. Such functions are automatically-generated wrappers for "
"the native functions. For example, given the ABI list example provided in "
"the user manual, the following wrappers will be generated under the args ABI:"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:203
msgid ""
"As an optimization, direct calls to native ABI functions will call the "
"native ABI function directly and the pass will compute the appropriate label "
"internally.  This has the advantage of reducing the number of union "
"operations required when the return value label is known to be zero (i.e. "
"``discard`` functions, or ``functional`` functions with known unlabelled "
"arguments)."
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:210
msgid "Checking ABI Consistency"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:212
msgid ""
"DFSan changes the ABI of each function in the module.  This makes it "
"possible for a function with the native ABI to be called with the "
"instrumented ABI, or vice versa, thus possibly invoking undefined behavior.  "
"A simple way of statically detecting instances of this problem is to prepend "
"the prefix \"dfs$\" to the name of each instrumented-ABI function."
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:218
msgid ""
"This will not catch every such problem; in particular function pointers "
"passed across the instrumented-native barrier cannot be used on the other "
"side. These problems could potentially be caught dynamically."
msgstr ""
