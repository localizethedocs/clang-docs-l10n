# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2025, The Clang Team
# This file is distributed under the same license as the Clang package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Clang 20\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-13 13:41+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../FunctionEffectAnalysis.rst:3
msgid "Function Effect Analysis"
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:11
msgid "Introduction"
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:13
msgid ""
"Clang Function Effect Analysis is a language extension which can warn about "
"\"unsafe\" constructs. The feature is currently tailored for the Performance "
"Constraint attributes ``nonblocking`` and ``nonallocating``; functions with "
"these attributes are verified as not containing any language constructs or "
"calls to other functions which violate the constraint. (See :doc:"
"`AttributeReference`.)"
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:21
msgid "The ``nonblocking`` and ``nonallocating`` attributes"
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:24
msgid "Attribute syntax"
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:26
msgid ""
"The ``nonblocking`` and ``nonallocating`` attributes apply to function "
"types, allowing them to be attached to functions, blocks, function pointers, "
"lambdas, and member functions."
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:54
msgid ""
"The attribute applies only to the function itself. In particular, it does "
"not apply to any nested functions or declarations, such as blocks, lambdas, "
"and local classes."
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:57
msgid ""
"This document uses the C++/C23 syntax ``[[clang::nonblocking]]``, since it "
"parallels the placement of the ``noexcept`` specifier, and the attributes "
"have other similarities to ``noexcept``. The GNU "
"``__attribute__((nonblocking))`` syntax is also supported. Note that it "
"requires a different placement on a C++ type alias."
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:62
msgid ""
"Like ``noexcept``, ``nonblocking`` and ``nonallocating`` have an optional "
"argument, a compile-time constant boolean expression. By default, the "
"argument is ``true``, so ``[[clang::nonblocking]]`` is equivalent to "
"``[[clang::nonblocking(true)]]``, and declares the function type as never "
"blocking."
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:68
msgid "Attribute semantics"
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:70
msgid ""
"Together with ``noexcept``, the ``nonallocating`` and ``nonblocking`` "
"attributes define an ordered series of performance constraints. From weakest "
"to strongest:"
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:73
msgid ""
"``noexcept`` (as per the C++ standard): The function type will never throw "
"an exception."
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:74
msgid ""
"``nonallocating``: The function type will never allocate memory on the heap "
"or throw an exception."
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:76
msgid ""
"``nonblocking``: The function type will never block on a lock, allocate "
"memory on the heap, or throw an exception."
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:79
msgid "``nonblocking`` includes the ``nonallocating`` guarantee."
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:81
msgid ""
"While ``nonblocking`` and ``nonallocating`` are conceptually a superset of "
"``noexcept``, neither attribute implicitly specifies ``noexcept``. Further, "
"``noexcept`` has a specified runtime behavior of aborting if an exception is "
"thrown, while the ``nonallocating`` and ``nonblocking`` attributes are "
"mainly for compile-time analysis and have no runtime behavior, except in "
"code built with Clang's :doc:`RealtimeSanitizer`. Nonetheless, Clang emits a "
"warning if, in C++, a function is declared ``nonblocking`` or "
"``nonallocating`` without ``noexcept``. This diagnostic is controlled by ``-"
"Wperf-constraint-implies-noexcept``."
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:89
msgid ""
"``nonblocking(true)`` and ``nonallocating(true)`` apply to function *types*, "
"and by extension, to function-like declarations. When applied to a "
"declaration with a body, the compiler verifies the function, as described in "
"the section \"Analysis and warnings\", below."
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:93
msgid ""
"``blocking`` and ``allocating`` are synonyms for ``nonblocking(false)`` and "
"``nonallocating(false)``, respectively. They can be used on a function-like "
"declaration to explicitly disable any potential inference of ``nonblocking`` "
"or ``nonallocating`` during verification. (Inference is described later in "
"this document). ``nonblocking(false)`` and ``nonallocating(false)`` are "
"legal, but superfluous  when applied to a function *type* that is not part "
"of a declarator: ``float (int) [[nonblocking(false)]]`` and ``float (int)`` "
"are identical types."
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:101
msgid ""
"For functions with no explicit performance constraint, the worst is assumed: "
"the function allocates memory and potentially blocks, unless it can be "
"inferred otherwise. This is detailed in the discussion of verification."
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:105
msgid ""
"The following example describes the meanings of all permutations of the two "
"attributes and arguments:"
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:123
msgid "Type conversions"
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:125
msgid ""
"A performance constraint can be removed or weakened via an implicit "
"conversion. An attempt to add or strengthen a performance constraint is "
"unsafe and results in a warning. The rules for this are comparable to that "
"for ``noexcept`` in C++17 and later."
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:162
msgid "Virtual methods"
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:164
msgid ""
"In C++, when a virtual method has a performance constraint, overriding "
"methods in subclasses inherit the constraint."
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:183
msgid "Redeclarations, overloads, and name mangling"
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:185
msgid ""
"The ``nonblocking`` and ``nonallocating`` attributes, like ``noexcept``, do "
"not factor into argument-dependent lookup and overloaded functions/methods."
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:188
msgid "First, consider that ``noexcept`` is integral to a function's type:"
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:197
msgid ""
"Unlike ``noexcept``, a redeclaration of ``f2`` with an added or stronger "
"performance constraint is legal and propagates the attribute to the previous "
"declaration:"
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:205
msgid ""
"This greatly eases adoption by making it possible to annotate functions in "
"external libraries without modifying library headers."
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:208
msgid ""
"A redeclaration with a removed or weaker performance constraint produces a "
"warning, paralleling the behavior of ``noexcept``:"
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:216
msgid ""
"In C++14, the following two declarations of `f3` are identical (a single "
"function). In C++17 they are separate overloads:"
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:224
msgid ""
"Similarly, the following two declarations of `f4` are separate overloads. "
"This pattern may pose difficulties due to ambiguity:"
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:232
msgid ""
"The attributes have no effect on the mangling of function and method names."
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:235
msgid "Objective-C"
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:237
msgid "The attributes are currently unsupported on Objective-C methods."
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:240
msgid "Analysis and warnings"
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:243
msgid "Constraints"
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:245
msgid ""
"Functions declared ``nonallocating`` or ``nonblocking``, when defined, are "
"verified according to the following rules. Such functions:"
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:248
msgid ""
"May not allocate or deallocate memory on the heap. The analysis follows the "
"calls to ``operator new`` and ``operator delete`` generated by the ``new`` "
"and ``delete`` keywords, and treats them like any other function call. The "
"global ``operator new`` and ``operator delete`` aren't declared "
"``nonblocking`` or ``nonallocating`` and so they are considered unsafe. "
"(This is correct because most memory allocators are not lock-free. Note that "
"the placement form of ``operator new`` is implemented inline in libc++'s "
"``<new>`` header, and is verifiably ``nonblocking``, since it merely casts "
"the supplied pointer to the result type.)"
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:256
msgid ""
"May not throw or catch exceptions. To throw, the compiler must allocate the "
"exception on the heap. (Also, many subclasses of ``std::exception`` allocate "
"a string). Exceptions are deallocated when caught."
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:260
msgid ""
"May not make any indirect function call, via a virtual method, function "
"pointer, or pointer-to-member function, unless the target is explicitly "
"declared with the same ``nonblocking`` or ``nonallocating`` attribute (or "
"stronger)."
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:264
msgid ""
"May not make direct calls to any other function, with the following "
"exceptions:"
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:266
msgid ""
"The callee is also explicitly declared with the same ``nonblocking`` or "
"``nonallocating`` attribute (or stronger)."
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:268
msgid ""
"The callee is defined in the same translation unit as the caller, does not "
"have the ``false`` form of the required attribute, and can be verified to "
"have the same attribute or stronger, according to these same rules."
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:271
msgid ""
"The callee is a built-in function that is known not to block or allocate."
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:272
msgid ""
"The callee is declared ``noreturn`` and, if compiling C++, the callee is "
"also declared ``noexcept``. This special case excludes functions such as "
"``abort()`` and ``std::terminate()`` from the analysis. (The reason for "
"requiring ``noexcept`` in C++ is that a function declared ``noreturn`` could "
"be a wrapper for ``throw``.)"
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:277
msgid ""
"May not invoke or access an Objective-C method or property, since "
"``objc_msgSend()`` calls into the Objective-C runtime, which may allocate "
"memory or otherwise block."
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:280
msgid ""
"May not access thread-local variables. Typically, thread-local variables are "
"allocated on the heap when first accessed."
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:283
msgid "Functions declared ``nonblocking`` have an additional constraint:"
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:285
msgid ""
"May not declare static local variables (e.g. Meyers singletons). The "
"compiler generates a lock protecting the initialization of the variable."
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:288
msgid ""
"Violations of any of these rules result in warnings, in the ``-Wfunction-"
"effects`` category:"
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:315
msgid "Inferring ``nonblocking`` or ``nonallocating``"
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:317
msgid ""
"In the absence of a ``nonblocking`` or ``nonallocating`` attribute (whether "
"``true`` or ``false``), a function that is called from a performance-"
"constrained function may be analyzed to infer whether it has a desired "
"attribute. This analysis happens when the function is not a virtual method, "
"and it has a visible definition within the current translation unit (i.e. "
"its body can be traversed)."
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:342
msgid "Lambdas and blocks"
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:344
msgid ""
"As mentioned earlier, the performance constraint attributes apply only to a "
"single function and not to any code nested inside it, including blocks, "
"lambdas, and local classes. It is possible for a nonblocking function to "
"schedule the execution of a blocking lambda on another thread. Similarly, a "
"blocking function may create a ``nonblocking`` lambda for use in a realtime "
"context."
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:349
msgid ""
"Operations which create, destroy, copy, and move lambdas and blocks are "
"analyzed in terms of the underlying function calls. For example, the "
"creation of a lambda with captures generates a function call to an anonymous "
"struct's constructor, passing the captures as parameters."
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:354
msgid "Implicit function calls in the AST"
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:356
msgid ""
"The ``nonblocking`` / ``nonallocating`` analysis occurs at the Sema phase of "
"analysis in Clang. During Sema, there are some constructs which will "
"eventually become function calls, but do not appear as function calls in the "
"AST. For example, ``auto* foo = new Foo;`` becomes a declaration containing "
"a ``CXXNewExpr`` which is understood as a function call to the global "
"``operator new`` (in this example), and a ``CXXConstructExpr``, which, for "
"analysis purposes, is a function call to ``Foo``'s constructor. Most gaps in "
"the analysis would be due to incomplete knowledge of AST constructs which "
"become function calls."
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:365
msgid "Disabling diagnostics"
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:367
msgid "Function effect diagnostics are controlled by ``-Wfunction-effects``."
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:369
msgid ""
"A construct like this can be used to exempt code from the checks described "
"here:"
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:380
msgid "Disabling the diagnostic allows for:"
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:382
msgid ""
"constructs which do block, but which in practice are used in ways to avoid "
"unbounded blocking, e.g. a thread pool with semaphores to coordinate "
"multiple realtime threads;"
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:384
msgid "using libraries which are safe but not yet annotated;"
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:385
msgid "incremental adoption in a large codebase."
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:388
msgid "Adoption"
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:390
msgid ""
"There are a few common issues that arise when adopting the ``nonblocking`` "
"and ``nonallocating`` attributes."
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:394
msgid "C++ exceptions"
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:396
msgid ""
"Exceptions pose a challenge to the adoption of the performance constraints. "
"Common library functions which throw exceptions include:"
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:400
msgid "Method"
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:400
msgid "Alternative"
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:402
msgid "``std::vector<T>::at()``"
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:402
msgid "``operator[](size_t)``, after verifying that the index is in range."
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:404
msgid "``std::optional<T>::value()``"
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:404
msgid "``operator*``, after checking ``has_value()`` or ``operator bool()``."
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:406
msgid "``std::expected<T, E>::value()``"
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:406
msgid "Same as for ``std::optional<T>::value()``."
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:411
msgid "``std::function<R(Args...)>``"
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:413
msgid ""
"``std::function<R(Args...)>`` is generally incompatible with ``nonblocking`` "
"and ``nonallocating`` code, because a typical implementation may allocate "
"heap memory in the constructor."
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:416
msgid "Alternatives:"
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:418
msgid ""
"``std::function_ref`` (available in C++26 or as ``llvm::function_ref``). "
"This is appropriate and optimal when a functor's lifetime does not need to "
"extend past the function that created it."
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:421
msgid ""
"``inplace_function`` from WG14. This solves the allocation problem by giving "
"the functor wrapper a fixed size known at compile time and using an inline "
"buffer."
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:424
msgid ""
"While these alternatives both address the heap allocation of ``std::"
"function``, they are still obstacles to ``nonblocking/nonallocating`` "
"verification, for reasons detailed in the next section."
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:429
msgid "Interactions with type-erasure techniques"
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:431
msgid ""
"``std::function<R(Args...)>`` illustrates a common C++ type-erasure "
"technique. Using template argument deduction, it decomposes a function type "
"into its return and parameter types. Additional components of the function "
"type, including ``noexcept``, ``nonblocking``, ``nonallocating``, and any "
"other attributes, are discarded."
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:436
msgid ""
"Standard library support for these components of a function type is not "
"immediately forthcoming."
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:438
msgid "Code can work around this limitation in either of two ways:"
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:440
msgid ""
"Avoid abstractions like ``std::function`` and instead work directly with the "
"original lambda type."
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:442
msgid ""
"Create a specialized alternative, e.g. "
"``nonblocking_function_ref<R(Args...)>`` where all function pointers used in "
"the implementation and its interface are ``nonblocking``."
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:445
msgid ""
"As an example of the first approach, when using a lambda as a *Callable* "
"template parameter, the attribute is preserved:"
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:453
msgid ""
"Here, the type of the ``Compare`` template parameter is an anonymous class "
"generated from the lambda, with an ``operator()`` method holding the "
"``nonblocking`` attribute."
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:456
msgid ""
"A complication arises when a *Callable* template parameter, instead of being "
"a lambda or class implementing ``operator()``, is a function pointer:"
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:466
msgid ""
"Here, the type of ``compare_elems`` is decomposed to ``bool(const Elem&, "
"const Elem&)``, without ``nonblocking``, when forming the template "
"parameter. This can be solved using the second approach, creating a "
"specialized alternative which explicitly requires the attribute. In this "
"case, it's possible to use a small wrapper to transform the function pointer "
"into a functor:"
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:502
msgid ""
"Now, the ``nonblocking`` attribute of ``compare_elems`` is verified when it "
"is converted to a ``nonblocking`` function pointer, as the argument to "
"``nonblocking_fp``'s constructor. The template parameter is the functor "
"class ``nonblocking_fp``."
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:508
msgid "Static local variables"
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:510
msgid ""
"Static local variables are often used for lazily-constructed globals (Meyers "
"singletons). Beyond the compiler's use of a lock to ensure thread-safe "
"initialization, it is dangerously easy to inadvertently trigger "
"initialization, involving heap allocation, from a ``nonblocking`` or "
"``nonallocating`` context."
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:515
msgid ""
"Generally, such singletons need to be replaced by globals, and care must be "
"taken to ensure their initialization before they are used from "
"``nonblocking`` or ``nonallocating`` contexts."
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:520
msgid "Annotating libraries"
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:522
msgid ""
"It can be surprising that the analysis does not depend on knowledge of any "
"primitives; it simply assumes the worst, that all function calls are unsafe "
"unless explicitly marked as safe or able to be inferred as safe. With "
"``nonblocking``, this appears to suffice for all but the most primitive of "
"spinlocks."
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:527
msgid ""
"At least for an operating system's C functions, it is possible to define an "
"override header which redeclares safe common functions (e.g. "
"``pthread_self()``) with the addition of ``nonblocking``. This may help in "
"adopting the feature incrementally."
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:531
msgid ""
"It also helps that many of the functions in the standard C libraries "
"(notably ``<math.h>``) are treated as built-in functions by Clang, which the "
"diagnosis understands to be safe."
msgstr ""

#: ../../../FunctionEffectAnalysis.rst:534
msgid ""
"Much of the C++ standard library consists of inline templated functions "
"which work well with inference. A small number of primitives may need "
"explicit ``nonblocking/nonallocating`` attributes."
msgstr ""
