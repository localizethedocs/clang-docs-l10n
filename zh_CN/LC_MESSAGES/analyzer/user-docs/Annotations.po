# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2025, The Clang Team
# This file is distributed under the same license as the Clang package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Clang 21\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-13 13:42+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../analyzer/user-docs/Annotations.rst:3
msgid "Source Annotations"
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:5
msgid ""
"The Clang frontend supports several source-level annotations in the form of "
"`GCC-style attributes <https://gcc.gnu.org/onlinedocs/gcc/Attribute-Syntax."
"html>`_ and pragmas that can help make using the Clang Static Analyzer more "
"useful. These annotations can both help suppress false positives as well as "
"enhance the analyzer's ability to find bugs."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:11
msgid ""
"This page gives a practical overview of such annotations. For more technical "
"specifics regarding Clang-specific annotations please see the Clang's list "
"of `language extensions <https://clang.llvm.org/docs/LanguageExtensions."
"html>`_. Details of \"standard\" GCC attributes (that Clang also supports) "
"can be found in the `GCC manual <https://gcc.gnu.org/onlinedocs/gcc/>`_, "
"with the majority of the relevant attributes being in the section on "
"`function attributes <https://gcc.gnu.org/onlinedocs/gcc/Function-Attributes."
"html>`_."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:19
msgid ""
"Note that attributes that are labeled **Clang-specific** are not recognized "
"by GCC. Their use can be conditioned using preprocessor macros (examples "
"included on this page)."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:27
msgid "General Purpose Annotations"
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:30
msgid "Null Pointer Checking"
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:33
msgid "Attribute 'nonnull'"
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:35
msgid ""
"The analyzer recognizes the GCC attribute 'nonnull', which indicates that a "
"function expects that a given function parameter is not a null pointer. "
"Specific details of the syntax of using the 'nonnull' attribute can be found "
"in `GCC's documentation <https://gcc.gnu.org/onlinedocs/gcc/Common-Function-"
"Attributes.html#index-nonnull-function-attribute>`_."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:40
msgid ""
"Both the Clang compiler and GCC will flag warnings for simple cases where a "
"null pointer is directly being passed to a function with a 'nonnull' "
"parameter (e.g., as a constant). The analyzer extends this checking by using "
"its deeper symbolic analysis to track what pointer values are potentially "
"null and then flag warnings when they are passed in a function call via a "
"'nonnull' parameter."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:47
#: ../../../analyzer/user-docs/Annotations.rst:129
#: ../../../analyzer/user-docs/Annotations.rst:152
#: ../../../analyzer/user-docs/Annotations.rst:245
#: ../../../analyzer/user-docs/Annotations.rst:345
#: ../../../analyzer/user-docs/Annotations.rst:434
#: ../../../analyzer/user-docs/Annotations.rst:486
#: ../../../analyzer/user-docs/Annotations.rst:538
#: ../../../analyzer/user-docs/Annotations.rst:628
msgid "**Example**"
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:58
msgid "Running ``scan-build`` over this source produces the following output:"
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:65
msgid "Custom Assertion Handlers"
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:67
msgid ""
"The analyzer exploits code assertions by pruning off paths where the "
"assertion condition is false. The idea is capture any program invariants "
"specified in the assertion that the developer may know but is not "
"immediately apparent in the code itself. In this way assertions make "
"implicit assumptions explicit in the code, which not only makes the analyzer "
"more accurate when finding bugs, but can help others better able to "
"understand your code as well. It can also help remove certain kinds of "
"analyzer false positives by pruning off false paths."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:76
msgid ""
"In order to exploit assertions, however, the analyzer must understand when "
"it encounters an \"assertion handler\". Typically assertions are implemented "
"with a macro, with the macro performing a check for the assertion condition "
"and, when the check fails, calling an assertion handler.  For example, "
"consider the following code fragment:"
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:88
msgid "When this code is preprocessed on Mac OS X it expands to the following:"
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:96
msgid ""
"In this example, the assertion handler is ``__assert_rtn``. When called, "
"most assertion handlers typically print an error and terminate the program. "
"The analyzer can exploit such semantics by ending the analysis of a path "
"once it hits a call to an assertion handler."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:101
msgid ""
"The trick, however, is that the analyzer needs to know that a called "
"function is an assertion handler; otherwise the analyzer might assume the "
"function call returns and it will continue analyzing the path where the "
"assertion condition failed. This can lead to false positives, as the "
"assertion condition usually implies a safety condition (e.g., a pointer is "
"not null) prior to performing some action that depends on that condition (e."
"g., dereferencing a pointer)."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:108
msgid ""
"The analyzer knows about several well-known assertion handlers, but can "
"automatically infer if a function should be treated as an assertion handler "
"if it is annotated with the 'noreturn' attribute or the (Clang-specific) "
"'analyzer_noreturn' attribute. Note that, currently, clang does not support "
"these attributes on Objective-C methods and C++ methods."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:115
msgid "Attribute 'noreturn'"
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:117
msgid ""
"The 'noreturn' attribute is a GCC attribute that can be placed on the "
"declarations of functions. It means exactly what its name implies: a "
"function with a 'noreturn' attribute should never return."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:121
msgid ""
"Specific details of the syntax of using the 'noreturn' attribute can be "
"found in `GCC's documentation <https://gcc.gnu.org/onlinedocs/gcc/Common-"
"Function-Attributes.html#index-noreturn-function-attribute>`__."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:124
msgid ""
"Not only does the analyzer exploit this information when pruning false "
"paths, but the compiler also takes it seriously and will generate different "
"code (and possibly better optimized) under the assumption that the function "
"does not return."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:131
msgid ""
"On Mac OS X, the function prototype for ``__assert_rtn`` (declared in "
"``assert.h``) is specifically annotated with the 'noreturn' attribute:"
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:139
msgid "Attribute 'analyzer_noreturn' (Clang-specific)"
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:141
msgid ""
"The Clang-specific 'analyzer_noreturn' attribute is almost identical to "
"'noreturn' except that it is ignored by the compiler for the purposes of "
"code generation."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:145
msgid ""
"This attribute is useful for annotating assertion handlers that actually "
"*can* return, but for the purpose of using the analyzer we want to pretend "
"that such functions do not return."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:149
msgid ""
"Because this attribute is Clang-specific, its use should be conditioned with "
"the use of preprocessor macros."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:167
msgid "Dynamic Memory Modeling Annotations"
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:169
msgid ""
"If a project uses custom functions for dynamic memory management (that e.g. "
"act as wrappers around ``malloc``/``free`` or ``new``/``delete`` in C++) and "
"the analyzer cannot \"see\" the _definitions_ of these functions, it's "
"possible to annotate their declarations to let the analyzer model their "
"behavior. (Otherwise the analyzer cannot know that the opaque ``my_free()`` "
"is basically equivalent to a standard ``free()`` call.)"
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:172
msgid ""
"**This page only provides a brief list of these annotations.** For a full "
"documentation, see the main `Attributes in Clang <../../AttributeReference."
"html#ownership-holds-ownership-returns-ownership-takes-clang-static-"
"analyzer>`_ page."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:175
msgid "Attribute 'ownership_returns' (Clang-specific)"
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:177
msgid ""
"Use this attribute to mark functions that return dynamically allocated "
"memory. Takes a single argument, the type of the allocation (e.g. ``malloc`` "
"or ``new``)."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:184
msgid "Attribute 'ownership_takes' (Clang-specific)"
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:186
msgid ""
"Use this attribute to mark functions that deallocate memory. Takes two "
"arguments: the type of the allocation (e.g. ``malloc`` or ``new``) and the "
"index of the parameter that is being deallocated (counting from 1)."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:193
msgid "Attribute 'ownership_holds' (Clang-specific)"
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:195
msgid ""
"Use this attribute to mark functions that take ownership of memory and will "
"deallocate it at some unspecified point in the future. Takes two arguments: "
"the type of the allocation (e.g. ``malloc`` or ``new``) and the index of the "
"parameter that is being held (counting from 1)."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:201
msgid ""
"The annotations ``ownership_takes`` and ``ownership_holds`` both prevent "
"memory leak reports (concerning the specified argument); the difference "
"between them is that using taken memory is a use-after-free error, while "
"using held memory is assumed to be legitimate."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:204
msgid "Mac OS X API Annotations"
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:209
msgid "Cocoa & Core Foundation Memory Management Annotations"
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:211
msgid ""
"The analyzer supports the proper management of retain counts for both Cocoa "
"and Core Foundation objects. This checking is largely based on enforcing "
"Cocoa and Core Foundation naming conventions for Objective-C methods (Cocoa) "
"and C functions (Core Foundation). Not strictly following these conventions "
"can cause the analyzer to miss bugs or flag false positives."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:217
msgid ""
"One can educate the analyzer (and others who read your code) about methods "
"or functions that deviate from the Cocoa and Core Foundation conventions "
"using the attributes described here. However, you should consider using "
"proper naming conventions or the `objc_method_family <https://clang.llvm.org/"
"docs/LanguageExtensions.html#the-objc-method-family-attribute>`_ attribute, "
"if applicable."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:226
msgid "Attribute 'ns_returns_retained' (Clang-specific)"
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:228
msgid ""
"The GCC-style (Clang-specific) attribute 'ns_returns_retained' allows one to "
"annotate an Objective-C method or C function as returning a retained Cocoa "
"object that the caller is responsible for releasing (via sending a "
"``release`` message to the object). The Foundation framework defines a macro "
"``NS_RETURNS_RETAINED`` that is functionally equivalent to the one shown "
"below."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:235
msgid ""
"**Placing on Objective-C methods**: For Objective-C methods, this annotation "
"essentially tells the analyzer to treat the method as if its name begins "
"with \"alloc\" or \"new\" or contains the word \"copy\"."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:240
msgid ""
"**Placing on C functions**: For C functions returning Cocoa objects, the "
"analyzer typically does not make any assumptions about whether or not the "
"object is returned retained. Explicitly adding the 'ns_returns_retained' "
"attribute to C functions allows the analyzer to perform extra checking."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:277
msgid ""
"Running ``scan-build`` on this source file produces the following output:"
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:284
msgid "Attribute 'ns_returns_not_retained' (Clang-specific)"
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:286
msgid ""
"The 'ns_returns_not_retained' attribute is the complement of "
"'`ns_returns_retained`_'. Where a function or method may appear to obey the "
"Cocoa conventions and return a retained Cocoa object, this attribute can be "
"used to indicate that the object reference returned should not be considered "
"as an \"owning\" reference being returned to the caller. The Foundation "
"framework defines a macro ``NS_RETURNS_NOT_RETAINED`` that is functionally "
"equivalent to the one shown below."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:294
msgid ""
"Usage is identical to `ns_returns_retained`_.  When using the attribute, be "
"sure to declare it within the proper macro that checks for its availability, "
"as it is not available in earlier versions of the analyzer:"
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:315
msgid "Attribute 'cf_returns_retained' (Clang-specific)"
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:317
msgid ""
"The GCC-style (Clang-specific) attribute 'cf_returns_retained' allows one to "
"annotate an Objective-C method or C function as returning a retained Core "
"Foundation object that the caller is responsible for releasing. The "
"CoreFoundation framework defines a macro ``CF_RETURNS_RETAINED`` that is "
"functionally equivalent to the one shown below."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:323
msgid ""
"**Placing on Objective-C methods**: With respect to Objective-C methods., "
"this attribute is identical in its behavior and usage to "
"'ns_returns_retained' except for the distinction of returning a Core "
"Foundation object instead of a Cocoa object."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:328
msgid ""
"This distinction is important for the following reason: as Core Foundation "
"is a C API, the analyzer cannot always tell that a pointer return value "
"refers to a Core Foundation object. In contrast, it is trivial for the "
"analyzer to recognize if a pointer refers to a Cocoa object (given the "
"Objective-C type system)."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:334
msgid ""
"**Placing on C functions**: When placing the attribute 'cf_returns_retained' "
"on the declarations of C functions, the analyzer interprets the function as:"
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:338
msgid "Returning a Core Foundation Object"
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:339
msgid ""
"Treating the function as if it its name contained the keywords \"create\" or "
"\"copy\". This means the returned object as a +1 retain count that must be "
"released by the caller, either by sending a ``release`` message (via toll-"
"free bridging to an Objective-C object pointer), or calling ``CFRelease`` or "
"a similar function."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:388
msgid "Running ``scan-build`` on this example produces the following output:"
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:393
msgid "Attribute 'cf_returns_not_retained' (Clang-specific)"
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:395
msgid ""
"The 'cf_returns_not_retained' attribute is the complement of "
"'`cf_returns_retained`_'. Where a function or method may appear to obey the "
"Core Foundation or Cocoa conventions and return a retained Core Foundation "
"object, this attribute can be used to indicate that the object reference "
"returned should not be considered as an \"owning\" reference being returned "
"to the caller. The CoreFoundation framework defines a macro "
"**``CF_RETURNS_NOT_RETAINED``** that is functionally equivalent to the one "
"shown below."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:404
msgid ""
"Usage is identical to cf_returns_retained_. When using the attribute, be "
"sure to declare it within the proper macro that checks for its availability, "
"as it is not available in earlier versions of the analyzer:"
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:425
msgid "Attribute 'ns_consumed' (Clang-specific)"
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:427
msgid ""
"The 'ns_consumed' attribute can be placed on a specific parameter in either "
"the declaration of a function or an Objective-C method. It indicates to the "
"static analyzer that a ``release`` message is implicitly sent to the "
"parameter upon completion of the call to the given function or method. The "
"Foundation framework defines a macro ``NS_RELEASES_ARGUMENT`` that is "
"functionally equivalent to the ``NS_CONSUMED`` macro shown below."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:474
msgid "Attribute 'cf_consumed' (Clang-specific)"
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:476
msgid ""
"The 'cf_consumed' attribute is practically identical to ns_consumed_. The "
"attribute can be placed on a specific parameter in either the declaration of "
"a function or an Objective-C method. It indicates to the static analyzer "
"that the object reference is implicitly passed to a call to ``CFRelease`` "
"upon completion of the call to the given function or method. The "
"CoreFoundation framework defines a macro ``CF_RELEASES_ARGUMENT`` that is "
"functionally equivalent to the ``CF_CONSUMED`` macro shown below."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:484
msgid "Operationally this attribute is nearly identical to 'ns_consumed'."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:528
msgid "Attribute 'ns_consumes_self' (Clang-specific)"
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:530
msgid ""
"The 'ns_consumes_self' attribute can be placed only on an Objective-C method "
"declaration. It indicates that the receiver of the message is "
"\"consumed\" (a single reference count decremented) after the message is "
"sent. This matches the semantics of all \"init\" methods."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:535
msgid ""
"One use of this attribute is declare your own init-like methods that do not "
"follow the standard Cocoa naming conventions."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:558
msgid ""
"In this example, ``-nonstandardInitWith:`` has the same ownership semantics "
"as the init method ``-initWith:``. The static analyzer will observe that the "
"method consumes the receiver, and then returns an object with a +1 retain "
"count."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:563
msgid ""
"The Foundation framework defines a macro ``NS_REPLACES_RECEIVER`` which is "
"functionally equivalent to the combination of ``NS_CONSUMES_SELF`` and "
"``NS_RETURNS_RETAINED`` shown above."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:568
msgid "Libkern Memory Management Annotations"
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:570
msgid ""
"`Libkern <https://developer.apple.com/documentation/kernel/osobject?"
"language=objc>`_ requires developers to inherit all heap allocated objects "
"from ``OSObject`` and to perform manual reference counting. The reference "
"counting model is very similar to MRR (manual retain-release) mode in "
"`Objective-C <https://developer.apple.com/library/archive/documentation/"
"Cocoa/Conceptual/MemoryMgmt/Articles/mmRules.html>`_ or to CoreFoundation "
"reference counting. Freshly-allocated objects start with a reference count "
"of 1, and calls to ``retain`` increment it, while calls to ``release`` "
"decrement it. The object is deallocated whenever its reference count reaches "
"zero."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:580
msgid ""
"Manually incrementing and decrementing reference counts is error-prone: over-"
"retains lead to leaks, and over-releases lead to uses-after-free. The "
"analyzer can help the programmer to check for unbalanced retain/release "
"calls."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:585
msgid ""
"The reference count checking is based on the principle of *locality*: it "
"should be possible to establish correctness (lack of leaks/uses after free) "
"by looking at each function body, and the declarations (not the definitions) "
"of all the functions it interacts with."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:590
msgid ""
"In order to support such reasoning, it should be possible to *summarize* the "
"behavior of each function, with respect to reference count of its returned "
"values and attributes."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:594
msgid "By default, the following summaries are assumed:"
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:596
msgid ""
"All functions starting with ``get`` or ``Get``, unless they are returning "
"subclasses of ``OSIterator``, are assumed to be returning at +0. That is, "
"the caller has no reference count *obligations* with respect to the "
"reference count of the returned object and should leave it untouched."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:601
msgid ""
"All other functions are assumed to return at +1. That is, the caller has an "
"*obligation* to release such objects."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:604
msgid ""
"Functions are assumed not to change the reference count of their parameters, "
"including the implicit ``this`` parameter."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:607
msgid ""
"These summaries can be overriden with the following `attributes <https://"
"clang.llvm.org/docs/AttributeReference.html#os-returns-not-retained>`_:"
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:611
msgid "Attribute 'os_returns_retained'"
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:613
msgid ""
"The ``os_returns_retained`` attribute (accessed through the macro "
"``LIBKERN_RETURNS_RETAINED``) plays a role identical to "
"`ns_returns_retained`_ for functions returning ``OSObject`` subclasses. The "
"attribute indicates that it is a callers responsibility to release the "
"returned object."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:619
msgid "Attribute 'os_returns_not_retained'"
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:621
msgid ""
"The ``os_returns_not_retained`` attribute (accessed through the macro "
"``LIBKERN_RETURNS_NOT_RETAINED``) plays a role identical to "
"`ns_returns_not_retained`_ for functions returning ``OSObject`` subclasses. "
"The attribute indicates that the caller should not change the retain count "
"of the returned object."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:643
msgid "Attribute 'os_consumed'"
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:645
msgid ""
"Similarly to `ns_consumed`_ attribute, ``os_consumed`` (accessed through "
"``LIBKERN_CONSUMED``) attribute, applied to a parameter, indicates that the "
"call to the function *consumes* the parameter: the callee should either "
"release it or store it and release it in the destructor, while the caller "
"should assume one is subtracted from the reference count after the call."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:655
msgid "Attribute 'os_consumes_this'"
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:657
msgid ""
"Similarly to `ns_consumes_self`_, the ``os_consumes_self`` attribute "
"indicates that the method call *consumes* the implicit ``this`` argument: "
"the caller should assume one was subtracted from the reference count of the "
"object after the call, and the callee has on obligation to either release "
"the argument, or store it and eventually release it in the destructor."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:668
msgid "Out Parameters"
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:670
msgid ""
"A function can also return an object to a caller by a means of an out "
"parameter (a pointer-to-OSObject-pointer is passed, and a callee writes a "
"pointer to an object into an argument). Currently the analyzer does not "
"track unannotated out parameters by default, but with annotations we "
"distinguish four separate cases:"
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:675
msgid ""
"**1. Non-retained out parameters**, identified using "
"``LIBKERN_RETURNS_NOT_RETAINED`` applied to parameters, e.g.:"
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:681
msgid ""
"Such functions write a non-retained object into an out parameter, and the "
"caller has no further obligations."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:684
msgid ""
"**2. Retained out parameters**, identified using "
"``LIBKERN_RETURNS_RETAINED``:"
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:689
msgid ""
"In such cases a retained object is written into an out parameter, which the "
"caller has then to release in order to avoid a leak."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:691
msgid ""
"These two cases are simple - but in practice a functions returning an out-"
"parameter usually also return a return code, and then an out parameter may "
"or may not be written, which conditionally depends on the exit code, e.g.:"
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:698
msgid ""
"For such functions, the usual semantics is that an object is written into on "
"\"success\", and not written into on \"failure\"."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:700
msgid ""
"For ``LIBKERN_RETURNS_RETAINED`` we assume the following definition of "
"success:"
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:703
msgid ""
"For functions returning ``OSReturn`` or ``IOReturn`` (any typedef to "
"``kern_return_t``) success is defined as having an output of zero "
"(``kIOReturnSuccess`` is zero)."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:707
msgid "For all others, success is non-zero (e.g. non-nullptr for pointers)"
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:709
msgid ""
"**3. Retained out parameters on zero return** The annotation "
"``LIBKERN_RETURNS_RETAINED_ON_ZERO`` states that a retained object is "
"written into if and only if the function returns a zero value:"
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:716
msgid ""
"Then the caller has to release an object if the function has returned zero."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:718
msgid ""
"**4. Retained out parameters on non-zero return** Similarly, "
"``LIBKERN_RETURNS_RETAINED_ON_NONZERO`` specifies that a retained object is "
"written into the parameter if and only if the function has returned a non-"
"zero value."
msgstr ""

#: ../../../analyzer/user-docs/Annotations.rst:723
msgid ""
"Note that for non-retained out parameters conditionals do not matter, as the "
"caller has no obligations regardless of whether an object is written into or "
"not."
msgstr ""
