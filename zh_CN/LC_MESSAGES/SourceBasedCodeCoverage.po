# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2025, The Clang Team
# This file is distributed under the same license as the Clang package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Clang 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-13 13:41+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../SourceBasedCodeCoverage.rst:3
msgid "Source-based Code Coverage"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:9
msgid "Introduction"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:11
msgid ""
"This document explains how to use clang's source-based code coverage "
"feature. It's called \"source-based\" because it operates on AST and "
"preprocessor information directly. This allows it to generate very precise "
"coverage data."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:15
msgid "Clang ships two other code coverage implementations:"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:17
msgid ""
":doc:`SanitizerCoverage` - A low-overhead tool meant for use alongside the "
"various sanitizers. It can provide up to edge-level coverage."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:20
msgid ""
"gcov - A GCC-compatible coverage implementation which operates on DebugInfo."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:22
msgid ""
"From this point onwards \"code coverage\" will refer to the source-based "
"kind."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:25
msgid "The code coverage workflow"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:27
msgid "The code coverage workflow consists of three main steps:"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:29
msgid "Compiling with coverage enabled."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:31
msgid "Running the instrumented program."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:33
msgid "Creating coverage reports."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:35
msgid ""
"The next few sections work through a complete, copy-'n-paste friendly "
"example based on this program:"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:53
msgid "Compiling with coverage enabled"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:55
msgid ""
"To compile code with coverage enabled, pass ``-fprofile-instr-generate -"
"fcoverage-mapping`` to the compiler:"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:63
msgid ""
"Note that linking together code with and without coverage instrumentation is "
"supported: any uninstrumented code simply won't be accounted for."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:67
msgid "Running the instrumented program"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:69
msgid ""
"The next step is to run the instrumented program. When the program exits it "
"will write a **raw profile** to the path specified by the "
"``LLVM_PROFILE_FILE`` environment variable. If that variable does not exist, "
"the profile is written to ``default.profraw`` in the current directory of "
"the program. If ``LLVM_PROFILE_FILE`` contains a path to a non-existent "
"directory, the missing directory structure will be created.  Additionally, "
"the following special **pattern strings** are rewritten:"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:77
msgid "\"%p\" expands out to the process ID."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:79
msgid "\"%h\" expands out to the hostname of the machine running the program."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:81
msgid ""
"\"%Nm\" expands out to the instrumented binary's signature. When this "
"pattern is specified, the runtime creates a pool of N raw profiles which are "
"used for on-line profile merging. The runtime takes care of selecting a raw "
"profile from the pool, locking it, and updating it before the program "
"exits.  If N is not specified (i.e the pattern is \"%m\"), it's assumed that "
"``N = 1``. N must be between 1 and 9. The merge pool specifier can only "
"occur once per filename pattern."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:95
msgid "Creating coverage reports"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:97
msgid ""
"Raw profiles have to be **indexed** before they can be used to generate "
"coverage reports. This is done using the \"merge\" tool in ``llvm-"
"profdata``, so named because it can combine and index profiles at the same "
"time:"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:106
msgid ""
"There are multiple different ways to render coverage reports. One option is "
"to generate a line-oriented report:"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:114
msgid "To demangle any C++ identifiers in the output, use:"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:120
msgid ""
"This report includes a summary view as well as dedicated sub-views for "
"templated functions and their instantiations. For our example program, we "
"get distinct views for ``foo<int>(...)`` and ``foo<float>(...)``.  If ``-"
"show-line-counts-or-regions`` is enabled, ``llvm-cov`` displays sub-line "
"region counts (even in macro expansions):"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:148
msgid ""
"It's possible to generate a file-level summary of coverage statistics "
"(instead of a line-oriented report) with:"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:161
msgid "A few final notes:"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:163
msgid ""
"The ``-sparse`` flag is optional but can result in dramatically smaller "
"indexed profiles. This option should not be used if the indexed profile will "
"be reused for PGO."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:167
msgid ""
"Raw profiles can be discarded after they are indexed. Advanced use of the "
"profile runtime library allows an instrumented program to merge profiling "
"information directly into an existing raw profile on disk. The details are "
"out of scope."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:172
msgid ""
"The ``llvm-profdata`` tool can be used to merge together multiple raw or "
"indexed profiles. To combine profiling data from multiple runs of a program, "
"try e.g:"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:181
msgid "Format compatibility guarantees"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:183
msgid ""
"There are no backwards or forwards compatibility guarantees for the raw "
"profile format. Raw profiles may be dependent on the specific compiler "
"revision used to generate them. It's inadvisable to store raw profiles for "
"long periods of time."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:188
msgid ""
"Tools must retain **backwards** compatibility with indexed profile formats. "
"These formats are not forwards-compatible: i.e, a tool which uses format "
"version X will not be able to understand format version (X+k)."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:192
msgid ""
"There is a third format in play: the format of the coverage mappings emitted "
"into instrumented binaries. Tools must retain **backwards** compatibility "
"with these formats. These formats are not forwards-compatible."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:197
msgid "Using the profiling runtime without static initializers"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:199
msgid ""
"By default the compiler runtime uses a static initializer to determine the "
"profile output path and to register a writer function. To collect profiles "
"without using static initializers, do this manually:"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:203
msgid ""
"Export a ``int __llvm_profile_runtime`` symbol from each instrumented shared "
"library and executable. When the linker finds a definition of this symbol, "
"it knows to skip loading the object which contains the profiling runtime's "
"static initializer."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:208
msgid ""
"Forward-declare ``void __llvm_profile_initialize_file(void)`` and call it "
"once from each instrumented executable. This function parses "
"``LLVM_PROFILE_FILE``, sets the output path, and truncates any existing "
"files at that path. To get the same behavior without truncating existing "
"files, pass a filename pattern string to ``void "
"__llvm_profile_set_filename(char *)``.  These calls can be placed anywhere "
"so long as they precede all calls to ``__llvm_profile_write_file``."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:216
msgid ""
"Forward-declare ``int __llvm_profile_write_file(void)`` and call it to write "
"out a profile. This function returns 0 when it succeeds, and a non-zero "
"value otherwise. Calling this function multiple times appends profile data "
"to an existing on-disk raw profile."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:222
msgid "Drawbacks and limitations"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:224
msgid ""
"Code coverage does not handle unpredictable changes in control flow or stack "
"unwinding in the presence of exceptions precisely. Consider the following "
"function:"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:235
msgid ""
"If the call to ``may_throw()`` propagates an exception into ``f``, the code "
"coverage tool may mark the ``return`` statement as executed even though it "
"is not. A call to ``longjmp()`` can have similar effects."
msgstr ""
