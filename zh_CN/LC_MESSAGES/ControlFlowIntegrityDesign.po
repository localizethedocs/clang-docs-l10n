# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2025, The Clang Team
# This file is distributed under the same license as the Clang package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Clang 3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-13 13:41+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../ControlFlowIntegrityDesign.rst:3
msgid "Control Flow Integrity Design Documentation"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:5
msgid ""
"This page documents the design of the :doc:`ControlFlowIntegrity` schemes "
"supported by Clang."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:9
msgid "Forward-Edge CFI for Virtual Calls"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:11
msgid ""
"This scheme works by allocating, for each static type used to make a virtual "
"call, a region of read-only storage in the object file holding a bit vector "
"that maps onto to the region of storage used for those virtual tables. Each "
"set bit in the bit vector corresponds to the `address point`_ for a virtual "
"table compatible with the static type for which the bit vector is being "
"built."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:17
msgid "For example, consider the following three C++ classes:"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:39
msgid ""
"The scheme will cause the virtual tables for A, B and C to be laid out "
"consecutively:"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:42
#: ../../../ControlFlowIntegrityDesign.rst:232
msgid "Virtual Table Layout for A, B, C"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "0"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "1"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "2"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "3"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "4"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "5"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "6"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "7"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "8"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "9"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "10"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "11"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "12"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "13"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "14"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "A::offset-to-top"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "&A::rtti"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "&A::f1"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "&A::f2"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "&A::f3"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "B::offset-to-top"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "&B::rtti"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "&B::f1"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "&B::f2"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "&B::f3"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "C::offset-to-top"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "&C::rtti"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "&C::f1"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "&C::f2"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "&C::f3"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:47
msgid "The bit vector for static types A, B and C will look like this:"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:49
#: ../../../ControlFlowIntegrityDesign.rst:121
msgid "Bit Vectors for A, B, C"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "Class"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "A"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "B"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "C"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:56
msgid ""
"Bit vectors are represented in the object file as byte arrays. By loading "
"from indexed offsets into the byte array and applying a mask, a program can "
"test bits from the bit set with a relatively short instruction sequence. Bit "
"vectors may overlap so long as they use different bits. For the full "
"details, see the `ByteArrayBuilder`_ class."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:62
msgid ""
"In this case, assuming A is laid out at offset 0 in bit 0, B at offset 0 in "
"bit 1 and C at offset 0 in bit 2, the byte array would look like this:"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:69
msgid ""
"To emit a virtual call, the compiler will assemble code that checks that the "
"object's virtual table pointer is in-bounds and aligned and that the "
"relevant bit is set in the bit vector."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:73
msgid "For example on x86 a typical virtual call may look like this:"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:91
msgid ""
"The compiler relies on co-operation from the linker in order to assemble the "
"bit vectors for the whole program. It currently does this using LLVM's `type "
"metadata`_ mechanism together with link-time optimization."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:100
msgid "Optimizations"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:102
msgid ""
"The scheme as described above is the fully general variant of the scheme. "
"Most of the time we are able to apply one or more of the following "
"optimizations to improve binary size or performance."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:106
msgid ""
"In fact, if you try the above example with the current version of the "
"compiler, you will probably find that it will not use the described virtual "
"table layout or machine instructions. Some of the optimizations we are about "
"to introduce cause the compiler to use a different layout or a different "
"sequence of machine instructions."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:113
msgid "Stripping Leading/Trailing Zeros in Bit Vectors"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:115
msgid ""
"If a bit vector contains leading or trailing zeros, we can strip them from "
"the vector. The compiler will emit code to check if the pointer is in range "
"of the region covered by ones, and perform the bit vector check using a "
"truncated version of the bit vector. For example, the bit vectors for our "
"example class hierarchy will be emitted like this:"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:129
msgid "Short Inline Bit Vectors"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:131
msgid ""
"If the vector is sufficiently short, we can represent it as an inline "
"constant on x86. This saves us a few instructions when reading the correct "
"element of the bit vector."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:135
msgid "If the bit vector fits in 32 bits, the code looks like this:"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:154
msgid "Or if the bit vector fits in 64 bits:"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:174
msgid ""
"If the bit vector consists of a single bit, there is only one possible "
"virtual table, and the check can consist of a single equality comparison:"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:189
msgid "Virtual Table Layout"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:191
msgid ""
"The compiler lays out classes of disjoint hierarchies in separate regions of "
"the object file. At worst, bit vectors in disjoint hierarchies only need to "
"cover their disjoint hierarchy. But the closer that classes in sub-"
"hierarchies are laid out to each other, the smaller the bit vectors for "
"those sub-hierarchies need to be (see \"Stripping Leading/Trailing Zeros in "
"Bit Vectors\" above). The `GlobalLayoutBuilder`_ class is responsible for "
"laying out the globals efficiently to minimize the sizes of the underlying "
"bitsets."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:202
msgid "Alignment"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:204
msgid ""
"If all gaps between address points in a particular bit vector are multiples "
"of powers of 2, the compiler can compress the bit vector by strengthening "
"the alignment requirements of the virtual table pointer. For example, given "
"this class hierarchy:"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:230
msgid "The virtual tables will be laid out like this:"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "15"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "&B::f4"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "&B::f5"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "&B::f6"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:237
msgid ""
"Notice that each address point for A is separated by 4 words. This lets us "
"emit a compressed bit vector for A that looks like this:"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:245
msgid ""
"At call sites, the compiler will strengthen the alignment requirements by "
"using a different rotate count. For example, on a 64-bit machine where the "
"address points are 4-word aligned (as in A from our example), the ``rol`` "
"instruction may look like this:"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:255
msgid "Padding to Powers of 2"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:257
msgid ""
"Of course, this alignment scheme works best if the address points are in "
"fact aligned correctly. To make this more likely to happen, we insert "
"padding between virtual tables that in many cases aligns address points to a "
"power of 2. Specifically, our padding aligns virtual tables to the next "
"highest power of 2 bytes; because address points for specific base classes "
"normally appear at fixed offsets within the virtual table, this normally has "
"the effect of aligning the address points as well."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:265
msgid ""
"This scheme introduces tradeoffs between decreased space overhead for "
"instructions and bit vectors and increased overhead in the form of padding. "
"We therefore limit the amount of padding so that we align to no more than "
"128 bytes. This number was found experimentally to provide a good tradeoff."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:271
msgid "Eliminating Bit Vector Checks for All-Ones Bit Vectors"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:273
msgid ""
"If the bit vector is all ones, the bit vector check is redundant; we simply "
"need to check that the address is in range and well aligned. This is more "
"likely to occur if the virtual tables are padded."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:278
msgid "Forward-Edge CFI for Indirect Function Calls"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:280
msgid ""
"Under forward-edge CFI for indirect function calls, each unique function "
"type has its own bit vector, and at each call site we need to check that the "
"function pointer is a member of the function type's bit vector. This scheme "
"works in a similar way to forward-edge CFI for virtual calls, the "
"distinction being that we need to build bit vectors of function entry points "
"rather than of virtual tables."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:287
msgid ""
"Unlike when re-arranging global variables, we cannot re-arrange functions in "
"a particular order and base our calculations on the layout of the functions' "
"entry points, as we have no idea how large a particular function will end up "
"being (the function sizes could even depend on how we arrange the "
"functions). Instead, we build a jump table, which is a block of code "
"consisting of one branch instruction for each of the functions in the bit "
"set that branches to the target function, and redirect any taken function "
"addresses to the corresponding jump table entry. In this way, the distance "
"between function entry points is predictable and controllable. In the object "
"file's symbol table, the symbols for the target functions also refer to the "
"jump table entries, so that addresses taken outside the module will pass any "
"verification done inside the module."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:300
msgid ""
"In more concrete terms, suppose we have three functions ``f``, ``g``, ``h`` "
"which are all of the same type, and a function foo that returns their "
"addresses:"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:324
msgid "Our jump table will (conceptually) look like this:"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:364
msgid ""
"Because the addresses of ``f``, ``g``, ``h`` are evenly spaced at a power of "
"2, and function types do not overlap (unlike class types with base classes), "
"we can normally apply the `Alignment`_ and `Eliminating Bit Vector Checks "
"for All-Ones Bit Vectors`_ optimizations thus simplifying the check at each "
"call site to a range and alignment check."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:371
msgid "Shared library support"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:373
msgid "**EXPERIMENTAL**"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:375
msgid ""
"The basic CFI mode described above assumes that the application is a "
"monolithic binary; at least that all possible virtual/indirect call targets "
"and the entire class hierarchy are known at link time. The cross-DSO mode, "
"enabled with **-f[no-]sanitize-cfi-cross-dso** relaxes this requirement by "
"allowing virtual and indirect calls to cross the DSO boundary."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:382
msgid ""
"Assuming the following setup: the binary consists of several instrumented "
"and several uninstrumented DSOs. Some of them may be dlopen-ed/dlclose-d "
"periodically, even frequently."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:386
msgid "Calls made from uninstrumented DSOs are not checked and just work."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:387
msgid "Calls inside any instrumented DSO are fully protected."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:389
msgid "Calls between different instrumented DSOs are also protected, with"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:389
msgid "a performance penalty (in addition to the monolithic CFI overhead)."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:391
msgid "Calls from an instrumented DSO to an uninstrumented one are"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:392
msgid "unchecked and just work, with performance penalty."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:394
msgid "Calls from an instrumented DSO outside of any known DSO are"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:394
msgid "detected as CFI violations."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:396
msgid "In the monolithic scheme a call site is instrumented as"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:404
msgid "In the cross-DSO scheme it becomes"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:413
msgid "CallSiteTypeId"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:415
msgid ""
"``CallSiteTypeId`` is a stable process-wide identifier of the call-site "
"type. For a virtual call site, the type in question is the class type; for "
"an indirect function call it is the function signature. The mapping from a "
"type to an identifier is an ABI detail. In the current, experimental, "
"implementation the identifier of type T is calculated as follows:"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:422
msgid "Obtain the mangled name for \"typeinfo name for T\"."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:423
msgid "Calculate MD5 hash of the name as a string."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:424
msgid ""
"Reinterpret the first 8 bytes of the hash as a little-endian 64-bit integer."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:427
msgid ""
"It is possible, but unlikely, that collisions in the ``CallSiteTypeId`` "
"hashing will result in weaker CFI checks that would still be conservatively "
"correct."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:432
msgid "CFI_Check"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:434
msgid ""
"In the general case, only the target DSO knows whether the call to function "
"``f`` with type ``CallSiteTypeId`` is valid or not.  To export this "
"information, every DSO implements"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:442
msgid ""
"This function provides external modules with access to CFI checks for the "
"targets inside this DSO.  For each known ``CallSiteTypeId``, this function "
"performs an ``llvm.type.test`` with the corresponding type identifier. It "
"aborts if the type is unknown, or if the check fails."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:447
msgid ""
"The basic implementation is a large switch statement over all values of "
"CallSiteTypeId supported by this DSO, and each case is similar to the "
"InlinedFastCheck() in the basic CFI mode."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:452
msgid "CFI Shadow"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:454
msgid ""
"To route CFI checks to the target DSO's __cfi_check function, a mapping from "
"possible virtual / indirect call targets to the corresponding __cfi_check "
"functions is maintained. This mapping is implemented as a sparse array of 2 "
"bytes for every possible page (4096 bytes) of memory. The table is kept "
"readonly (FIXME: not yet) most of the time."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:461
msgid "There are 3 types of shadow values:"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:463
msgid "Address in a CFI-instrumented DSO."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:464
msgid ""
"Unchecked address (a “trusted” non-instrumented DSO). Encoded as value "
"0xFFFF."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:466
msgid "Invalid address (everything else). Encoded as value 0."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:468
msgid ""
"For a CFI-instrumented DSO, a shadow value encodes the address of the "
"__cfi_check function for all call targets in the corresponding memory page. "
"If Addr is the target address, and V is the shadow value, then the address "
"of __cfi_check is calculated as"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:477
msgid ""
"This works as long as __cfi_check is aligned by 4096 bytes and located below "
"any call targets in its DSO, but not more than 256MB apart from them."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:482
msgid "CFI_SlowPath"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:484
msgid "The slow path check is implemented in compiler-rt library as"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:490
msgid ""
"This functions loads a shadow value for ``TargetAddr``, finds the address of "
"__cfi_check as described above and calls that."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:494
msgid "Position-independent executable requirement"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:496
msgid ""
"Cross-DSO CFI mode requires that the main executable is built as PIE. In non-"
"PIE executables the address of an external function (taken from the main "
"executable) is the address of that function’s PLT record in the main "
"executable. This would break the CFI checks."
msgstr ""
