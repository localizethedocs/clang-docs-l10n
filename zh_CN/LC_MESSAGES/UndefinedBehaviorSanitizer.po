# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2025, The Clang Team
# This file is distributed under the same license as the Clang package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Clang 21\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-21 08:51+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../UndefinedBehaviorSanitizer.rst:3
msgid "UndefinedBehaviorSanitizer"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:9
msgid "Introduction"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:11
msgid ""
"UndefinedBehaviorSanitizer (UBSan) is a fast undefined behavior detector. "
"UBSan modifies the program at compile-time to catch various kinds of "
"undefined behavior during program execution, for example:"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:15
msgid ""
"Array subscript out of bounds, where the bounds can be statically determined"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:16
msgid "Bitwise shifts that are out of bounds for their data type"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:17
msgid "Dereferencing misaligned or null pointers"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:18
msgid "Signed integer overflow"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:19
msgid ""
"Conversion to, from, or between floating-point types which would overflow "
"the destination"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:22
msgid "See the full list of available :ref:`checks <ubsan-checks>` below."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:24
msgid ""
"UBSan has an optional run-time library which provides better error "
"reporting. The checks have small runtime cost and no impact on address space "
"layout or ABI."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:28
msgid "How to build"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:30
msgid "Build LLVM/Clang with `CMake <https://llvm.org/docs/CMake.html>`_."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:33
msgid "Usage"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:35
msgid ""
"Use ``clang++`` to compile and link your program with the ``-"
"fsanitize=undefined`` option. Make sure to use ``clang++`` (not ``ld``) as a "
"linker, so that your executable is linked with proper UBSan runtime "
"libraries, unless all enabled checks use trap mode. You can use ``clang`` "
"instead of ``clang++`` if you're compiling/linking C code."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:53
msgid ""
"You can use ``-fsanitize=...`` and ``-fno-sanitize=`` to enable and disable "
"one check or one check group. For an individual check, the last option that "
"enabling or disabling it wins."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:68
msgid ""
"For most checks (:ref:`checks <ubsan-checks>`), the instrumented program "
"prints a verbose error report and continues execution upon a failed check. "
"You can use the following options to change the error reporting behavior:"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:72
msgid ""
"``-fno-sanitize-recover=...``: print a verbose error report and exit the "
"program;"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:73
msgid ""
"``-fsanitize-trap=...``: execute a trap instruction (doesn't require UBSan "
"run-time support). If the signal is not caught, the program will typically "
"terminate due to a ``SIGILL`` or ``SIGTRAP`` signal."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:77
msgid "For example:"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:83
msgid ""
"The program will continue execution after signed integer overflows, exit "
"after the first invalid use of a null pointer, and trap after the first use "
"of misaligned pointer."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:91
msgid ""
"All checks in the \"undefined\" group are put into trap mode. Since no check "
"needs run-time support, the UBSan run-time library it not linked. Note that "
"some other sanitizers also support trap mode and ``-fsanitize-trap=all`` "
"enables trap mode for them."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:100
msgid ""
"``-fsanitize-trap=`` and ``-fsanitize-recover=`` are a no-op in the absence "
"of a ``-fsanitize=`` option. There is no unused command line option warning."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:106
msgid "Available checks"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:108
msgid "Available checks are:"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:110
msgid ""
"``-fsanitize=alignment``: Use of a misaligned pointer or creation of a "
"misaligned reference. Also sanitizes assume_aligned-like attributes."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:112
msgid ""
"``-fsanitize=bool``: Load of a ``bool`` value which is neither ``true`` nor "
"``false``."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:114
msgid "``-fsanitize=builtin``: Passing invalid values to compiler builtins."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:115
msgid ""
"``-fsanitize=bounds``: Out of bounds array indexing, in cases where the "
"array bound can be statically determined. The check includes ``-"
"fsanitize=array-bounds`` and ``-fsanitize=local-bounds``. Note that ``-"
"fsanitize=local-bounds`` is not included in ``-fsanitize=undefined``."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:119
msgid ""
"``-fsanitize=enum``: Load of a value of an enumerated type which is not in "
"the range of representable values for that enumerated type."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:122
msgid ""
"``-fsanitize=float-cast-overflow``: Conversion to, from, or between floating-"
"point types which would overflow the destination. Because the range of "
"representable values for all floating-point types supported by Clang is [-"
"inf, +inf], the only cases detected are conversions from floating point to "
"integer types."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:127
msgid ""
"``-fsanitize=float-divide-by-zero``: Floating point division by zero. This "
"is undefined per the C and C++ standards, but is defined by Clang (and by "
"ISO/IEC/IEEE 60559 / IEEE 754) as producing either an infinity or NaN value, "
"so is not included in ``-fsanitize=undefined``."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:131
msgid ""
"``-fsanitize=function``: Indirect call of a function through a function "
"pointer of the wrong type."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:133
msgid ""
"``-fsanitize=implicit-unsigned-integer-truncation``, ``-fsanitize=implicit-"
"signed-integer-truncation``: Implicit conversion from integer of larger bit "
"width to smaller bit width, if that results in data loss. That is, if the "
"demoted value, after casting back to the original width, is not equal to the "
"original value before the downcast. The ``-fsanitize=implicit-unsigned-"
"integer-truncation`` handles conversions between two ``unsigned`` types, "
"while ``-fsanitize=implicit-signed-integer-truncation`` handles the rest of "
"the conversions - when either one, or both of the types are signed. Issues "
"caught by these sanitizers are not undefined behavior, but are often "
"unintentional."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:144
msgid ""
"``-fsanitize=implicit-integer-sign-change``: Implicit conversion between "
"integer types, if that changes the sign of the value. That is, if the "
"original value was negative and the new value is positive (or zero), or the "
"original value was positive, and the new value is negative. Issues caught by "
"this sanitizer are not undefined behavior, but are often unintentional."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:150
msgid "``-fsanitize=integer-divide-by-zero``: Integer division by zero."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:151
msgid ""
"``-fsanitize=implicit-bitfield-conversion``: Implicit conversion from "
"integer of larger bit width to smaller bitfield, if that results in data "
"loss. This includes unsigned/signed truncations and sign changes, similarly "
"to how the ``-fsanitize=implicit-integer-conversion`` group works, but "
"explicitly for bitfields."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:156
msgid ""
"``-fsanitize=nonnull-attribute``: Passing null pointer as a function "
"parameter which is declared to never be null."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:158
msgid ""
"``-fsanitize=null``: Use of a null pointer or creation of a null reference."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:160
msgid ""
"``-fsanitize=nullability-arg``: Passing null as a function parameter which "
"is annotated with ``_Nonnull``."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:162
msgid ""
"``-fsanitize=nullability-assign``: Assigning null to an lvalue which is "
"annotated with ``_Nonnull``."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:164
msgid ""
"``-fsanitize=nullability-return``: Returning null from a function with a "
"return type annotated with ``_Nonnull``."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:166
msgid ""
"``-fsanitize=objc-cast``: Invalid implicit cast of an ObjC object pointer to "
"an incompatible type. This is often unintentional, but is not undefined "
"behavior, therefore the check is not a part of the ``undefined`` group. "
"Currently only supported on Darwin."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:170
msgid ""
"``-fsanitize=object-size``: An attempt to potentially use bytes which the "
"optimizer can determine are not part of the object being accessed. This will "
"also detect some types of undefined behavior that may not directly access "
"memory, but are provably incorrect given the size of the objects involved, "
"such as invalid downcasts and calling methods on invalid pointers. These "
"checks are made in terms of ``__builtin_object_size``, and consequently may "
"be able to detect more problems at higher optimization levels."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:178
msgid ""
"``-fsanitize=pointer-overflow``: Performing pointer arithmetic which "
"overflows, or where either the old or new pointer value is a null pointer "
"(excluding the case where both are null pointers)."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:181
msgid ""
"``-fsanitize=return``: In C++, reaching the end of a value-returning "
"function without returning a value."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:183
msgid ""
"``-fsanitize=returns-nonnull-attribute``: Returning null pointer from a "
"function which is declared to never return null."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:185
msgid ""
"``-fsanitize=shift``: Shift operators where the amount shifted is greater or "
"equal to the promoted bit-width of the left hand side or less than zero, or "
"where the left hand side is negative. For a signed left shift, also checks "
"for signed overflow in C, and for unsigned overflow in C++. You can use ``-"
"fsanitize=shift-base`` or ``-fsanitize=shift-exponent`` to check only left-"
"hand side or right-hand side of shift operation, respectively."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:192
msgid ""
"``-fsanitize=unsigned-shift-base``: check that an unsigned left-hand side of "
"a left shift operation doesn't overflow. Issues caught by this sanitizer are "
"not undefined behavior, but are often unintentional."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:195
msgid ""
"``-fsanitize=signed-integer-overflow``: Signed integer overflow, where the "
"result of a signed integer computation cannot be represented in its type. "
"This includes all the checks covered by ``-ftrapv``, as well as checks for "
"signed division overflow (``INT_MIN/-1``). Note that checks are still added "
"even when ``-fwrapv`` is enabled. This sanitizer does not check for lossy "
"implicit conversions performed before the computation (see ``-"
"fsanitize=implicit-integer-conversion``). Both of these two issues are "
"handled by ``-fsanitize=implicit-integer-conversion`` group of checks."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:203
msgid ""
"``-fsanitize=unreachable``: If control flow reaches an unreachable program "
"point."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:205
msgid ""
"``-fsanitize=unsigned-integer-overflow``: Unsigned integer overflow, where "
"the result of an unsigned integer computation cannot be represented in its "
"type. Unlike signed integer overflow, this is not undefined behavior, but it "
"is often unintentional. This sanitizer does not check for lossy implicit "
"conversions performed before such a computation (see ``-fsanitize=implicit-"
"integer-conversion``)."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:211
msgid ""
"``-fsanitize=vla-bound``: A variable-length array whose bound does not "
"evaluate to a positive value."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:213
msgid ""
"``-fsanitize=vptr``: Use of an object whose vptr indicates that it is of the "
"wrong dynamic type, or that its lifetime has not begun or has ended. "
"Incompatible with ``-fno-rtti``. Link must be performed by ``clang++``, not "
"``clang``, to make sure C++-specific parts of the runtime library and C++ "
"standard libraries are present. The check is not a part of the ``undefined`` "
"group. Also it does not support ``-fsanitize-trap=vptr``."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:252
msgid "You can also use the following check groups:"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:221
msgid ""
"``-fsanitize=undefined``: All of the checks listed above other than ``float-"
"divide-by-zero``, ``unsigned-integer-overflow``, ``implicit-conversion``, "
"``local-bounds``, ``vptr`` and the ``nullability-*`` group of checks."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:225
msgid ""
"``-fsanitize=undefined-trap``: Deprecated alias of ``-fsanitize=undefined``."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:227
msgid ""
"``-fsanitize=implicit-integer-truncation``: Catches lossy integral "
"conversions. Enables ``implicit-signed-integer-truncation`` and ``implicit-"
"unsigned-integer-truncation``."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:230
msgid ""
"``-fsanitize=implicit-integer-arithmetic-value-change``: Catches implicit "
"conversions that change the arithmetic value of the integer. Enables "
"``implicit-signed-integer-truncation`` and ``implicit-integer-sign-change``."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:233
msgid ""
"``-fsanitize=implicit-integer-conversion``: Checks for suspicious behavior "
"of implicit integer conversions. Enables ``implicit-unsigned-integer-"
"truncation``, ``implicit-signed-integer-truncation``, and ``implicit-integer-"
"sign-change``."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:238
msgid ""
"``-fsanitize=implicit-conversion``: Checks for suspicious behavior of "
"implicit conversions. Enables ``implicit-integer-conversion``, and "
"``implicit-bitfield-conversion``."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:242
msgid ""
"``-fsanitize=integer``: Checks for undefined or suspicious integer behavior "
"(e.g. unsigned integer overflow). Enables ``signed-integer-overflow``, "
"``unsigned-integer-overflow``, ``shift``, ``integer-divide-by-zero``, "
"``implicit-unsigned-integer-truncation``, ``implicit-signed-integer-"
"truncation``, and ``implicit-integer-sign-change``."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:249
msgid ""
"``-fsanitize=nullability``: Enables ``nullability-arg``, ``nullability-"
"assign``, and ``nullability-return``. While violating nullability does not "
"have undefined behavior, it is often unintentional, so UBSan offers to catch "
"it."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:255
msgid "Volatile"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:257
msgid ""
"The ``null``, ``alignment``, ``object-size``, ``local-bounds``, and ``vptr`` "
"checks do not apply to pointers to types with the ``volatile`` qualifier."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:263
msgid "Minimal Runtime"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:265
msgid ""
"There is a minimal UBSan runtime available suitable for use in production "
"environments. This runtime has a small attack surface. It only provides very "
"basic issue logging and deduplication, and does not support ``-"
"fsanitize=vptr`` checking."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:270
msgid ""
"To use the minimal runtime, add ``-fsanitize-minimal-runtime`` to the clang "
"command line options. For example, if you're used to compiling with ``-"
"fsanitize=undefined``, you could enable the minimal runtime with ``-"
"fsanitize=undefined -fsanitize-minimal-runtime``."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:276
msgid "Stack traces and report symbolization"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:277
msgid ""
"If you want UBSan to print symbolized stack trace for each error report, you "
"will need to:"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:280
msgid ""
"Compile with ``-g``, ``-fno-sanitize-merge`` and ``-fno-omit-frame-pointer`` "
"to get proper debug information in your binary."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:282
msgid ""
"Run your program with environment variable "
"``UBSAN_OPTIONS=print_stacktrace=1``."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:284
msgid "Make sure ``llvm-symbolizer`` binary is in ``PATH``."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:287
msgid "Logging"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:289
msgid ""
"The default log file for diagnostics is \"stderr\". To log diagnostics to "
"another file, you can set ``UBSAN_OPTIONS=log_path=...``."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:293
msgid "Silencing Unsigned Integer Overflow"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:294
msgid ""
"To silence reports from unsigned integer overflow, you can set "
"``UBSAN_OPTIONS=silence_unsigned_overflow=1``.  This feature, combined with "
"``-fsanitize-recover=unsigned-integer-overflow``, is particularly useful for "
"providing fuzzing signal without blowing up logs."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:300
msgid "Disabling instrumentation for common overflow patterns"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:302
msgid ""
"There are certain overflow-dependent or overflow-prone code patterns which "
"produce a lot of noise for integer overflow/truncation sanitizers. Negated "
"unsigned constants, post-decrements in a while loop condition and simple "
"overflow checks are accepted and pervasive code patterns. However, the "
"signal received from sanitizers instrumenting these code patterns may be too "
"noisy for some projects. To disable instrumentation for these common "
"patterns one should use ``-fsanitize-undefined-ignore-overflow-pattern=``."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:310
msgid "Currently, this option supports three overflow-dependent code idioms:"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:312
msgid "``negated-unsigned-const``"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:320
msgid "``unsigned-post-decr-while``"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:328
msgid "``add-signed-overflow-test,add-unsigned-overflow-test``"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:336
msgid "Overflow Pattern Types"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:340
msgid "Pattern"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:341
msgid "Sanitizer"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:342
msgid "negated-unsigned-const"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:343
#: ../../../UndefinedBehaviorSanitizer.rst:345
#: ../../../UndefinedBehaviorSanitizer.rst:347
msgid "unsigned-integer-overflow"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:344
msgid "unsigned-post-decr-while"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:346
msgid "add-unsigned-overflow-test"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:348
msgid "add-signed-overflow-test"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:349
msgid "signed-integer-overflow"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:353
msgid ""
"Note: ``add-signed-overflow-test`` suppresses only the check for Undefined "
"Behavior. Eager Undefined Behavior optimizations are still possible. One may "
"remedy this with ``-fwrapv`` or ``-fno-strict-overflow``."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:357
msgid ""
"You can enable all exclusions with ``-fsanitize-undefined-ignore-overflow-"
"pattern=all`` or disable all exclusions with ``-fsanitize-undefined-ignore-"
"overflow-pattern=none``. If ``-fsanitize-undefined-ignore-overflow-pattern`` "
"is not specified ``none`` is implied. Specifying ``none`` alongside other "
"values also implies ``none`` as ``none`` has precedence over other values -- "
"including ``all``."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:365
msgid "Issue Suppression"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:367
msgid ""
"UndefinedBehaviorSanitizer is not expected to produce false positives. If "
"you see one, look again; most likely it is a true positive!"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:371
msgid ""
"Disabling Instrumentation with "
"``__attribute__((no_sanitize(\"undefined\")))``"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:373
msgid ""
"You disable UBSan checks for particular functions with "
"``__attribute__((no_sanitize(\"undefined\")))``. You can use all values of "
"``-fsanitize=`` flag in this attribute, e.g. if your function deliberately "
"contains possible signed integer overflow, you can use "
"``__attribute__((no_sanitize(\"signed-integer-overflow\")))``."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:379
msgid ""
"This attribute may not be supported by other compilers, so consider using it "
"together with ``#if defined(__clang__)``."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:384
msgid "Suppressing Errors in Recompiled Code (Ignorelist)"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:386
msgid ""
"UndefinedBehaviorSanitizer supports ``src`` and ``fun`` entity types in :doc:"
"`SanitizerSpecialCaseList`, that can be used to suppress error reports in "
"the specified source files or functions."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:391
msgid "Runtime suppressions"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:393
msgid ""
"Sometimes you can suppress UBSan error reports for specific files, "
"functions, or libraries without recompiling the code. You need to pass a "
"path to suppression file in a ``UBSAN_OPTIONS`` environment variable."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:401
msgid ""
"You need to specify a :ref:`check <ubsan-checks>` you are suppressing and "
"the bug location. For example:"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:410
msgid "There are several limitations:"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:412
msgid ""
"Sometimes your binary must have enough debug info and/or symbol table, so "
"that the runtime could figure out source file or function name to match "
"against the suppression."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:415
msgid ""
"It is only possible to suppress recoverable checks. For the example above, "
"you can additionally pass ``-fsanitize-recover=signed-integer-overflow,"
"alignment,vptr``, although most of UBSan checks are recoverable by default."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:419
msgid ""
"Check groups (like ``undefined``) can't be used in suppressions file, only "
"fine-grained checks are supported."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:423
msgid "Security Considerations"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:425
msgid ""
"UndefinedBehaviorSanitizer's runtime is meant for testing purposes and its "
"usage in production environment should be carefully considered from security "
"perspective as it may compromise the security of the resulting executable. "
"For security-sensitive applications consider using :ref:`Minimal Runtime "
"<minimal-runtime>` or trap mode for all checks."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:432
msgid "Supported Platforms"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:434
msgid ""
"UndefinedBehaviorSanitizer is supported on the following operating systems:"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:436
msgid "Android"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:437
msgid "Linux"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:438
msgid "NetBSD"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:439
msgid "FreeBSD"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:440
msgid "OpenBSD"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:441
msgid "macOS"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:442
msgid "Windows"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:444
msgid ""
"The runtime library is relatively portable and platform independent. If the "
"OS you need is not listed above, UndefinedBehaviorSanitizer may already work "
"for it, or could be made to work with a minor porting effort."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:449
msgid "Current Status"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:451
msgid ""
"UndefinedBehaviorSanitizer is available on selected platforms starting from "
"LLVM 3.3. The test suite is integrated into the CMake build and can be run "
"with ``check-ubsan`` command."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:456
msgid "Additional Configuration"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:458
msgid ""
"UndefinedBehaviorSanitizer adds static check data for each check unless it "
"is in trap mode. This check data includes the full file name. The option ``-"
"fsanitize-undefined-strip-path-components=N`` can be used to trim this "
"information. If ``N`` is positive, file information emitted by "
"UndefinedBehaviorSanitizer will drop the first ``N`` components from the "
"file path. If ``N`` is negative, the last ``N`` components will be kept."
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:466
msgid "Example"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:468
msgid ""
"For a file called ``/code/library/file.cpp``, here is what would be emitted:"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:470
msgid ""
"Default (No flag, or ``-fsanitize-undefined-strip-path-components=0``): ``/"
"code/library/file.cpp``"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:471
msgid ""
"``-fsanitize-undefined-strip-path-components=1``: ``code/library/file.cpp``"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:472
msgid "``-fsanitize-undefined-strip-path-components=2``: ``library/file.cpp``"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:473
msgid "``-fsanitize-undefined-strip-path-components=-1``: ``file.cpp``"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:474
msgid "``-fsanitize-undefined-strip-path-components=-2``: ``library/file.cpp``"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:477
msgid "More Information"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:479
msgid ""
"From Oracle blog, including a discussion of error messages: `Improving "
"Application Security with UndefinedBehaviorSanitizer (UBSan) and GCC "
"<https://blogs.oracle.com/linux/improving-application-security-with-"
"undefinedbehaviorsanitizer-ubsan-and-gcc>`_"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:482
msgid ""
"From LLVM project blog: `What Every C Programmer Should Know About Undefined "
"Behavior <http://blog.llvm.org/2011/05/what-every-c-programmer-should-know."
"html>`_"
msgstr ""

#: ../../../UndefinedBehaviorSanitizer.rst:485
msgid ""
"From John Regehr's *Embedded in Academia* blog: `A Guide to Undefined "
"Behavior in C and C++ <https://blog.regehr.org/archives/213>`_"
msgstr ""
