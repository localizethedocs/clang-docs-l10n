# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2025, The Clang Team
# This file is distributed under the same license as the Clang package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Clang 15\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-13 13:43+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: fr_FR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../StandardCPlusPlusModules.rst:3
msgid "Standard C++ Modules"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:9
msgid "Introduction"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:11
msgid ""
"The term ``modules`` has a lot of meanings. For the users of Clang, modules "
"may refer to ``Objective-C Modules``, ``Clang C++ Modules`` (or ``Clang "
"Header Modules``, etc.) or ``Standard C++ Modules``. The implementation of "
"all these kinds of modules in Clang has a lot of shared code, but from the "
"perspective of users, their semantics and command line interfaces are very "
"different. This document focuses on an introduction of how to use standard C+"
"+ modules in Clang."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:18
msgid ""
"There is already a detailed document about `Clang modules <Modules.html>`_, "
"it should be helpful to read `Clang modules <Modules.html>`_ if you want to "
"know more about the general idea of modules. Since standard C++ modules have "
"different semantics (and work flows) from `Clang modules`, this page "
"describes the background and use of Clang with standard C++ modules."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:24
msgid ""
"Modules exist in two forms in the C++ Language Specification. They can refer "
"to either \"Named Modules\" or to \"Header Units\". This document covers "
"both forms."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:28
msgid "Standard C++ Named modules"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:30
msgid ""
"This document was intended to be a manual first and foremost, however, we "
"consider it helpful to introduce some language background here for readers "
"who are not familiar with the new language feature. This document is not "
"intended to be a language tutorial; it will only introduce necessary "
"concepts about the structure and building of the project."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:37
msgid "Background and terminology"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:40
msgid "Modules"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:42
msgid ""
"In this document, the term ``Modules``/``modules`` refers to standard C++ "
"modules feature if it is not decorated by ``Clang``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:46
msgid "Clang Modules"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:48
msgid ""
"In this document, the term ``Clang Modules``/``Clang modules`` refer to "
"Clang c++ modules extension. These are also known as ``Clang header "
"modules``, ``Clang module map modules`` or ``Clang c++ modules``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:53
msgid "Module and module unit"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:55
msgid ""
"A module consists of one or more module units. A module unit is a special "
"translation unit. Every module unit must have a module declaration. The "
"syntax of the module declaration is:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:63
msgid ""
"Terms enclosed in ``[]`` are optional. The syntax of ``module_name`` and "
"``partition_name`` in regex form corresponds to ``[a-zA-Z_][a-zA-"
"Z_0-9\\.]*``. In particular, a literal dot ``.`` in the name has no semantic "
"meaning (e.g. implying a hierarchy)."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:67
msgid "In this document, module units are classified into:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:69
msgid "Primary module interface unit."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:71
msgid "Module implementation unit."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:73
msgid "Module interface partition unit."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:75
msgid "Internal module partition unit."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:77
msgid ""
"A primary module interface unit is a module unit whose module declaration is "
"``export module module_name;``. The ``module_name`` here denotes the name of "
"the module. A module should have one and only one primary module interface "
"unit."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:81
msgid ""
"A module implementation unit is a module unit whose module declaration is "
"``module module_name;``. A module could have multiple module implementation "
"units with the same declaration."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:85
msgid ""
"A module interface partition unit is a module unit whose module declaration "
"is ``export module module_name:partition_name;``. The ``partition_name`` "
"should be unique within any given module."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:89
msgid ""
"An internal module partition unit is a module unit whose module declaration "
"is ``module module_name:partition_name;``. The ``partition_name`` should be "
"unique within any given module."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:93
msgid "In this document, we use the following umbrella terms:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:95
msgid ""
"A ``module interface unit`` refers to either a ``primary module interface "
"unit`` or a ``module interface partition unit``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:98
msgid ""
"An ``importable module unit`` refers to either a ``module interface unit`` "
"or a ``internal module partition unit``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:101
msgid ""
"A ``module partition unit`` refers to either a ``module interface partition "
"unit`` or a ``internal module partition unit``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:105
msgid "Built Module Interface file"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:107
msgid ""
"A ``Built Module Interface file`` stands for the precompiled result of an "
"importable module unit. It is also called the acronym ``BMI`` genrally."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:111
msgid "Global module fragment"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:113
msgid ""
"In a module unit, the section from ``module;`` to the module declaration is "
"called the global module fragment."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:117
msgid "How to build projects using modules"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:120
#: ../../../StandardCPlusPlusModules.rst:615
msgid "Quick Start"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:122
msgid "Let's see a \"hello world\" example that uses modules."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:141
msgid "Then we type:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:150
msgid ""
"In this example, we make and use a simple module ``Hello`` which contains "
"only a primary module interface unit ``Hello.cppm``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:153
msgid ""
"Then let's see a little bit more complex \"hello world\" example which uses "
"the 4 kinds of module units."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:195
msgid "Then we are able to compile the example by the following command:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:214
msgid "We explain the options in the following sections."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:217
msgid "How to enable standard C++ modules"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:219
msgid ""
"Currently, standard C++ modules are enabled automatically if the language "
"standard is ``-std=c++20`` or newer. The ``-fmodules-ts`` option is "
"deprecated and is planned to be removed."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:224
msgid "How to produce a BMI"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:226
msgid ""
"It is possible to generate a BMI for an importable module unit by specifying "
"the ``--precompile`` option."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:229
msgid "File name requirement"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:231
msgid ""
"The file name of an ``importable module unit`` should end with ``.cppm`` (or "
"``.ccm``, ``.cxxm``, ``.c++m``). The file name of a ``module implementation "
"unit`` should end with ``.cpp`` (or ``.cc``, ``.cxx``, ``.c++``)."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:235
msgid ""
"The file name of BMIs should end with ``.pcm``. The file name of the BMI of "
"a ``primary module interface unit`` should be ``module_name.pcm``. The file "
"name of BMIs of ``module partition unit`` should be ``module_name-"
"partition_name.pcm``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:239
msgid ""
"If the file names use different extensions, Clang may fail to build the "
"module. For example, if the filename of an ``importable module unit`` ends "
"with ``.cpp`` instead of ``.cppm``, then we can't generate a BMI for the "
"``importable module unit`` by ``--precompile`` option since ``--precompile`` "
"option now would only run preprocessor, which is equal to `-E` now. If we "
"want the filename of an ``importable module unit`` ends with other suffixes "
"instead of ``.cppm``, we could put ``-x c++-module`` in front of the file. "
"For example,"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:263
msgid ""
"Now the filename of the ``module interface`` ends with ``.cpp`` instead of "
"``.cppm``, we can't compile them by the original command lines. But we are "
"still able to do it by:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:274
#: ../../../StandardCPlusPlusModules.rst:684
msgid "How to specify the dependent BMIs"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:276
msgid ""
"The option ``-fprebuilt-module-path`` tells the compiler the path where to "
"search for dependent BMIs. It may be used multiple times just like ``-I`` "
"for specifying paths for header files. The look up rule here is:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:279
msgid ""
"(1) When we import module M. The compiler would look up M.pcm in the "
"directories specified by ``-fprebuilt-module-path``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:281
msgid ""
"(2) When we import partition module unit M:P. The compiler would look up M-P."
"pcm in the directories specified by ``-fprebuilt-module-path``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:284
msgid ""
"Another way to specify the dependent BMIs is to use ``-fmodule-file``. The "
"main difference is that ``-fprebuilt-module-path`` takes a directory, "
"whereas ``-fmodule-file`` requires a specific file. In case both the ``-"
"fprebuilt-module-path`` and ``-fmodule-file`` exist, the ``-fmodule-file`` "
"option takes higher precedence. In another word, if the compiler finds the "
"wanted BMI specified by ``-fmodule-file``, the compiler wouldn't look up "
"again in the directories specified by ``-fprebuilt-module-path``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:291
msgid ""
"When we compile a ``module implementation unit``, we must pass the BMI of "
"the corresponding ``primary module interface unit`` by ``-fmodule-file`` "
"since the language specification says a module implementation unit "
"implicitly imports the primary module interface unit."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:296
msgid "[module.unit]p8"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:298
msgid ""
"A module-declaration that contains neither an export-keyword nor a module-"
"partition implicitly imports the primary module interface unit of the module "
"as if by a module-import-declaration."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:301
msgid ""
"Again, the option ``-fmodule-file`` may occur multiple times. For example, "
"the command line to compile ``M.cppm`` in the above example could be "
"rewritten into:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:309
msgid ""
"``-fprebuilt-module-path`` is more convenient and ``-fmodule-file`` is "
"faster since it saves time for file lookup."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:313
msgid "Remember that module units still have an object counterpart to the BMI"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:315
msgid ""
"It is easy to forget to compile BMIs at first since we may envision module "
"interfaces like headers. However, this is not true. Module units are "
"translation units. We need to compile them to object files and link the "
"object files like the example shows."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:320
msgid ""
"For example, the traditional compilation processes for headers are like:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:329
msgid "And the compilation process for module units are like:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:338
msgid ""
"As the diagrams show, we need to compile the BMI from module units to object "
"files and link the object files. (But we can't do this for the BMI from "
"header units. See the later section for the definition of header units)"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:341
msgid ""
"If we want to create a module library, we can't just ship the BMIs in an "
"archive. We must compile these BMIs(``*.pcm``) into object files(``*.o``) "
"and add those object files to the archive instead."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:345
msgid "Consistency Requirement"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:347
msgid ""
"If we envision modules as a cache to speed up compilation, then - as with "
"other caching techniques - it is important to keep cache consistency. So "
"**currently** Clang will do very strict check for consistency."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:352
msgid "Options consistency"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:354
msgid ""
"The language option of module units and their non-module-unit users should "
"be consistent. The following example is not allowed:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:370
msgid ""
"The compiler would reject the example due to the inconsistent language "
"options. Not all options are language options. For example, the following "
"example is allowed:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:382
msgid ""
"Although the two examples have inconsistent optimization and debugging "
"level, both of them are accepted."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:384
msgid ""
"Note that **currently** the compiler doesn't consider inconsistent macro "
"definition a problem. For example:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:392
msgid ""
"Currently Clang would accept the above example. But it may produce "
"surprising results if the debugging code depends on consistent use of "
"``NDEBUG`` also in other translation units."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:396
msgid "Source content consistency"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:398
msgid ""
"When the compiler reads a BMI, the compiler will check the consistency of "
"the corresponding source files. For example:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:422
msgid ""
"The compiler would reject the example since the compiler failed to find the "
"source file to check the consistency. So the following example would be "
"rejected too."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:431
msgid ""
"The compiler would reject it too since the compiler detected the file was "
"changed."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:433
msgid "But it is OK to move the BMI as long as the source files remain:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:442
msgid "The above example would be accepted."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:444
msgid ""
"If the user doesn't want to follow the consistency requirement due to some "
"reasons (e.g., distributing BMI), the user could try to use ``-Xclang -"
"fmodules-embed-all-files`` when producing BMI. For example:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:453
msgid ""
"Now the compiler would accept the above example. Important note: Xclang "
"options are intended to be used by compiler internally and its semantics are "
"not guaranteed to be preserved in future versions."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:457
msgid ""
"Also the compiler will record the path to the header files included in the "
"global module fragment and compare the headers when imported. For example,"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:480
msgid ""
"Then it is problematic if we remove ``foo.h`` before import `foo` module."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:489
msgid ""
"The above case will rejected. And we're still able to workaround it by ``-"
"Xclang -fmodules-embed-all-files`` option:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:499
msgid "ABI Impacts"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:501
msgid ""
"The declarations in a module unit which are not in the global module "
"fragment have new linkage names."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:503
msgid "For example,"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:512
msgid ""
"The linkage name of ``NS::foo()`` would be ``_ZN2NSW1M3fooEv``. This "
"couldn't be demangled by previous versions of the debugger or demangler. As "
"of LLVM 15.x, users can utilize ``llvm-cxxfilt`` to demangle this:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:520
msgid ""
"The result would be ``NS::foo@M()``, which reads as ``NS::foo()`` in module "
"``M``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:522
msgid ""
"The ABI implies that we can't declare something in a module unit and define "
"it in a non-module unit (or vice-versa), as this would result in linking "
"errors."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:526
msgid "Known Problems"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:528
msgid ""
"The following describes issues in the current implementation of modules. "
"Please see https://github.com/llvm/llvm-project/labels/clang%3Amodules for "
"more issues or file a new issue if you don't find an existing one. If you're "
"going to create a new issue for standard C++ modules, please start the title "
"with ``[C++20] [Modules]`` (or ``[C++2b] [Modules]``, etc) and add the label "
"``clang:modules`` (if you have permissions for that)."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:535
msgid ""
"For higher level support for proposals, you could visit https://clang.llvm."
"org/cxx_status.html."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:538
msgid "Support for clang-scan-deps"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:540
msgid ""
"The support for clang-scan-deps may be the most urgent problem for modules "
"now. Without the support for clang-scan-deps, it's hard to involve build "
"systems. This means that users could only play with modules through "
"makefiles or by writing a parser by hand. It blocks more uses for modules, "
"which will block more defect reports or requirements."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:545
msgid "This is tracked in: https://github.com/llvm/llvm-project/issues/51792."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:548
msgid "Ambiguous deduction guide"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:550
msgid ""
"Currently, when we call deduction guides in global module fragment, we may "
"get incorrect diagnosing message like: `ambiguous deduction`."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:553
msgid ""
"So if we're using deduction guide from global module fragment, we probably "
"need to write:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:559
msgid "instead of"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:565
msgid "This is tracked in: https://github.com/llvm/llvm-project/issues/56916"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:568
msgid "Ignored PreferredName Attribute"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:570
msgid ""
"Due to a tricky problem, when Clang writes BMIs, Clang will ignore the "
"``preferred_name`` attribute, if any. This implies that the "
"``preferred_name`` wouldn't show in debugger or dumping."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:573
msgid "This is tracked in: https://github.com/llvm/llvm-project/issues/56490"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:576
msgid "Don't emit macros about module declaration"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:578
msgid ""
"This is covered by P1857R3. We mention it again here since users may abuse "
"it before we implement it."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:580
msgid ""
"Someone may want to write code which could be compiled both by modules or "
"non-modules. A direct idea would be use macros like:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:591
msgid ""
"So this file could be triggered like a module unit or a non-module unit "
"depending on the definition of some macros. However, this kind of usage is "
"forbidden by P1857R3 but we haven't implemented P1857R3 yet. This means that "
"is possible to write illegal modules code now, and obviously this will stop "
"working once P1857R3 is implemented. A simple suggestion would be \"Don't "
"play macro tricks with module declarations\"."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:598
msgid "This is tracked in: https://github.com/llvm/llvm-project/issues/56917"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:601
msgid "In consistent filename suffix requirement for importable module units"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:603
msgid ""
"Currently, clang requires the file name of an ``importable module unit`` "
"should end with ``.cppm`` (or ``.ccm``, ``.cxxm``, ``.c++m``). However, the "
"behavior is inconsistent with other compilers."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:606
msgid "This is tracked in: https://github.com/llvm/llvm-project/issues/57416"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:609
msgid "Header Units"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:612
msgid "How to build projects using header unit"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:617
msgid "For the following example,"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:626
msgid "we could compile it as"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:634
msgid "How to produce BMIs"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:636
msgid ""
"Similar to named modules, we could use ``--precompile`` to produce the BMI. "
"But we need to specify that the input file is a header by ``-xc++-system-"
"header`` or ``-xc++-user-header``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:639
msgid ""
"Also we could use `-fmodule-header={user,system}` option to produce the BMI "
"for header units which has suffix like `.h` or `.hh`. The value of `-fmodule-"
"header` means the user search path or the system search path. The default "
"value for `-fmodule-header` is `user`. For example,"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:659
msgid "We could compile it as:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:666
msgid ""
"For headers which don't have a suffix, we need to pass ``-xc++-header`` (or "
"``-xc++-system-header`` or ``-xc++-user-header``) to mark it as a header. "
"For example,"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:686
msgid ""
"We could use ``-fmodule-file`` to specify the BMIs, and this option may "
"occur multiple times as well."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:688
msgid ""
"With the existing implementation ``-fprebuilt-module-path`` cannot be used "
"for header units (since they are nominally anonymous). For header units, "
"use  ``-fmodule-file`` to include the relevant PCM file for each header unit."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:692
msgid ""
"This is expect to be solved in future editions of the compiler either by the "
"tooling finding and specifying the -fmodule-file or by the use of a module-"
"mapper that understands how to map the header name to their PCMs."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:696
msgid "Don't compile the BMI"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:698
msgid ""
"Another difference with modules is that we can't compile the BMI from a "
"header unit. For example:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:707
msgid ""
"It makes sense due to the semantics of header units, which are just like "
"headers."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:710
msgid "Include translation"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:712
msgid ""
"The C++ spec allows the vendors to convert ``#include header-name`` to "
"``import header-name;`` when possible. Currently, Clang would do this "
"translation for the ``#include`` in the global module fragment."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:715
msgid "For example, the following two examples are the same:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:726
msgid "with the following one:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:742
msgid ""
"In the latter example, the Clang could find the BMI for the ``<iostream>`` "
"so it would try to replace the ``#include <iostream>`` to ``import "
"<iostream>;`` automatically."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:747
msgid "Relationships between Clang modules"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:749
msgid ""
"Header units have pretty similar semantics with Clang modules. The semantics "
"of both of them are like headers."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:752
msgid ""
"In fact, we could even \"mimic\" the sytle of header units by Clang modules:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:765
msgid "It would be simpler if we are using libcxx:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:771
msgid ""
"Since there is already one `module map <https://github.com/llvm/llvm-project/"
"blob/main/libcxx/include/module.modulemap.in>`_ in the source of libcxx."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:775
msgid ""
"Then immediately leads to the question: why don't we implement header units "
"through Clang header modules?"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:777
msgid ""
"The main reason for this is that Clang modules have more semantics like "
"hierarchy or wrapping multiple headers together as a big module. However, "
"these things are not part of Standard C++ Header units, and we want to avoid "
"the impression that these additional semantics get interpreted as Standard C+"
"+ behavior."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:782
msgid ""
"Another reason is that there are proposals to introduce module mappers to "
"the C++ standard (for example, https://wg21.link/p1184r2). If we decide to "
"reuse Clang's modulemap, we may get in trouble once we need to introduce "
"another module mapper."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:786
msgid ""
"So the final answer for why we don't reuse the interface of Clang modules "
"for header units is that there are some differences between header units and "
"Clang modules and that ignoring those differences now would likely become a "
"problem in the future."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:791
msgid "Possible Questions"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:794
msgid "How modules speed up compilation"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:796
msgid ""
"A classic theory for the reason why modules speed up the compilation is: if "
"there are ``n`` headers and ``m`` source files and each header is included "
"by each source file, then the complexity of the compilation is ``O(n*m)``; "
"But if there are ``n`` module interfaces and ``m`` source files, the "
"complexity of the compilation is ``O(n+m)``. So, using modules would be a "
"big win when scaling. In a simpler word, we could get rid of many redundant "
"compilations by using modules."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:803
msgid ""
"Roughly, this theory is correct. But the problem is that it is too rough. "
"The behavior depends on the optimization level, as we will illustrate below."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:806
msgid ""
"First is ``O0``. The compilation process is described in the following graph."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:828
msgid ""
"Here we can see that the source file (could be a non-module unit or a module "
"unit) would get processed by the whole pipeline. But the imported code would "
"only get involved in semantic analysis, which is mainly about name lookup, "
"overload resolution and template instantiation. All of these processes are "
"fast relative to the whole compilation process. More importantly, the "
"imported code only needs to be processed once in frontend code generation, "
"as well as the whole middle end and backend. So we could get a big win for "
"the compilation time in O0."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:837
msgid "But with optimizations, things are different:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:839
msgid ""
"(we omit ``code generation`` part for each end due to the limited space)"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:860
msgid ""
"It would be very unfortunate if we end up with worse performance after using "
"modules. The main concern is that when we compile a source file, the "
"compiler needs to see the function body of imported module units so that it "
"can perform IPO (InterProcedural Optimization, primarily inlining in "
"practice) to optimize functions in current source file with the help of the "
"information provided by the imported module units. In other words, the "
"imported code would be processed again and again in importee units by "
"optimizations (including IPO itself). The optimizations before IPO and the "
"IPO itself are the most time-consuming part in whole compilation process. So "
"from this perspective, we might not be able to get the improvements "
"described in the theory. But we could still save the time for optimizations "
"after IPO and the whole backend."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:871
msgid ""
"Overall, at ``O0`` the implementations of functions defined in a module will "
"not impact module users, but at higher optimization levels the definitions "
"of such functions are provided to user compilations for the purposes of "
"optimization (but definitions of these functions are still not included in "
"the use's object file)- this means the build speedup at higher optimization "
"levels may be lower than expected given ``O0`` experience, but does provide "
"by more optimization opportunities."
msgstr ""
