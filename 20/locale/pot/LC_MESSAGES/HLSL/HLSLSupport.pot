# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2025, The Clang Team
# This file is distributed under the same license as the Clang package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Clang 20\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-13 13:41+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../HLSL/HLSLSupport.rst:3
msgid "HLSL Support"
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:9
msgid "Introduction"
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:11
msgid ""
"HLSL Support is under active development in the Clang codebase. This "
"document describes the high level goals of the project, the guiding "
"principles, as well as some idiosyncrasies of the HLSL language and how we "
"intend to support them in Clang."
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:17
msgid "Project Goals"
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:19
msgid ""
"The long term goal of this project is to enable Clang to function as a "
"replacement for the `DirectXShaderCompiler (DXC) <https://github.com/"
"microsoft/DirectXShaderCompiler/>`_ in all its supported use cases. "
"Accomplishing that goal will require Clang to be able to process most "
"existing HLSL programs with a high degree of source compatibility."
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:26
msgid "Non-Goals"
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:28
msgid ""
"HLSL ASTs do not need to be compatible between DXC and Clang. We do not "
"expect identical code generation or that features will resemble DXC's "
"implementation or architecture. In fact, we explicitly expect to deviate "
"from DXC's implementation in key ways."
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:34
msgid "Guiding Principles"
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:36
msgid ""
"This document lacks details for architectural decisions that are not yet "
"finalized. Our top priorities are quality, maintainability, and flexibility. "
"In accordance with community standards we are expecting a high level of test "
"coverage, and we will engineer our solutions with long term maintenance in "
"mind. We are also working to limit modifications to the Clang C++ code paths "
"and share as much functionality as possible."
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:44
msgid "Architectural Direction"
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:46
msgid ""
"HLSL support in Clang is expressed as C++ minus unsupported C and C++ "
"features. This is different from how other Clang languages are implemented. "
"Most languages in Clang are additive on top of C."
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:50
msgid ""
"HLSL is not a formally or fully specified language, and while our goals "
"require a high level of source compatibility, implementations can vary and "
"we have some flexibility to be more or less permissive in some cases. For "
"modern HLSL DXC is the reference implementation."
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:55
msgid ""
"The HLSL effort prioritizes following similar patterns for other languages, "
"drivers, runtimes and targets. Specifically, We will maintain separation "
"between HSLS-specific code and the rest of Clang as much as possible "
"following patterns in use in Clang code today (i.e. ParseHLSL.cpp, SemaHLSL."
"cpp, CGHLSL*.cpp...). We will use inline checks on language options where "
"the code is simple and isolated, and prefer HLSL-specific implementation "
"files for any code of reasonable complexity."
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:63
msgid ""
"In places where the HLSL language is in conflict with C and C++, we will "
"seek to make minimally invasive changes guarded under the HLSL language "
"options. We will seek to make HLSL language support as minimal a maintenance "
"burden as possible."
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:68
msgid "DXC Driver"
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:70
msgid ""
"A DXC driver mode will provide command-line compatibility with DXC, "
"supporting DXC's options and flags. The DXC driver is HLSL-specific and will "
"create an HLSLToolchain which will provide the basis to support targeting "
"both DirectX and Vulkan."
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:76
msgid "Parser"
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:78
msgid ""
"Following the examples of other parser extensions HLSL will add a ParseHLSL."
"cpp file to contain the implementations of HLSL-specific extensions to the "
"Clang parser. The HLSL grammar shares most of its structure with C and C++, "
"so we will use the existing C/C++ parsing code paths."
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:84
msgid "Sema"
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:86
msgid ""
"HLSL's Sema implementation will also provide an ``ExternalSemaSource``. In "
"DXC, an ``ExternalSemaSource`` is used to provide definitions for HLSL built-"
"in data types and built-in templates. Clang is already designed to allow an "
"attached ``ExternalSemaSource`` to lazily complete data types, which is a "
"**huge** performance win for HLSL."
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:92
msgid ""
"If precompiled headers are used when compiling HLSL, the "
"``ExternalSemaSource`` will be a ``MultiplexExternalSemaSource`` which "
"includes both the ``ASTReader`` and -. For Built-in declarations that are "
"already completed in the serialized AST, the ``HLSLExternalSemaSource`` will "
"reuse the existing declarations and not introduce new declarations. If the "
"built-in types are not completed in the serialized AST, the "
"``HLSLExternalSemaSource`` will create new declarations and connect the de-"
"serialized decls as the previous declaration."
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:102
msgid "CodeGen"
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:104
msgid ""
"Like OpenCL, HLSL relies on capturing a lot of information into IR metadata. "
"*hand wave* *hand wave* *hand wave* As a design principle here we want our "
"IR to be idiomatic Clang IR as much as possible. We will use IR attributes "
"wherever we can, and use metadata as sparingly as possible. One example of a "
"difference from DXC already implemented in Clang is the use of target "
"triples to communicate shader model versions and shader stages."
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:111
msgid ""
"Our HLSL CodeGen implementation should also have an eye toward generating IR "
"that will map directly to targets other than DXIL. While IR itself is "
"generally not re-targetable, we want to share the Clang CodeGen "
"implementation for HLSL with other GPU graphics targets like SPIR-V and "
"possibly other GPU and even CPU targets."
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:118
msgid "hlsl.h"
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:120
msgid ""
"HLSL has a library of standalone functions. This is similar to OpenCL and "
"CUDA, and is analogous to C's standard library. The implementation approach "
"for the HLSL library functionality draws from patterns in use by OpenCL and "
"other Clang resource headers. All of the clang resource headers are part of "
"the ``ClangHeaders`` component found in the source tree under `clang/lib/"
"Headers <https://github.com/llvm/llvm-project/tree/main/clang/lib/Headers>`_."
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:129
msgid ""
"HLSL's complex data types are not defined in HLSL's header because many of "
"the semantics of those data types cannot be expressed in HLSL due to missing "
"language features. Data types that can't be expressed in HLSL are defined in "
"code in the ``HLSLExternalSemaSource``."
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:134
msgid ""
"Similar to OpenCL, the HLSL library functionality is implicitly declared in "
"translation units without needing to include a header to provide "
"declarations. In Clang this is handled by making ``hlsl.h`` an implicitly "
"included header distributed as part of the Clang resource directory."
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:139
msgid ""
"Similar to OpenCL, HLSL's implicit header will explicitly declare all "
"overloads, and each overload will map to a corresponding ``__builtin*`` "
"compiler intrinsic that is handled in ClangCodeGen. CUDA uses a similar "
"pattern although many CUDA functions have full definitions in the included "
"headers which in turn call corresponding ``__builtin*`` compiler intrinsics. "
"By not having bodies HLSL avoids the need for the inliner to clean up and "
"inline large numbers of small library functions."
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:147
msgid ""
"HLSL's implicit headers also define some of HLSL's typedefs. This is "
"consistent with how the AVX vector header is implemented."
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:150
msgid ""
"Concerns have been expressed that this approach may result in slower compile "
"times than the approach DXC uses where library functions are treated more "
"like Clang ``__builtin*`` intrinsics. No real world use cases have been "
"identified where parsing is a significant compile-time overhead, but the "
"HLSL implicit headers can be compiled into a module for performance if "
"needed."
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:156
msgid ""
"Further, by treating these as functions rather than ``__builtin*`` compiler "
"intrinsics, the language behaviors are more consistent and aligned with user "
"expectation because normal overload resolution rules and implicit "
"conversions apply as expected."
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:161
msgid ""
"It is a feature of this design that clangd-powered \"go to declaration\" for "
"library functions will jump to a valid header declaration and all overloads "
"will be user readable."
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:166
msgid "HLSL Language"
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:168
msgid ""
"The HLSL language is insufficiently documented, and not formally specified. "
"Documentation is available on `Microsoft's website <https://docs.microsoft."
"com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl>`_. The language "
"syntax is similar enough to C and C++ that carefully written C and C++ code "
"is valid HLSL. HLSL has some key differences from C & C++ which we will need "
"to handle in Clang."
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:175
msgid ""
"HLSL is not a conforming or valid extension or superset of C or C++. The "
"language has key incompatibilities with C and C++, both syntactically and "
"semantically."
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:180
msgid "An Aside on GPU Languages"
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:182
msgid ""
"Due to HLSL being a GPU targeted language HLSL is a Single Program Multiple "
"Data (SPMD) language relying on the implicit parallelism provided by GPU "
"hardware. Some language features in HLSL enable programmers to take "
"advantage of the parallel nature of GPUs in a hardware abstracted language."
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:187
msgid ""
"HLSL also prohibits some features of C and C++ which can have catastrophic "
"performance or are not widely supportable on GPU hardware or drivers. As an "
"example, register spilling is often excessively expensive on GPUs, so HLSL "
"requires all functions to be inlined during code generation, and does not "
"support a runtime calling convention."
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:194
msgid "Pointers & References"
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:196
msgid ""
"HLSL does not support referring to values by address. Semantically all "
"variables are value-types and behave as such. HLSL disallows the pointer "
"dereference operators (unary ``*``, and ``->``), as well as the address of "
"operator (unary &). While HLSL disallows pointers and references in the "
"syntax, HLSL does use reference types in the AST, and we intend to use "
"pointer decay in the AST in the Clang implementation."
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:204
msgid "HLSL ``this`` Keyword"
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:206
msgid ""
"HLSL does support member functions, and (in HLSL 2021) limited operator "
"overloading. With member function support, HLSL also has a ``this`` keyword. "
"The ``this`` keyword is an example of one of the places where HLSL relies on "
"references in the AST, because ``this`` is a reference."
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:212
msgid "Bitshifts"
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:214
msgid ""
"In deviation from C, HLSL bitshifts are defined to mask the shift count by "
"the size of the type. In DXC, the semantics of LLVM IR were altered to "
"accommodate this, in Clang we intend to generate the mask explicitly in the "
"IR. In cases where the shift value is constant, this will be constant folded "
"appropriately, in other cases we can clean it up in the DXIL target."
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:221
msgid "Non-short Circuiting Logical Operators"
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:223
msgid ""
"In HLSL 2018 and earlier, HLSL supported logical operators (and the ternary "
"operator) on vector types. This behavior required that operators not short "
"circuit. The non-short circuiting behavior applies to all data types until "
"HLSL 2021. In HLSL 2021, logical and ternary operators do not support vector "
"types instead builtin functions ``and``, ``or`` and ``select`` are "
"available, and operators short circuit matching C behavior."
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:231
msgid "Precise Qualifier"
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:233
msgid ""
"HLSL has a ``precise`` qualifier that behaves unlike anything else in the C "
"language. The support for this qualifier in DXC is buggy, so our bar for "
"compatibility is low."
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:237
msgid ""
"The ``precise`` qualifier applies in the inverse direction from normal "
"qualifiers. Rather than signifying that the declaration containing "
"``precise`` qualifier be precise, it signifies that the operations "
"contributing to the declaration's value be ``precise``. Additionally, "
"``precise`` is a misnomer: values attributed as ``precise`` comply with "
"IEEE-754 floating point semantics, and are prevented from optimizations "
"which could decrease *or increase* precision."
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:246
msgid "Differences in Templates"
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:248
msgid ""
"HLSL uses templates to define builtin types and methods, but disallowed user-"
"defined templates until HLSL 2021. HLSL also allows omitting empty template "
"parameter lists when all template parameters are defaulted. This is an "
"ambiguous syntax in C++, but Clang detects the case and issues a diagnostic. "
"This makes supporting the case in Clang minimally invasive."
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:255
msgid "Vector Extensions"
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:257
msgid ""
"HLSL uses the OpenCL vector extensions, and also provides C++-style "
"constructors for vectors that are not supported by Clang."
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:261
msgid "Standard Library"
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:263
msgid ""
"HLSL does not support the C or C++ standard libraries. Like OpenCL, HLSL "
"describes its own library of built in types, complex data types, and "
"functions."
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:267
msgid "Unsupported C & C++ Features"
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:269
msgid ""
"HLSL does not support all features of C and C++. In implementing HLSL in "
"Clang use of some C and C++ features will produce diagnostics under HLSL, "
"and others will be supported as language extensions. In general, any C or C+"
"+ feature that can be supported by the DXIL and SPIR-V code generation "
"targets could be treated as a clang HLSL extension. Features that cannot be "
"lowered to DXIL or SPIR-V, must be diagnosed as errors."
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:276
msgid "HLSL does not support the following C features:"
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:278
msgid "Pointers"
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:279
msgid "References"
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:280
msgid "``goto`` or labels"
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:281
msgid "Variable Length Arrays"
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:282
msgid "``_Complex`` and ``_Imaginary``"
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:283
msgid "C Threads or Atomics (or Obj-C blocks)"
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:284
msgid ""
"``union`` types `(in progress for HLSL 202x) <https://github.com/microsoft/"
"DirectXShaderCompiler/pull/4132>`_"
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:285
msgid "Most features C11 and later"
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:287
msgid "HLSL does not support the following C++ features:"
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:289
msgid "RTTI"
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:290
msgid "Exceptions"
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:291
msgid "Multiple inheritance"
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:292
msgid "Access specifiers"
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:293
msgid "Anonymous or inline namespaces"
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:294
msgid ""
"``new`` & ``delete`` operators in all of their forms (array, placement, etc)"
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:295
msgid "Constructors and destructors"
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:296
msgid "Any use of the ``virtual`` keyword"
msgstr ""

#: ../../../HLSL/HLSLSupport.rst:297
msgid "Most features C++11 and later"
msgstr ""
