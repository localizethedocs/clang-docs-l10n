# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2025, The Clang Team
# This file is distributed under the same license as the Clang package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Clang 18\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-13 13:42+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../HLSL/FunctionCalls.rst:3
msgid "HLSL Function Calls"
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:9
msgid "Introduction"
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:11
msgid ""
"This document describes the design and implementation of HLSL's function "
"call semantics in Clang. This includes details related to argument "
"conversion and parameter lifetimes."
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:15
msgid ""
"This document does not seek to serve as official documentation for HLSL's "
"call semantics, but does provide an overview to assist a reader. The "
"authoritative documentation for HLSL's language semantics is the `draft "
"language specification <https://microsoft.github.io/hlsl-specs/specs/hlsl."
"pdf>`_."
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:21
msgid "Argument Semantics"
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:23
msgid ""
"In HLSL, all function arguments are passed by value in and out of functions. "
"HLSL has 3 keywords which denote the parameter semantics (``in``, ``out`` "
"and ``inout``). In a function declaration a parameter may be annotated any "
"of the following ways:"
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:28
msgid "<no parameter annotation> - denotes input"
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:29
msgid "``in`` - denotes input"
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:30
msgid "``out`` - denotes output"
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:31
msgid "``in out`` - denotes input and output"
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:32
msgid "``out in`` - denotes input and output"
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:33
msgid "``inout`` - denotes input and output"
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:35
msgid ""
"Parameters that are exclusively input behave like C/C++ parameters that are "
"passed by value."
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:38
msgid ""
"For parameters that are output (or input and output), a temporary value is "
"created in the caller. The temporary value is then passed by-address. For "
"output-only parameters, the temporary is uninitialized when passed (if the "
"parameter is not explicitly initialized inside the function an undefined "
"value is stored back to the argument expression). For parameters that are "
"both input and output, the temporary is initialized from the lvalue argument "
"expression through implicit  or explicit casting from the lvalue argument "
"type to the parameter type."
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:47
msgid ""
"On return of the function, the values of any parameter temporaries are "
"written back to the argument expression through an inverted conversion "
"sequence (if an ``out`` parameter was not initialized in the function, the "
"uninitialized value may be written back)."
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:52
msgid ""
"Parameters of constant-sized array type are also passed with value "
"semantics. This requires input parameters of arrays to construct temporaries "
"and the temporaries go through array-to-pointer decay when initializing "
"parameters."
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:56
msgid ""
"Implementations are allowed to avoid unnecessary temporaries, and HLSL's "
"strict no-alias rules can enable some trivial optimizations."
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:60 ../../../HLSL/FunctionCalls.rst:170
msgid "Array Temporaries"
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:62
msgid "Given the following example:"
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:76
msgid ""
"In C or C++, the array parameter decays to a pointer, so after the call to "
"``fn``, the value of ``arr[0]`` is ``3``. In HLSL, the array is passed by "
"value, so modifications inside ``fn`` do not propagate out."
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:82
msgid ""
"DXC may pass unsized arrays directly as decayed pointers, which is an "
"unfortunate behavior divergence."
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:86 ../../../HLSL/FunctionCalls.rst:243
msgid "Out Parameter Temporaries"
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:100
msgid ""
"In the above example the ``Init`` function's behavior depends on the C++ "
"implementation. C++ does not define the order in which parameters are "
"initialized or destroyed. In MSVC and Clang's MSVC compatibility mode, "
"arguments are emitted right-to-left and destroyed left-to-right. This means "
"that  the parameter initialization and destruction occurs in the order: "
"{``Y``, ``X``, ``~X``, ``~Y``}. This causes the write-back of the value of "
"``Y`` to occur last, so the resulting value of ``V`` is ``2``. In the "
"Itanium C++ ABI, the  parameter ordering is reversed, so the initialization "
"and destruction occurs in the order: {``X``, ``Y``, ``~Y``, ``X``}. This "
"causes the write-back of the value ``X`` to occur last, resulting in the "
"value of ``V`` being set to ``1``."
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:121
msgid ""
"In the above example, the argument expression ``F`` undergoes element-wise "
"conversion from a float vector to an integer vector to create a temporary "
"``int3``. On expiration the temporary undergoes elementwise conversion back "
"to the floating point vector type ``float3``. This results in an implicit "
"element-wise conversion of the vector even if the value is unused in the "
"function (effectively truncating the floating point values)."
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:138
msgid ""
"In this example an initialized value is passed to an ``out`` parameter. "
"Parameters marked ``out`` are not initialized by the argument expression or "
"implicitly by the function. They must be explicitly initialized. In this "
"case the argument is not initialized in the function so the temporary is "
"still uninitialized when it is copied back to the argument expression. This "
"is undefined behavior in HLSL, and any use of the argument after the call is "
"a use of an undefined value which may be illegal in the target (DXIL "
"programs with used or potentially used ``undef`` or ``poison`` values fail "
"validation)."
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:148
msgid "Clang Implementation"
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:152
msgid ""
"The implementation described here is a proposal. It has not yet been fully "
"implemented, so the current state of Clang's sources may not reflect this "
"design. A prototype implementation was built on DXC which is Clang-3.7 "
"based. The prototype can be found `here <https://github.com/microsoft/"
"DirectXShaderCompiler/pull/5249>`_. A lot of the changes in the prototype "
"implementation are restoring Clang-3.7 code that was previously modified to "
"its original state."
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:160
msgid ""
"The implementation in clang depends on two new AST nodes and minor "
"extensions to Clang's existing support for Objective-C write-back arguments. "
"The goal of this design is to capture the semantic details of HLSL function "
"calls in the AST, and minimize the amount of magic that needs to occur "
"during IR generation."
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:165
msgid ""
"The two new AST nodes are ``HLSLArrayTemporaryExpr`` and "
"``HLSLOutParamExpr``, which respectively represent the temporaries used for "
"passing arrays by value and the temporaries created for function outputs."
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:172
msgid ""
"The ``HLSLArrayTemporaryExpr`` represents temporary values for input "
"constant-sized array arguments. This applies for all constant-sized array "
"arguments regardless of whether or not the parameter is constant-sized or "
"unsized."
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:188
msgid ""
"In the example above, the following AST is generated for the call to "
"``SizedArray``:"
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:199
msgid ""
"In the example above, the following AST is generated for the call to "
"``UnsizedArray``:"
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:210
msgid ""
"In both of these cases the argument expression is of known array size so we "
"can initialize an appropriately sized temporary."
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:213
msgid "It is illegal in HLSL to convert an unsized array to a sized array:"
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:222
msgid ""
"When converting a sized array to an unsized array, an array temporary can "
"also be inserted. Given the following code:"
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:232
msgid "An expected AST should be something like:"
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:245
msgid ""
"Output parameters are defined in HLSL as *casting expiring values* (cx-"
"values), which is a term made up for HLSL. A cx-value is a temporary value "
"which may be the result of a cast, and stores its value back to an lvalue "
"when the value expires."
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:250
msgid ""
"To represent this concept in Clang we introduce a new ``HLSLOutParamExpr``. "
"An ``HLSLOutParamExpr`` has two forms, one with a single sub-expression and "
"one with two sub-expressions."
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:254
msgid ""
"The single sub-expression form is used when the argument expression and the "
"function parameter are the same type, so no cast is required. As in this "
"example:"
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:269
msgid "The expected AST formulation for this code would be something like:"
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:279
msgid ""
"The ``HLSLOutParamExpr`` captures that the value is ``inout`` vs ``out`` to "
"denote whether or not the temporary is initialized from the sub-expression. "
"If no casting is required the sub-expression denotes the lvalue expression "
"that the cx-value will be copied to when the value expires."
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:284
msgid ""
"The two sub-expression form of the AST node is required when the argument "
"type is not the same as the parameter type. Given this example:"
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:297
msgid ""
"For this case the ``HLSLOutParamExpr`` will have sub-expressions to record "
"both casting expression sequences for the initialization and write back:"
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:313
msgid ""
"In this formation the write-back casts are captured as the first sub-"
"expression and they cast from an ``OpaqueValueExpr``. In IR generation we "
"can use the ``OpaqueValueExpr`` as a placeholder for the "
"``HLSLOutParamExpr``'s temporary value on function return."
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:318
msgid ""
"In code generation this can be implemented with some targeted extensions to "
"the Objective-C write-back support. Specifically extending CGCall.cpp's "
"``EmitWriteback`` function to support casting expressions and emission of "
"aggregate lvalues."
msgstr ""
