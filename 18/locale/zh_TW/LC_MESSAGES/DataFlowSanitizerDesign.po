# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2025, The Clang Team
# This file is distributed under the same license as the Clang package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Clang 18\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-13 13:42+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../DataFlowSanitizerDesign.rst:2
msgid "DataFlowSanitizer Design Document"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:4
msgid ""
"This document sets out the design for DataFlowSanitizer, a general dynamic "
"data flow analysis.  Unlike other Sanitizer tools, this tool is not designed "
"to detect a specific class of bugs on its own. Instead, it provides a "
"generic dynamic data flow analysis framework to be used by clients to help "
"detect application-specific issues within their own code."
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:11
msgid ""
"DataFlowSanitizer is a program instrumentation which can associate a number "
"of taint labels with any data stored in any memory region accessible by the "
"program. The analysis is dynamic, which means that it operates on a running "
"program, and tracks how the labels propagate through that program."
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:18
msgid "Use Cases"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:20
msgid ""
"This instrumentation can be used as a tool to help monitor how data flows "
"from a program's inputs (sources) to its outputs (sinks). This has "
"applications from a privacy/security perspective in that one can audit how a "
"sensitive data item is used within a program and ensure it isn't exiting the "
"program anywhere it shouldn't be."
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:27
msgid "Interface"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:29
msgid ""
"A number of functions are provided which will attach taint labels to memory "
"regions and extract the set of labels associated with a specific memory "
"region. These functions are declared in the header file ``sanitizer/"
"dfsan_interface.h``."
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:68
msgid ""
"The following functions are provided to check origin tracking status and "
"results."
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:106
msgid ""
"The following functions are provided to register hooks called by custom "
"wrappers."
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:125
msgid "Taint label representation"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:127
msgid ""
"We use an 8-bit unsigned integer for the representation of a label. The "
"label identifier 0 is special, and means that the data item is unlabelled. "
"This is optimizing for low CPU and code size overhead of the "
"instrumentation. When a label union operation is requested at a join point "
"(any arithmetic or logical operation with two or more operands, such as "
"addition), we can simply OR the two labels in O(1)."
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:134
msgid ""
"Users are responsible for managing the 8 integer labels (i.e., keeping track "
"of what labels they have used so far, picking one that is yet unused, etc)."
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:139
msgid "Origin tracking trace representation"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:141
msgid ""
"An origin tracking trace is a list of chains. Each chain has a stack trace "
"where the DFSan runtime records a label propagation, and a pointer to its "
"previous chain. The very first chain does not point to any chain."
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:145
msgid ""
"Every four 4-bytes aligned application bytes share a 4-byte origin trace ID. "
"A 4-byte origin trace ID contains a 4-bit depth and a 28-bit hash ID of a "
"chain."
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:148
msgid ""
"A chain ID is calculated as a hash from a chain structure. A chain structure "
"contains a stack ID and the previous chain ID. The chain head has a zero "
"previous chain ID. A stack ID is a hash from a stack trace. The 4-bit depth "
"limits the maximal length of a path. The environment variable "
"``origin_history_size`` can set the depth limit. Non-positive values mean "
"unlimited. Its default value is 16. When reaching the limit, origin tracking "
"ignores following propagation chains."
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:156
msgid ""
"The first chain of a trace starts by `dfsan_set_label` with non-zero labels. "
"A new chain is appended at the end of a trace at stores or memory transfers "
"when ``-dfsan-track-origins`` is 1. Memory transfers include LLVM memory "
"transfer instructions, glibc memcpy and memmove. When ``-dfsan-track-"
"origins`` is 2, a new chain is also appended at loads."
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:162
msgid ""
"Other instructions do not create new chains, but simply propagate origin "
"trace IDs. If an instruction has more than one operands with non-zero "
"labels, the origin treace ID of the last operand with non-zero label is "
"propagated to the result of the instruction."
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:168
msgid "Memory layout and label management"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:170
msgid "The following is the memory layout for Linux/x86\\_64:"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:173
msgid "Start"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:173
msgid "End"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:173
msgid "Use"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:175
#: ../../../DataFlowSanitizerDesign.rst:177
msgid "0x700000000000"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:175
msgid "0x800000000000"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:175
msgid "application 3"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:177
#: ../../../DataFlowSanitizerDesign.rst:179
msgid "0x610000000000"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:177
#: ../../../DataFlowSanitizerDesign.rst:185
#: ../../../DataFlowSanitizerDesign.rst:193
msgid "unused"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:179
#: ../../../DataFlowSanitizerDesign.rst:181
msgid "0x600000000000"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:179
msgid "origin 1"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:181
#: ../../../DataFlowSanitizerDesign.rst:183
msgid "0x510000000000"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:181
msgid "application 2"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:183
#: ../../../DataFlowSanitizerDesign.rst:185
msgid "0x500000000000"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:183
msgid "shadow 1"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:185
#: ../../../DataFlowSanitizerDesign.rst:187
msgid "0x400000000000"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:187
#: ../../../DataFlowSanitizerDesign.rst:189
msgid "0x300000000000"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:187
msgid "origin 3"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:189
#: ../../../DataFlowSanitizerDesign.rst:191
msgid "0x200000000000"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:189
msgid "shadow 3"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:191
#: ../../../DataFlowSanitizerDesign.rst:193
msgid "0x110000000000"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:191
msgid "origin 2"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:193
#: ../../../DataFlowSanitizerDesign.rst:195
msgid "0x100000000000"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:195
#: ../../../DataFlowSanitizerDesign.rst:197
msgid "0x010000000000"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:195
msgid "shadow 2"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:197
msgid "0x000000000000"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:197
msgid "application 1"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:200
msgid ""
"Each byte of application memory corresponds to a single byte of shadow "
"memory, which is used to store its taint label. We map memory, shadow, and "
"origin regions to each other with these masks and offsets:"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:204
msgid "shadow_addr = memory_addr ^ 0x500000000000"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:206
msgid "origin_addr = shadow_addr + 0x100000000000"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:208
msgid ""
"As for LLVM SSA registers, we have not found it necessary to associate a "
"label with each byte or bit of data, as some other tools do. Instead, labels "
"are associated directly with registers.  Loads will result in a union of all "
"shadow labels corresponding to bytes loaded, and stores will result in a "
"copy of the label of the stored value to the shadow of all bytes stored to."
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:216
msgid "Propagating labels through arguments"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:218
msgid ""
"In order to propagate labels through function arguments and return values, "
"DataFlowSanitizer changes the ABI of each function in the translation unit. "
"There are currently two supported ABIs:"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:222
msgid ""
"Args -- Argument and return value labels are passed through additional "
"arguments and by modifying the return type."
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:225
msgid ""
"TLS -- Argument and return value labels are passed through TLS variables "
"``__dfsan_arg_tls`` and ``__dfsan_retval_tls``."
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:228
msgid ""
"The main advantage of the TLS ABI is that it is more tolerant of ABI "
"mismatches (TLS storage is not shared with any other form of storage, "
"whereas extra arguments may be stored in registers which under the native "
"ABI are not used for parameter passing and thus could contain arbitrary "
"values).  On the other hand the args ABI is more efficient and allows ABI "
"mismatches to be more easily identified by checking for nonzero labels in "
"nominally unlabelled programs."
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:236
msgid "Implementing the ABI list"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:238
msgid ""
"The `ABI list <DataFlowSanitizer.html#abi-list>`_ provides a list of "
"functions which conform to the native ABI, each of which is callable from an "
"instrumented program.  This is implemented by replacing each reference to a "
"native ABI function with a reference to a function which uses the "
"instrumented ABI. Such functions are automatically-generated wrappers for "
"the native functions. For example, given the ABI list example provided in "
"the user manual, the following wrappers will be generated under the args ABI:"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:274
msgid ""
"As an optimization, direct calls to native ABI functions will call the "
"native ABI function directly and the pass will compute the appropriate label "
"internally.  This has the advantage of reducing the number of union "
"operations required when the return value label is known to be zero (i.e. "
"``discard`` functions, or ``functional`` functions with known unlabelled "
"arguments)."
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:281
msgid "Checking ABI Consistency"
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:283
msgid ""
"DFSan changes the ABI of each function in the module.  This makes it "
"possible for a function with the native ABI to be called with the "
"instrumented ABI, or vice versa, thus possibly invoking undefined behavior.  "
"A simple way of statically detecting instances of this problem is to append "
"the suffix \".dfsan\" to the name of each instrumented-ABI function."
msgstr ""

#: ../../../DataFlowSanitizerDesign.rst:289
msgid ""
"This will not catch every such problem; in particular function pointers "
"passed across the instrumented-native barrier cannot be used on the other "
"side. These problems could potentially be caught dynamically."
msgstr ""
