# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2025, The Clang Team
# This file is distributed under the same license as the Clang package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Clang 21\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-13 13:42+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../HLSL/FunctionCalls.rst:3
msgid "HLSL Function Calls"
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:9
msgid "Introduction"
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:11
msgid ""
"This document describes the design and implementation of HLSL's function "
"call semantics in Clang. This includes details related to argument "
"conversion and parameter lifetimes."
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:15
msgid ""
"This document does not seek to serve as official documentation for HLSL's "
"call semantics, but does provide an overview to assist a reader. The "
"authoritative documentation for HLSL's language semantics is the `draft "
"language specification <https://microsoft.github.io/hlsl-specs/specs/hlsl."
"pdf>`_."
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:21
msgid "Argument Semantics"
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:23
msgid ""
"In HLSL, all function arguments are passed by value in and out of functions. "
"HLSL has 3 keywords which denote the parameter semantics (``in``, ``out`` "
"and ``inout``). In a function declaration a parameter may be annotated any "
"of the following ways:"
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:28
msgid "<no parameter annotation> - denotes input"
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:29
msgid "``in`` - denotes input"
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:30
msgid "``out`` - denotes output"
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:31
msgid "``in out`` - denotes input and output"
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:32
msgid "``out in`` - denotes input and output"
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:33
msgid "``inout`` - denotes input and output"
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:35
msgid ""
"Parameters that are exclusively input behave like C/C++ parameters that are "
"passed by value."
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:38
msgid ""
"For parameters that are output (or input and output), a temporary value is "
"created in the caller. The temporary value is then passed by-address. For "
"output-only parameters, the temporary is uninitialized when passed (if the "
"parameter is not explicitly initialized inside the function an undefined "
"value is stored back to the argument expression). For parameters that are "
"both input and output, the temporary is initialized from the lvalue argument "
"expression through implicit  or explicit casting from the lvalue argument "
"type to the parameter type."
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:47
msgid ""
"On return of the function, the values of any parameter temporaries are "
"written back to the argument expression through an inverted conversion "
"sequence (if an ``out`` parameter was not initialized in the function, the "
"uninitialized value may be written back)."
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:52
msgid ""
"Parameters of constant-sized array type are also passed with value "
"semantics. This requires input parameters of arrays to construct temporaries "
"and the temporaries go through array-to-pointer decay when initializing "
"parameters."
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:56
msgid ""
"Implementations are allowed to avoid unnecessary temporaries, and HLSL's "
"strict no-alias rules can enable some trivial optimizations."
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:60 ../../../HLSL/FunctionCalls.rst:167
msgid "Array Temporaries"
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:62
msgid "Given the following example:"
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:76
msgid ""
"In C or C++, the array parameter decays to a pointer, so after the call to "
"``fn``, the value of ``arr[0]`` is ``3``. In HLSL, the array is passed by "
"value, so modifications inside ``fn`` do not propagate out."
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:82
msgid ""
"DXC may pass unsized arrays directly as decayed pointers, which is an "
"unfortunate behavior divergence."
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:86 ../../../HLSL/FunctionCalls.rst:244
msgid "Out Parameter Temporaries"
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:100
msgid ""
"In the above example the ``Init`` function's behavior depends on the C++ "
"implementation. C++ does not define the order in which parameters are "
"initialized or destroyed. In MSVC and Clang's MSVC compatibility mode, "
"arguments are emitted right-to-left and destroyed left-to-right. This means "
"that  the parameter initialization and destruction occurs in the order: "
"{``Y``, ``X``, ``~X``, ``~Y``}. This causes the write-back of the value of "
"``Y`` to occur last, so the resulting value of ``V`` is ``2``. In the "
"Itanium C++ ABI, the  parameter ordering is reversed, so the initialization "
"and destruction occurs in the order: {``X``, ``Y``, ``~Y``, ``X``}. This "
"causes the write-back of the value ``X`` to occur last, resulting in the "
"value of ``V`` being set to ``1``."
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:121
msgid ""
"In the above example, the argument expression ``F`` undergoes element-wise "
"conversion from a float vector to an integer vector to create a temporary "
"``int3``. On expiration the temporary undergoes elementwise conversion back "
"to the floating point vector type ``float3``. This results in an implicit "
"element-wise conversion of the vector even if the value is unused in the "
"function (effectively truncating the floating point values)."
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:138
msgid ""
"In this example an initialized value is passed to an ``out`` parameter. "
"Parameters marked ``out`` are not initialized by the argument expression or "
"implicitly by the function. They must be explicitly initialized. In this "
"case the argument is not initialized in the function so the temporary is "
"still uninitialized when it is copied back to the argument expression. This "
"is undefined behavior in HLSL, and any use of the argument after the call is "
"a use of an undefined value which may be illegal in the target (DXIL "
"programs with used or potentially used ``undef`` or ``poison`` values fail "
"validation)."
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:148
msgid "Clang Implementation"
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:152
msgid ""
"The implementation described here is a proposal. It has not yet been fully "
"implemented, so the current state of Clang's sources may not reflect this "
"design. A prototype implementation was built on DXC which is Clang-3.7 "
"based. The prototype can be found `here <https://github.com/microsoft/"
"DirectXShaderCompiler/pull/5249>`_. A lot of the changes in the prototype "
"implementation are restoring Clang-3.7 code that was previously modified to "
"its original state."
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:160
msgid ""
"The implementation in clang adds a new non-decaying array type, a new AST "
"node to represent output parameters, and minor extensions to Clang's "
"existing support for Objective-C write-back arguments. The goal of this "
"design is to capture the semantic details of HLSL function calls in the AST, "
"and minimize the amount of magic that needs to occur during IR generation."
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:169
msgid ""
"The new ``ArrayParameterType`` is a sub-class of ``ConstantArrayType`` "
"inheriting all the behaviors and methods of the parent except that it does "
"not decay to a pointer during overload resolution or template type deduction."
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:173
msgid ""
"An argument of ``ConstantArrayType`` can be implicitly converted to an "
"equivalent non-decayed ``ArrayParameterType`` if the underlying canonical "
"``ConstantArrayType`` is the same. This occurs during overload resolution "
"instead of array to pointer decay."
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:189
msgid ""
"In the example above, the following AST is generated for the call to "
"``SizedArray``:"
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:200
msgid ""
"In the example above, the following AST is generated for the call to "
"``UnsizedArray``:"
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:211
msgid ""
"In both of these cases the argument expression is of known array size so we "
"can initialize an appropriately sized temporary."
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:214
msgid "It is illegal in HLSL to convert an unsized array to a sized array:"
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:223
msgid ""
"When converting a sized array to an unsized array, an array temporary can "
"also be inserted. Given the following code:"
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:233
msgid "An expected AST should be something like:"
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:246
msgid ""
"Output parameters are defined in HLSL as *casting expiring values* (cx-"
"values), which is a term made up for HLSL. A cx-value is a temporary value "
"which may be the result of a cast, and stores its value back to an lvalue "
"when the value expires."
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:251
msgid ""
"To represent this concept in Clang we introduce a new ``HLSLOutArgExpr``. An "
"``HLSLOutArgExpr`` has three sub-expressions:"
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:254
msgid "An OpaqueValueExpr of the argument lvalue expression."
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:255
msgid "An OpaqueValueExpr of the copy-initialized parameter temporary."
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:256
msgid "A BinaryOpExpr assigning the first with the value of the second."
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:258
msgid "Given this example:"
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:271
msgid ""
"The expected AST formulation for this code would be something like the "
"example below. Due to the nature of OpaqueValueExpr nodes, the nodes repeat "
"in the AST dump. The fake addresses ``0xSOURCE`` and ``0xTEMPORARY`` denote "
"the source lvalue and argument temporary lvalue expressions."
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:297
msgid ""
"The ``HLSLOutArgExpr`` captures that the value is ``inout`` vs ``out`` to "
"denote whether or not the temporary is initialized from the sub-expression."
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:300
msgid "The example below demonstrates argument casting:"
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:312
msgid ""
"For this case the ``HLSLOutArgExpr`` will have sub-expressions to record "
"both casting expression sequences for the initialization and write back:"
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:339
msgid ""
"The AST representation is the same whether casting is required or not, which "
"simplifies the code generation. IR generation does the following:"
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:342
msgid "Emit the argument lvalue expression."
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:343
msgid ""
"Initialize the argument: * For ``inout`` arguments, emit the copy-"
"initialization expression. * For ``out`` arguments, emit an uninitialized "
"temporary."
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:346
msgid "Emit the call"
msgstr ""

#: ../../../HLSL/FunctionCalls.rst:347
msgid "Emit the write-back BinaryOperator expression."
msgstr ""
