# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2025, The Clang Team
# This file is distributed under the same license as the Clang package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Clang 11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-13 13:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../ObjectiveCLiterals.rst:3
msgid "Objective-C Literals"
msgstr ""

#: ../../../ObjectiveCLiterals.rst:6
msgid "Introduction"
msgstr "簡介"

#: ../../../ObjectiveCLiterals.rst:8
msgid ""
"Three new features were introduced into clang at the same time: *NSNumber "
"Literals* provide a syntax for creating ``NSNumber`` from scalar literal "
"expressions; *Collection Literals* provide a short-hand for creating arrays "
"and dictionaries; *Object Subscripting* provides a way to use subscripting "
"with Objective-C objects. Users of Apple compiler releases can use these "
"features starting with the Apple LLVM Compiler 4.0. Users of open-source "
"LLVM.org compiler releases can use these features starting with clang v3.1."
msgstr ""

#: ../../../ObjectiveCLiterals.rst:17
msgid ""
"These language additions simplify common Objective-C programming patterns, "
"make programs more concise, and improve the safety of container creation."
msgstr ""

#: ../../../ObjectiveCLiterals.rst:21
msgid ""
"This document describes how the features are implemented in clang, and how "
"to use them in your own programs."
msgstr ""

#: ../../../ObjectiveCLiterals.rst:25
msgid "NSNumber Literals"
msgstr ""

#: ../../../ObjectiveCLiterals.rst:27
msgid ""
"The framework class ``NSNumber`` is used to wrap scalar values inside "
"objects: signed and unsigned integers (``char``, ``short``, ``int``, "
"``long``, ``long long``), floating point numbers (``float``, ``double``), "
"and boolean values (``BOOL``, C++ ``bool``). Scalar values wrapped in "
"objects are also known as *boxed* values."
msgstr ""

#: ../../../ObjectiveCLiterals.rst:33
msgid ""
"In Objective-C, any character, numeric or boolean literal prefixed with the "
"``'@'`` character will evaluate to a pointer to an ``NSNumber`` object "
"initialized with that value. C's type suffixes may be used to control the "
"size of numeric literals."
msgstr ""

#: ../../../ObjectiveCLiterals.rst:39 ../../../ObjectiveCLiterals.rst:270
#: ../../../ObjectiveCLiterals.rst:324
msgid "Examples"
msgstr "範例"

#: ../../../ObjectiveCLiterals.rst:41
msgid "The following program illustrates the rules for ``NSNumber`` literals:"
msgstr ""

#: ../../../ObjectiveCLiterals.rst:70 ../../../ObjectiveCLiterals.rst:299
#: ../../../ObjectiveCLiterals.rst:452
msgid "Discussion"
msgstr ""

#: ../../../ObjectiveCLiterals.rst:72
msgid ""
"NSNumber literals only support literal scalar values after the ``'@'``. "
"Consequently, ``@INT_MAX`` works, but ``@INT_MIN`` does not, because they "
"are defined like this:"
msgstr ""

#: ../../../ObjectiveCLiterals.rst:81
msgid ""
"The definition of ``INT_MIN`` is not a simple literal, but a parenthesized "
"expression. Parenthesized expressions are supported using the `boxed "
"expression <#objc_boxed_expressions>`_ syntax, which is described in the "
"next section."
msgstr ""

#: ../../../ObjectiveCLiterals.rst:86
msgid ""
"Because ``NSNumber`` does not currently support wrapping ``long double`` "
"values, the use of a ``long double NSNumber`` literal (e.g. ``@123.23L``) "
"will be rejected by the compiler."
msgstr ""

#: ../../../ObjectiveCLiterals.rst:90
msgid ""
"Previously, the ``BOOL`` type was simply a typedef for ``signed char``, and "
"``YES`` and ``NO`` were macros that expand to ``(BOOL)1`` and ``(BOOL)0`` "
"respectively. To support ``@YES`` and ``@NO`` expressions, these macros are "
"now defined using new language keywords in ``<objc/objc.h>``:"
msgstr ""

#: ../../../ObjectiveCLiterals.rst:106
msgid ""
"The compiler implicitly converts ``__objc_yes`` and ``__objc_no`` to "
"``(BOOL)1`` and ``(BOOL)0``. The keywords are used to disambiguate ``BOOL`` "
"and integer literals."
msgstr ""

#: ../../../ObjectiveCLiterals.rst:110
msgid ""
"Objective-C++ also supports ``@true`` and ``@false`` expressions, which are "
"equivalent to ``@YES`` and ``@NO``."
msgstr ""

#: ../../../ObjectiveCLiterals.rst:114
msgid "Boxed Expressions"
msgstr ""

#: ../../../ObjectiveCLiterals.rst:116
msgid "Objective-C provides a new syntax for boxing C expressions:"
msgstr ""

#: ../../../ObjectiveCLiterals.rst:122
msgid ""
"Expressions of scalar (numeric, enumerated, BOOL), C string pointer and some "
"C structures (via NSValue) are supported:"
msgstr ""

#: ../../../ObjectiveCLiterals.rst:146
msgid "Boxed Enums"
msgstr ""

#: ../../../ObjectiveCLiterals.rst:148
msgid ""
"Cocoa frameworks frequently define constant values using *enums.* Although "
"enum values are integral, they may not be used directly as boxed literals "
"(this avoids conflicts with future ``'@'``-prefixed Objective-C keywords). "
"Instead, an enum value must be placed inside a boxed expression. The "
"following example demonstrates configuring an ``AVAudioRecorder`` using a "
"dictionary that contains a boxed enumeration value:"
msgstr ""

#: ../../../ObjectiveCLiterals.rst:171
msgid ""
"The expression ``@(AVAudioQualityMax)`` converts ``AVAudioQualityMax`` to an "
"integer type, and boxes the value accordingly. If the enum has a :ref:`fixed "
"underlying type <objc-fixed-enum>` as in:"
msgstr ""

#: ../../../ObjectiveCLiterals.rst:180
msgid ""
"then the fixed underlying type will be used to select the correct "
"``NSNumber`` creation method."
msgstr ""

#: ../../../ObjectiveCLiterals.rst:183
msgid ""
"Boxing a value of enum type will result in a ``NSNumber`` pointer with a "
"creation method according to the underlying type of the enum, which can be "
"a :ref:`fixed underlying type <objc-fixed-enum>` or a compiler-defined "
"integer type capable of representing the values of all the members of the "
"enumeration:"
msgstr ""

#: ../../../ObjectiveCLiterals.rst:196
msgid "Boxed C Strings"
msgstr ""

#: ../../../ObjectiveCLiterals.rst:198
msgid ""
"A C string literal prefixed by the ``'@'`` token denotes an ``NSString`` "
"literal in the same way a numeric literal prefixed by the ``'@'`` token "
"denotes an ``NSNumber`` literal. When the type of the parenthesized "
"expression is ``(char *)`` or ``(const char *)``, the result of the boxed "
"expression is a pointer to an ``NSString`` object containing equivalent "
"character data, which is assumed to be '\\\\0'-terminated and UTF-8 encoded. "
"The following example converts C-style command line arguments into "
"``NSString`` objects."
msgstr ""

#: ../../../ObjectiveCLiterals.rst:221
msgid ""
"As with all C pointers, character pointer expressions can involve arbitrary "
"pointer arithmetic, therefore programmers must ensure that the character "
"data is valid. Passing ``NULL`` as the character pointer will raise an "
"exception at runtime. When possible, the compiler will reject ``NULL`` "
"character pointers used in boxed expressions."
msgstr ""

#: ../../../ObjectiveCLiterals.rst:228
msgid "Boxed C Structures"
msgstr ""

#: ../../../ObjectiveCLiterals.rst:230
msgid ""
"Boxed expressions support construction of NSValue objects. It said that C "
"structures can be used, the only requirement is: structure should be marked "
"with ``objc_boxable`` attribute. To support older version of frameworks and/"
"or third-party libraries you may need to add the attribute via ``typedef``."
msgstr ""

#: ../../../ObjectiveCLiterals.rst:264
msgid "Container Literals"
msgstr ""

#: ../../../ObjectiveCLiterals.rst:266
msgid ""
"Objective-C now supports a new expression syntax for creating immutable "
"array and dictionary container objects."
msgstr ""

#: ../../../ObjectiveCLiterals.rst:272
msgid "Immutable array expression:"
msgstr ""

#: ../../../ObjectiveCLiterals.rst:278
msgid ""
"This creates an ``NSArray`` with 3 elements. The comma-separated sub-"
"expressions of an array literal can be any Objective-C object pointer typed "
"expression."
msgstr ""

#: ../../../ObjectiveCLiterals.rst:282
msgid "Immutable dictionary expression:"
msgstr ""

#: ../../../ObjectiveCLiterals.rst:292
msgid ""
"This creates an ``NSDictionary`` with 3 key/value pairs. Value sub-"
"expressions of a dictionary literal must be Objective-C object pointer "
"typed, as in array literals. Key sub-expressions must be of an Objective-C "
"object pointer type that implements the ``<NSCopying>`` protocol."
msgstr ""

#: ../../../ObjectiveCLiterals.rst:301
msgid ""
"Neither keys nor values can have the value ``nil`` in containers. If the "
"compiler can prove that a key or value is ``nil`` at compile time, then a "
"warning will be emitted. Otherwise, a runtime error will occur."
msgstr ""

#: ../../../ObjectiveCLiterals.rst:305
msgid ""
"Using array and dictionary literals is safer than the variadic creation "
"forms commonly in use today. Array literal expressions expand to calls to "
"``+[NSArray arrayWithObjects:count:]``, which validates that all objects are "
"non-``nil``. The variadic form, ``+[NSArray arrayWithObjects:]`` uses "
"``nil`` as an argument list terminator, which can lead to malformed array "
"objects. Dictionary literals are similarly created with ``+[NSDictionary "
"dictionaryWithObjects:forKeys:count:]`` which validates all objects and "
"keys, unlike ``+[NSDictionary dictionaryWithObjectsAndKeys:]`` which also "
"uses a ``nil`` parameter as an argument list terminator."
msgstr ""

#: ../../../ObjectiveCLiterals.rst:318
msgid "Object Subscripting"
msgstr ""

#: ../../../ObjectiveCLiterals.rst:320
msgid ""
"Objective-C object pointer values can now be used with C's subscripting "
"operator."
msgstr ""

#: ../../../ObjectiveCLiterals.rst:326
msgid ""
"The following code demonstrates the use of object subscripting syntax with "
"``NSMutableArray`` and ``NSMutableDictionary`` objects:"
msgstr ""

#: ../../../ObjectiveCLiterals.rst:342
msgid ""
"The next section explains how subscripting expressions map to accessor "
"methods."
msgstr ""

#: ../../../ObjectiveCLiterals.rst:346
msgid "Subscripting Methods"
msgstr ""

#: ../../../ObjectiveCLiterals.rst:348
msgid ""
"Objective-C supports two kinds of subscript expressions: *array-style* "
"subscript expressions use integer typed subscripts; *dictionary-style* "
"subscript expressions use Objective-C object pointer typed subscripts. Each "
"type of subscript expression is mapped to a message send using a predefined "
"selector. The advantage of this design is flexibility: class designers are "
"free to introduce subscripting by declaring methods or by adopting "
"protocols. Moreover, because the method names are selected by the type of "
"the subscript, an object can be subscripted using both array and dictionary "
"styles."
msgstr ""

#: ../../../ObjectiveCLiterals.rst:359
msgid "Array-Style Subscripting"
msgstr ""

#: ../../../ObjectiveCLiterals.rst:361
msgid ""
"When the subscript operand has an integral type, the expression is rewritten "
"to use one of two different selectors, depending on whether the element is "
"being read or written. When an expression reads an element using an integral "
"index, as in the following example:"
msgstr ""

#: ../../../ObjectiveCLiterals.rst:371
msgid "it is translated into a call to ``objectAtIndexedSubscript:``"
msgstr ""

#: ../../../ObjectiveCLiterals.rst:377
msgid "When an expression writes an element using an integral index:"
msgstr ""

#: ../../../ObjectiveCLiterals.rst:383
msgid "it is translated to a call to ``setObject:atIndexedSubscript:``"
msgstr ""

#: ../../../ObjectiveCLiterals.rst:389
msgid ""
"These message sends are then type-checked and performed just like explicit "
"message sends. The method used for objectAtIndexedSubscript: must be "
"declared with an argument of integral type and a return value of some "
"Objective-C object pointer type. The method used for setObject:"
"atIndexedSubscript: must be declared with its first argument having some "
"Objective-C pointer type and its second argument having integral type."
msgstr ""

#: ../../../ObjectiveCLiterals.rst:397
msgid ""
"The meaning of indexes is left up to the declaring class. The compiler will "
"coerce the index to the appropriate argument type of the method it uses for "
"type-checking. For an instance of ``NSArray``, reading an element using an "
"index outside the range ``[0, array.count)`` will raise an exception. For an "
"instance of ``NSMutableArray``, assigning to an element using an index "
"within this range will replace that element, but assigning to an element "
"using an index outside this range will raise an exception; no syntax is "
"provided for inserting, appending, or removing elements for mutable arrays."
msgstr ""

#: ../../../ObjectiveCLiterals.rst:407
msgid ""
"A class need not declare both methods in order to take advantage of this "
"language feature. For example, the class ``NSArray`` declares only "
"``objectAtIndexedSubscript:``, so that assignments to elements will fail to "
"type-check; moreover, its subclass ``NSMutableArray`` declares ``setObject:"
"atIndexedSubscript:``."
msgstr ""

#: ../../../ObjectiveCLiterals.rst:414
msgid "Dictionary-Style Subscripting"
msgstr ""

#: ../../../ObjectiveCLiterals.rst:416
msgid ""
"When the subscript operand has an Objective-C object pointer type, the "
"expression is rewritten to use one of two different selectors, depending on "
"whether the element is being read from or written to. When an expression "
"reads an element using an Objective-C object pointer subscript operand, as "
"in the following example:"
msgstr ""

#: ../../../ObjectiveCLiterals.rst:427
msgid ""
"it is translated into a call to the ``objectForKeyedSubscript:`` method:"
msgstr ""

#: ../../../ObjectiveCLiterals.rst:433
msgid ""
"When an expression writes an element using an Objective-C object pointer "
"subscript:"
msgstr ""

#: ../../../ObjectiveCLiterals.rst:440
msgid "it is translated to a call to ``setObject:forKeyedSubscript:``"
msgstr ""

#: ../../../ObjectiveCLiterals.rst:446
msgid ""
"The behavior of ``setObject:forKeyedSubscript:`` is class-specific; but in "
"general it should replace an existing value if one is already associated "
"with a key, otherwise it should add a new value for the key. No syntax is "
"provided for removing elements from mutable dictionaries."
msgstr ""

#: ../../../ObjectiveCLiterals.rst:454
msgid ""
"An Objective-C subscript expression occurs when the base operand of the C "
"subscript operator has an Objective-C object pointer type. Since this "
"potentially collides with pointer arithmetic on the value, these expressions "
"are only supported under the modern Objective-C runtime, which categorically "
"forbids such arithmetic."
msgstr ""

#: ../../../ObjectiveCLiterals.rst:460
msgid ""
"Currently, only subscripts of integral or Objective-C object pointer type "
"are supported. In C++, a class type can be used if it has a single "
"conversion function to an integral or Objective-C pointer type, in which "
"case that conversion is applied and analysis continues as appropriate. "
"Otherwise, the expression is ill-formed."
msgstr ""

#: ../../../ObjectiveCLiterals.rst:466
msgid ""
"An Objective-C object subscript expression is always an l-value. If the "
"expression appears on the left-hand side of a simple assignment operator "
"(=), the element is written as described below. If the expression appears on "
"the left-hand side of a compound assignment operator (e.g. +=), the program "
"is ill-formed, because the result of reading an element is always an "
"Objective-C object pointer and no binary operators are legal on such "
"pointers. If the expression appears in any other position, the element is "
"read as described below. It is an error to take the address of a subscript "
"expression, or (in C++) to bind a reference to it."
msgstr ""

#: ../../../ObjectiveCLiterals.rst:477
msgid ""
"Programs can use object subscripting with Objective-C object pointers of "
"type ``id``. Normal dynamic message send rules apply; the compiler must see "
"*some* declaration of the subscripting methods, and will pick the "
"declaration seen first."
msgstr ""

#: ../../../ObjectiveCLiterals.rst:483
msgid "Caveats"
msgstr ""

#: ../../../ObjectiveCLiterals.rst:485
msgid ""
"Objects created using the literal or boxed expression syntax are not "
"guaranteed to be uniqued by the runtime, but nor are they guaranteed to be "
"newly-allocated. As such, the result of performing direct comparisons "
"against the location of an object literal (using ``==``, ``!=``, ``<``, "
"``<=``, ``>``, or ``>=``) is not well-defined. This is usually a simple "
"mistake in code that intended to call the ``isEqual:`` method (or the "
"``compare:`` method)."
msgstr ""

#: ../../../ObjectiveCLiterals.rst:493
msgid ""
"This caveat applies to compile-time string literals as well. Historically, "
"string literals (using the ``@\"...\"`` syntax) have been uniqued across "
"translation units during linking. This is an implementation detail of the "
"compiler and should not be relied upon. If you are using such code, please "
"use global string constants instead (``NSString * const MyConst = @\"..."
"\"``) or use ``isEqual:``."
msgstr ""

#: ../../../ObjectiveCLiterals.rst:501
msgid "Grammar Additions"
msgstr ""

#: ../../../ObjectiveCLiterals.rst:503
msgid ""
"To support the new syntax described above, the Objective-C ``@``-expression "
"grammar has the following new productions:"
msgstr ""

#: ../../../ObjectiveCLiterals.rst:538
msgid "Note: ``@true`` and ``@false`` are only supported in Objective-C++."
msgstr ""

#: ../../../ObjectiveCLiterals.rst:541
msgid "Availability Checks"
msgstr ""

#: ../../../ObjectiveCLiterals.rst:543
msgid ""
"Programs test for the new features by using clang's \\_\\_has\\_feature "
"checks. Here are examples of their use:"
msgstr ""

#: ../../../ObjectiveCLiterals.rst:600
msgid ""
"Code can use also ``__has_feature(objc_bool)`` to check for the availability "
"of numeric literals support. This checks for the new ``__objc_yes / "
"__objc_no`` keywords, which enable the use of ``@YES / @NO`` literals."
msgstr ""

#: ../../../ObjectiveCLiterals.rst:605
msgid ""
"To check whether boxed expressions are supported, use "
"``__has_feature(objc_boxed_expressions)`` feature macro."
msgstr ""
