# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2025, The Clang Team
# This file is distributed under the same license as the Clang package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Clang 5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-13 13:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../ControlFlowIntegrityDesign.rst:3
msgid "Control Flow Integrity Design Documentation"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:5
msgid ""
"This page documents the design of the :doc:`ControlFlowIntegrity` schemes "
"supported by Clang."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:9
msgid "Forward-Edge CFI for Virtual Calls"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:11
msgid ""
"This scheme works by allocating, for each static type used to make a virtual "
"call, a region of read-only storage in the object file holding a bit vector "
"that maps onto to the region of storage used for those virtual tables. Each "
"set bit in the bit vector corresponds to the `address point`_ for a virtual "
"table compatible with the static type for which the bit vector is being "
"built."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:17
msgid "For example, consider the following three C++ classes:"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:39
msgid ""
"The scheme will cause the virtual tables for A, B and C to be laid out "
"consecutively:"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:42
#: ../../../ControlFlowIntegrityDesign.rst:232
msgid "Virtual Table Layout for A, B, C"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "0"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "1"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "2"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "3"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "4"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "5"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "6"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "7"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "8"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "9"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "10"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "11"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "12"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "13"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "14"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "A::offset-to-top"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "&A::rtti"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "&A::f1"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "&A::f2"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "&A::f3"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "B::offset-to-top"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "&B::rtti"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "&B::f1"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "&B::f2"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "&B::f3"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "C::offset-to-top"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "&C::rtti"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "&C::f1"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "&C::f2"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "&C::f3"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:47
msgid "The bit vector for static types A, B and C will look like this:"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:49
#: ../../../ControlFlowIntegrityDesign.rst:121
msgid "Bit Vectors for A, B, C"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "Class"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "A"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "B"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "C"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:56
msgid ""
"Bit vectors are represented in the object file as byte arrays. By loading "
"from indexed offsets into the byte array and applying a mask, a program can "
"test bits from the bit set with a relatively short instruction sequence. Bit "
"vectors may overlap so long as they use different bits. For the full "
"details, see the `ByteArrayBuilder`_ class."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:62
msgid ""
"In this case, assuming A is laid out at offset 0 in bit 0, B at offset 0 in "
"bit 1 and C at offset 0 in bit 2, the byte array would look like this:"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:69
msgid ""
"To emit a virtual call, the compiler will assemble code that checks that the "
"object's virtual table pointer is in-bounds and aligned and that the "
"relevant bit is set in the bit vector."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:73
msgid "For example on x86 a typical virtual call may look like this:"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:91
msgid ""
"The compiler relies on co-operation from the linker in order to assemble the "
"bit vectors for the whole program. It currently does this using LLVM's `type "
"metadata`_ mechanism together with link-time optimization."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:100
msgid "Optimizations"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:102
msgid ""
"The scheme as described above is the fully general variant of the scheme. "
"Most of the time we are able to apply one or more of the following "
"optimizations to improve binary size or performance."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:106
msgid ""
"In fact, if you try the above example with the current version of the "
"compiler, you will probably find that it will not use the described virtual "
"table layout or machine instructions. Some of the optimizations we are about "
"to introduce cause the compiler to use a different layout or a different "
"sequence of machine instructions."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:113
msgid "Stripping Leading/Trailing Zeros in Bit Vectors"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:115
msgid ""
"If a bit vector contains leading or trailing zeros, we can strip them from "
"the vector. The compiler will emit code to check if the pointer is in range "
"of the region covered by ones, and perform the bit vector check using a "
"truncated version of the bit vector. For example, the bit vectors for our "
"example class hierarchy will be emitted like this:"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:129
msgid "Short Inline Bit Vectors"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:131
msgid ""
"If the vector is sufficiently short, we can represent it as an inline "
"constant on x86. This saves us a few instructions when reading the correct "
"element of the bit vector."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:135
msgid "If the bit vector fits in 32 bits, the code looks like this:"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:154
msgid "Or if the bit vector fits in 64 bits:"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:174
msgid ""
"If the bit vector consists of a single bit, there is only one possible "
"virtual table, and the check can consist of a single equality comparison:"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:189
msgid "Virtual Table Layout"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:191
msgid ""
"The compiler lays out classes of disjoint hierarchies in separate regions of "
"the object file. At worst, bit vectors in disjoint hierarchies only need to "
"cover their disjoint hierarchy. But the closer that classes in sub-"
"hierarchies are laid out to each other, the smaller the bit vectors for "
"those sub-hierarchies need to be (see \"Stripping Leading/Trailing Zeros in "
"Bit Vectors\" above). The `GlobalLayoutBuilder`_ class is responsible for "
"laying out the globals efficiently to minimize the sizes of the underlying "
"bitsets."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:202
msgid "Alignment"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:204
msgid ""
"If all gaps between address points in a particular bit vector are multiples "
"of powers of 2, the compiler can compress the bit vector by strengthening "
"the alignment requirements of the virtual table pointer. For example, given "
"this class hierarchy:"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:230
msgid "The virtual tables will be laid out like this:"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "15"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "&B::f4"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "&B::f5"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:1
msgid "&B::f6"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:237
msgid ""
"Notice that each address point for A is separated by 4 words. This lets us "
"emit a compressed bit vector for A that looks like this:"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:245
msgid ""
"At call sites, the compiler will strengthen the alignment requirements by "
"using a different rotate count. For example, on a 64-bit machine where the "
"address points are 4-word aligned (as in A from our example), the ``rol`` "
"instruction may look like this:"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:255
msgid "Padding to Powers of 2"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:257
msgid ""
"Of course, this alignment scheme works best if the address points are in "
"fact aligned correctly. To make this more likely to happen, we insert "
"padding between virtual tables that in many cases aligns address points to a "
"power of 2. Specifically, our padding aligns virtual tables to the next "
"highest power of 2 bytes; because address points for specific base classes "
"normally appear at fixed offsets within the virtual table, this normally has "
"the effect of aligning the address points as well."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:265
msgid ""
"This scheme introduces tradeoffs between decreased space overhead for "
"instructions and bit vectors and increased overhead in the form of padding. "
"We therefore limit the amount of padding so that we align to no more than "
"128 bytes. This number was found experimentally to provide a good tradeoff."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:271
msgid "Eliminating Bit Vector Checks for All-Ones Bit Vectors"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:273
msgid ""
"If the bit vector is all ones, the bit vector check is redundant; we simply "
"need to check that the address is in range and well aligned. This is more "
"likely to occur if the virtual tables are padded."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:278
msgid "Forward-Edge CFI for Indirect Function Calls"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:280
msgid ""
"Under forward-edge CFI for indirect function calls, each unique function "
"type has its own bit vector, and at each call site we need to check that the "
"function pointer is a member of the function type's bit vector. This scheme "
"works in a similar way to forward-edge CFI for virtual calls, the "
"distinction being that we need to build bit vectors of function entry points "
"rather than of virtual tables."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:287
msgid ""
"Unlike when re-arranging global variables, we cannot re-arrange functions in "
"a particular order and base our calculations on the layout of the functions' "
"entry points, as we have no idea how large a particular function will end up "
"being (the function sizes could even depend on how we arrange the "
"functions). Instead, we build a jump table, which is a block of code "
"consisting of one branch instruction for each of the functions in the bit "
"set that branches to the target function, and redirect any taken function "
"addresses to the corresponding jump table entry. In this way, the distance "
"between function entry points is predictable and controllable. In the object "
"file's symbol table, the symbols for the target functions also refer to the "
"jump table entries, so that addresses taken outside the module will pass any "
"verification done inside the module."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:300
msgid ""
"In more concrete terms, suppose we have three functions ``f``, ``g``, ``h`` "
"which are all of the same type, and a function foo that returns their "
"addresses:"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:324
msgid "Our jump table will (conceptually) look like this:"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:364
msgid ""
"Because the addresses of ``f``, ``g``, ``h`` are evenly spaced at a power of "
"2, and function types do not overlap (unlike class types with base classes), "
"we can normally apply the `Alignment`_ and `Eliminating Bit Vector Checks "
"for All-Ones Bit Vectors`_ optimizations thus simplifying the check at each "
"call site to a range and alignment check."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:371
msgid "Shared library support"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:373
msgid "**EXPERIMENTAL**"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:375
msgid ""
"The basic CFI mode described above assumes that the application is a "
"monolithic binary; at least that all possible virtual/indirect call targets "
"and the entire class hierarchy are known at link time. The cross-DSO mode, "
"enabled with **-f[no-]sanitize-cfi-cross-dso** relaxes this requirement by "
"allowing virtual and indirect calls to cross the DSO boundary."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:382
msgid ""
"Assuming the following setup: the binary consists of several instrumented "
"and several uninstrumented DSOs. Some of them may be dlopen-ed/dlclose-d "
"periodically, even frequently."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:386
msgid "Calls made from uninstrumented DSOs are not checked and just work."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:387
msgid "Calls inside any instrumented DSO are fully protected."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:389
msgid "Calls between different instrumented DSOs are also protected, with"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:389
msgid "a performance penalty (in addition to the monolithic CFI overhead)."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:391
msgid "Calls from an instrumented DSO to an uninstrumented one are"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:392
msgid "unchecked and just work, with performance penalty."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:394
msgid "Calls from an instrumented DSO outside of any known DSO are"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:394
msgid "detected as CFI violations."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:396
msgid "In the monolithic scheme a call site is instrumented as"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:404
msgid "In the cross-DSO scheme it becomes"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:413
msgid "CallSiteTypeId"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:415
msgid ""
"``CallSiteTypeId`` is a stable process-wide identifier of the call-site "
"type. For a virtual call site, the type in question is the class type; for "
"an indirect function call it is the function signature. The mapping from a "
"type to an identifier is an ABI detail. In the current, experimental, "
"implementation the identifier of type T is calculated as follows:"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:422
msgid "Obtain the mangled name for \"typeinfo name for T\"."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:423
msgid "Calculate MD5 hash of the name as a string."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:424
msgid ""
"Reinterpret the first 8 bytes of the hash as a little-endian 64-bit integer."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:427
msgid ""
"It is possible, but unlikely, that collisions in the ``CallSiteTypeId`` "
"hashing will result in weaker CFI checks that would still be conservatively "
"correct."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:432
msgid "CFI_Check"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:434
msgid ""
"In the general case, only the target DSO knows whether the call to function "
"``f`` with type ``CallSiteTypeId`` is valid or not.  To export this "
"information, every DSO implements"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:442
msgid ""
"This function provides external modules with access to CFI checks for the "
"targets inside this DSO.  For each known ``CallSiteTypeId``, this function "
"performs an ``llvm.type.test`` with the corresponding type identifier. It "
"reports an error if the type is unknown, or if the check fails. Depending on "
"the values of compiler flags ``-fsanitize-trap`` and ``-fsanitize-recover``, "
"this function may print an error, abort and/or return to the caller. "
"``DiagData`` is an opaque pointer to the diagnostic information about the "
"error, or ``null`` if the caller does not provide this information."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:452
msgid ""
"The basic implementation is a large switch statement over all values of "
"CallSiteTypeId supported by this DSO, and each case is similar to the "
"InlinedFastCheck() in the basic CFI mode."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:457
msgid "CFI Shadow"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:459
msgid ""
"To route CFI checks to the target DSO's __cfi_check function, a mapping from "
"possible virtual / indirect call targets to the corresponding __cfi_check "
"functions is maintained. This mapping is implemented as a sparse array of 2 "
"bytes for every possible page (4096 bytes) of memory. The table is kept "
"readonly most of the time."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:465
msgid "There are 3 types of shadow values:"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:467
msgid "Address in a CFI-instrumented DSO."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:468
msgid ""
"Unchecked address (a “trusted” non-instrumented DSO). Encoded as value "
"0xFFFF."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:470
msgid "Invalid address (everything else). Encoded as value 0."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:472
msgid ""
"For a CFI-instrumented DSO, a shadow value encodes the address of the "
"__cfi_check function for all call targets in the corresponding memory page. "
"If Addr is the target address, and V is the shadow value, then the address "
"of __cfi_check is calculated as"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:481
msgid ""
"This works as long as __cfi_check is aligned by 4096 bytes and located below "
"any call targets in its DSO, but not more than 256MB apart from them."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:486
msgid "CFI_SlowPath"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:488
msgid "The slow path check is implemented in a runtime support library as"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:495
msgid ""
"These functions loads a shadow value for ``TargetAddr``, finds the address "
"of ``__cfi_check`` as described above and calls that. ``DiagData`` is an "
"opaque pointer to diagnostic data which is passed verbatim to "
"``__cfi_check``, and ``__cfi_slowpath`` passes ``nullptr`` instead."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:501
msgid ""
"Compiler-RT library contains reference implementations of slowpath "
"functions, but they have unresolvable issues with correctness and "
"performance in the handling of dlopen(). It is recommended that platforms "
"provide their own implementations, usually as part of libc or libdl."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:508
msgid "Position-independent executable requirement"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:510
msgid ""
"Cross-DSO CFI mode requires that the main executable is built as PIE. In non-"
"PIE executables the address of an external function (taken from the main "
"executable) is the address of that function’s PLT record in the main "
"executable. This would break the CFI checks."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:516
msgid "Backward-edge CFI for return statements (RCFI)"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:518
msgid "This section is a proposal. As of March 2017 it is not implemented."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:520
msgid ""
"Backward-edge control flow (`RET` instructions) can be hijacked via "
"overwriting the return address (`RA`) on stack. Various mitigation "
"techniques (e.g. `SafeStack`_, `RFG`_, `Intel CET`_) try to detect or "
"prevent `RA` corruption on stack."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:525
msgid ""
"RCFI enforces the expected control flow in several different ways described "
"below. RCFI heavily relies on LTO."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:529
msgid "Leaf Functions"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:530
msgid ""
"If `f()` is a leaf function (i.e. it has no calls except maybe no-return "
"calls) it can be called using a special calling convention that stores `RA` "
"in a dedicated register `R` before the `CALL` instruction. `f()` does not "
"spill `R` and does not use the `RET` instruction, instead it uses the value "
"in `R` to `JMP` to `RA`."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:536
msgid ""
"This flavour of CFI is *precise*, i.e. the function is guaranteed to return "
"to the point exactly following the call."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:539
msgid ""
"An alternative approach is to copy `RA` from stack to `R` in the first "
"instruction of `f()`, then `JMP` to `R`. This approach is simpler to "
"implement (does not require changing the caller) but weaker (there is a "
"small window when `RA` is actually stored on stack)."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:547
msgid "Functions called once"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:548
msgid ""
"Suppose `f()` is called in just one place in the program (assuming we can "
"verify this in LTO mode). In this case we can replace the `RET` instruction "
"with a `JMP` instruction with the immediate constant for `RA`. This will "
"*precisely* enforce the return control flow no matter what is stored on "
"stack."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:554
msgid ""
"Another variant is to compare `RA` on stack with the known constant and "
"abort if they don't match; then `JMP` to the known constant address."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:558
msgid "Functions called in a small number of call sites"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:559
msgid ""
"We may extend the above approach to cases where `f()` is called more than "
"once (but still a small number of times). With LTO we know all possible "
"values of `RA` and we check them one-by-one (or using binary search) against "
"the value on stack. If the match is found, we `JMP` to the known constant "
"address, otherwise abort."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:565
msgid ""
"This protection is *near-precise*, i.e. it guarantees that the control flow "
"will be transferred to one of the valid return addresses for this function, "
"but not necessary to the point of the most recent `CALL`."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:570
msgid "General case"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:571
msgid ""
"For functions called multiple times a *return jump table* is constructed in "
"the same manner as jump tables for indirect function calls (see above). The "
"correct jump table entry (or it's index) is passed by `CALL` to `f()` (as an "
"extra argument) and then spilled to stack. The `RET` instruction is replaced "
"with a load of the jump table entry, jump table range check, and `JMP` to "
"the jump table entry."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:578
msgid "This protection is also *near-precise*."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:581
msgid "Returns from functions called indirectly"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:583
msgid ""
"If a function is called indirectly, the return jump table is constructed for "
"the equivalence class of functions instead of a single function."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:587
msgid "Cross-DSO calls"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:588
msgid ""
"Consider two instrumented DSOs, `A` and `B`. `A` defines `f()` and `B` calls "
"it."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:590
msgid ""
"This case will be handled similarly to the cross-DSO scheme using the slow "
"path callback."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:593
msgid "Non-goals"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:598
msgid "RCFI does not protect `RET` instructions:"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:596
msgid "in non-instrumented DSOs,"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:597
msgid ""
"in instrumented DSOs for functions that are called from non-instrumented "
"DSOs,"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:598
msgid "embedded into other instructions (e.g. `0f4fc3 cmovg %ebx,%eax`)."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:605
msgid "Hardware support"
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:607
msgid ""
"We believe that the above design can be efficiently implemented in hardware. "
"A single new instruction added to an ISA would allow to perform the forward-"
"edge CFI check with fewer bytes per check (smaller code size overhead) and "
"potentially more efficiently. The current software-only instrumentation "
"requires at least 32-bytes per check (on x86_64). A hardware instruction may "
"probably be less than ~ 12 bytes. Such instruction would check that the "
"argument pointer is in-bounds, and is properly aligned, and if the checks "
"fail it will either trap (in monolithic scheme) or call the slow path "
"function (cross-DSO scheme). The bit vector lookup is probably too complex "
"for a hardware implementation."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:645
msgid ""
"An alternative and more compact encoding would not use `kFailedCheckTarget`, "
"and will trap on check failure instead. This will allow us to fit the "
"instruction into **8-9 bytes**. The cross-DSO checks will be performed by a "
"trap handler and performance-critical ones will have to be black-listed and "
"checked using the software-only scheme."
msgstr ""

#: ../../../ControlFlowIntegrityDesign.rst:652
msgid ""
"Note that such hardware extension would be complementary to checks at the "
"callee side, such as e.g. **Intel ENDBRANCH**. Moreover, CFI would have two "
"benefits over ENDBRANCH: a) precision and b) ability to protect against "
"invalid casts between polymorphic types."
msgstr ""
