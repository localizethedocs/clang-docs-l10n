# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2025, The Clang Team
# This file is distributed under the same license as the Clang package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Clang 17\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-13 13:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: fr_FR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../SourceBasedCodeCoverage.rst:3
msgid "Source-based Code Coverage"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:9
msgid "Introduction"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:11
msgid ""
"This document explains how to use clang's source-based code coverage "
"feature. It's called \"source-based\" because it operates on AST and "
"preprocessor information directly. This allows it to generate very precise "
"coverage data."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:15
msgid "Clang ships two other code coverage implementations:"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:17
msgid ""
":doc:`SanitizerCoverage` - A low-overhead tool meant for use alongside the "
"various sanitizers. It can provide up to edge-level coverage."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:20
msgid ""
"gcov - A GCC-compatible coverage implementation which operates on DebugInfo. "
"This is enabled by ``-ftest-coverage`` or ``--coverage``."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:23
msgid ""
"From this point onwards \"code coverage\" will refer to the source-based "
"kind."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:26
msgid "The code coverage workflow"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:28
msgid "The code coverage workflow consists of three main steps:"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:30
msgid "Compiling with coverage enabled."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:32
msgid "Running the instrumented program."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:34
msgid "Creating coverage reports."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:36
msgid ""
"The next few sections work through a complete, copy-'n-paste friendly "
"example based on this program:"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:54
msgid "Compiling with coverage enabled"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:56
msgid ""
"To compile code with coverage enabled, pass ``-fprofile-instr-generate -"
"fcoverage-mapping`` to the compiler:"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:64
msgid ""
"Note that linking together code with and without coverage instrumentation is "
"supported. Uninstrumented code simply won't be accounted for in reports."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:68
msgid "Running the instrumented program"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:70
msgid ""
"The next step is to run the instrumented program. When the program exits it "
"will write a **raw profile** to the path specified by the "
"``LLVM_PROFILE_FILE`` environment variable. If that variable does not exist, "
"the profile is written to ``default.profraw`` in the current directory of "
"the program. If ``LLVM_PROFILE_FILE`` contains a path to a non-existent "
"directory, the missing directory structure will be created.  Additionally, "
"the following special **pattern strings** are rewritten:"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:78
msgid "\"%p\" expands out to the process ID."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:80
msgid "\"%h\" expands out to the hostname of the machine running the program."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:82
msgid ""
"\"%t\" expands out to the value of the ``TMPDIR`` environment variable. On "
"Darwin, this is typically set to a temporary scratch directory."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:85
msgid ""
"\"%Nm\" expands out to the instrumented binary's signature. When this "
"pattern is specified, the runtime creates a pool of N raw profiles which are "
"used for on-line profile merging. The runtime takes care of selecting a raw "
"profile from the pool, locking it, and updating it before the program "
"exits.  If N is not specified (i.e the pattern is \"%m\"), it's assumed that "
"``N = 1``. The merge pool specifier can only occur once per filename pattern."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:92
msgid ""
"\"%c\" expands out to nothing, but enables a mode in which profile counter "
"updates are continuously synced to a file. This means that if the "
"instrumented program crashes, or is killed by a signal, perfect coverage "
"information can still be recovered. Continuous mode does not support value "
"profiling for PGO, and is only supported on Darwin at the moment. Support "
"for Linux may be mostly complete but requires testing, and support for "
"Windows may require more extensive changes: please get involved if you are "
"interested in porting this feature."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:106
msgid ""
"Note that continuous mode is also used on Fuchsia where it's the only "
"supported mode, but the implementation is different. The Darwin and Linux "
"implementation relies on padding and the ability to map a file over the "
"existing memory mapping which is generally only available on POSIX systems "
"and isn't suitable for other platforms."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:112
msgid ""
"On Fuchsia, we rely on the ability to relocate counters at runtime using a "
"level of indirection. On every counter access, we add a bias to the counter "
"address. This bias is stored in ``__llvm_profile_counter_bias`` symbol "
"that's provided by the profile runtime and is initially set to zero, meaning "
"no relocation. The runtime can map the profile into memory at arbitrary "
"locations, and set bias to the offset between the original and the new "
"counter location, at which point every subsequent counter access will be to "
"the new location, which allows updating profile directly akin to the "
"continuous mode."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:121
msgid ""
"The advantage of this approach is that doesn't require any special OS "
"support. The disadvantage is the extra overhead due to additional "
"instructions required for each counter access (overhead both in terms of "
"binary size and performance) plus duplication of counters (i.e. one copy in "
"the binary itself and another copy that's mapped into memory). This "
"implementation can be also enabled for other platforms by passing the ``-"
"runtime-counter-relocation`` option to the backend during compilation."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:129
msgid ""
"For a program such as the `Lit <https://llvm.org/docs/CommandGuide/lit."
"html>`_ testing tool which invokes other programs, it may be necessary to "
"set ``LLVM_PROFILE_FILE`` for each invocation. The pattern strings \"%p\" or "
"\"%Nm\" may help to avoid corruption due to concurrency. Note that \"%p\" is "
"also a Lit token and needs to be escaped as \"%%p\"."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:140
msgid "Creating coverage reports"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:142
msgid ""
"Raw profiles have to be **indexed** before they can be used to generate "
"coverage reports. This is done using the \"merge\" tool in ``llvm-profdata`` "
"(which can combine multiple raw profiles and index them at the same time):"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:151
msgid ""
"For an example of merging multiple profiles created by testing, see the LLVM "
"`coverage build script <https://github.com/llvm/llvm-zorg/blob/main/zorg/"
"jenkins/jobs/jobs/llvm-coverage>`_."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:154
msgid ""
"There are multiple different ways to render coverage reports. The simplest "
"option is to generate a line-oriented report:"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:162
msgid ""
"This report includes a summary view as well as dedicated sub-views for "
"templated functions and their instantiations. For our example program, we "
"get distinct views for ``foo<int>(...)`` and ``foo<float>(...)``.  If ``-"
"show-line-counts-or-regions`` is enabled, ``llvm-cov`` displays sub-line "
"region counts (even in macro expansions):"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:190
msgid ""
"If ``--show-branches=count`` and ``--show-expansions`` are also enabled, the "
"sub-views will show detailed branch coverage information in addition to the "
"region counts:"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:215
msgid ""
"To generate a file-level summary of coverage statistics instead of a line-"
"oriented report, try:"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:228
msgid ""
"The ``llvm-cov`` tool supports specifying a custom demangler, writing out "
"reports in a directory structure, and generating html reports. For the full "
"list of options, please refer to the `command guide <https://llvm.org/docs/"
"CommandGuide/llvm-cov.html>`_."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:233
msgid "A few final notes:"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:235
msgid ""
"The ``-sparse`` flag is optional but can result in dramatically smaller "
"indexed profiles. This option should not be used if the indexed profile will "
"be reused for PGO."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:239
msgid ""
"Raw profiles can be discarded after they are indexed. Advanced use of the "
"profile runtime library allows an instrumented program to merge profiling "
"information directly into an existing raw profile on disk. The details are "
"out of scope."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:244
msgid ""
"The ``llvm-profdata`` tool can be used to merge together multiple raw or "
"indexed profiles. To combine profiling data from multiple runs of a program, "
"try e.g:"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:253
msgid "Exporting coverage data"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:255
msgid ""
"Coverage data can be exported into JSON using the ``llvm-cov export`` sub-"
"command. There is a comprehensive reference which defines the structure of "
"the exported data at a high level in the llvm-cov source code."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:260
msgid "Interpreting reports"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:262
msgid "There are five statistics tracked in a coverage summary:"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:264
msgid ""
"Function coverage is the percentage of functions which have been executed at "
"least once. A function is considered to be executed if any of its "
"instantiations are executed."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:268
msgid ""
"Instantiation coverage is the percentage of function instantiations which "
"have been executed at least once. Template functions and static inline "
"functions from headers are two kinds of functions which may have multiple "
"instantiations. This statistic is hidden by default in reports, but can be "
"enabled via the ``-show-instantiation-summary`` option."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:274
msgid ""
"Line coverage is the percentage of code lines which have been executed at "
"least once. Only executable lines within function bodies are considered to "
"be code lines."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:278
msgid ""
"Region coverage is the percentage of code regions which have been executed "
"at least once. A code region may span multiple lines (e.g in a large "
"function body with no control flow). However, it's also possible for a "
"single line to contain multiple code regions (e.g in \"return x || y && z\")."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:283
msgid ""
"Branch coverage is the percentage of \"true\" and \"false\" branches that "
"have been taken at least once. Each branch is tied to individual conditions "
"in the source code that may each evaluate to either \"true\" or \"false\".  "
"These conditions may comprise larger boolean expressions linked by boolean "
"logical operators. For example, \"x = (y == 2) || (z < 10)\" is a boolean "
"expression that is comprised of two individual conditions, each of which "
"evaluates to either true or false, producing four total branch outcomes."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:291
msgid ""
"Of these five statistics, function coverage is usually the least granular "
"while branch coverage is the most granular. 100% branch coverage for a "
"function implies 100% region coverage for a function. The project-wide "
"totals for each statistic are listed in the summary."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:297
msgid "Format compatibility guarantees"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:299
msgid ""
"There are no backwards or forwards compatibility guarantees for the raw "
"profile format. Raw profiles may be dependent on the specific compiler "
"revision used to generate them. It's inadvisable to store raw profiles for "
"long periods of time."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:304
msgid ""
"Tools must retain **backwards** compatibility with indexed profile formats. "
"These formats are not forwards-compatible: i.e, a tool which uses format "
"version X will not be able to understand format version (X+k)."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:308
msgid ""
"Tools must also retain **backwards** compatibility with the format of the "
"coverage mappings emitted into instrumented binaries. These formats are not "
"forwards-compatible."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:312
msgid ""
"The JSON coverage export format has a (major, minor, patch) version triple. "
"Only a major version increment indicates a backwards-incompatible change. A "
"minor version increment is for added functionality, and patch version "
"increments are for bugfixes."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:318
msgid "Impact of llvm optimizations on coverage reports"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:320
msgid ""
"llvm optimizations (such as inlining or CFG simplification) should have no "
"impact on coverage report quality. This is due to the fact that the mapping "
"from source regions to profile counters is immutable, and is generated "
"before the llvm optimizer kicks in. The optimizer can't prove that profile "
"counter instrumentation is safe to delete (because it's not: it affects the "
"profile the program emits), and so leaves it alone."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:327
msgid ""
"Note that this coverage feature does not rely on information that can "
"degrade during the course of optimization, such as debug info line tables."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:331
msgid "Using the profiling runtime without static initializers"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:333
msgid ""
"By default the compiler runtime uses a static initializer to determine the "
"profile output path and to register a writer function. To collect profiles "
"without using static initializers, do this manually:"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:337
msgid ""
"Export a ``int __llvm_profile_runtime`` symbol from each instrumented shared "
"library and executable. When the linker finds a definition of this symbol, "
"it knows to skip loading the object which contains the profiling runtime's "
"static initializer."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:342
msgid ""
"Forward-declare ``void __llvm_profile_initialize_file(void)`` and call it "
"once from each instrumented executable. This function parses "
"``LLVM_PROFILE_FILE``, sets the output path, and truncates any existing "
"files at that path. To get the same behavior without truncating existing "
"files, pass a filename pattern string to ``void "
"__llvm_profile_set_filename(char *)``.  These calls can be placed anywhere "
"so long as they precede all calls to ``__llvm_profile_write_file``."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:350
msgid ""
"Forward-declare ``int __llvm_profile_write_file(void)`` and call it to write "
"out a profile. This function returns 0 when it succeeds, and a non-zero "
"value otherwise. Calling this function multiple times appends profile data "
"to an existing on-disk raw profile."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:355
#: ../../../SourceBasedCodeCoverage.rst:383
msgid "In C++ files, declare these as ``extern \"C\"``."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:358
msgid "Using the profiling runtime without a filesystem"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:360
msgid ""
"The profiling runtime also supports freestanding environments that lack a "
"filesystem. The runtime ships as a static archive that's structured to make "
"dependencies on a hosted environment optional, depending on what features "
"the client application uses."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:365
msgid ""
"The first step is to export ``__llvm_profile_runtime``, as above, to disable "
"the default static initializers. Instead of calling the ``*_file()`` APIs "
"described above, use the following to save the profile directly to a buffer "
"under your control:"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:370
msgid ""
"Forward-declare ``uint64_t __llvm_profile_get_size_for_buffer(void)`` and "
"call it to determine the size of the profile. You'll need to allocate a "
"buffer of this size."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:374
msgid ""
"Forward-declare ``int __llvm_profile_write_buffer(char *Buffer)`` and call "
"it to copy the current counters to ``Buffer``, which is expected to already "
"be allocated and big enough for the profile."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:378
msgid ""
"Optionally, forward-declare ``void __llvm_profile_reset_counters(void)`` and "
"call it to reset the counters before entering a specific section to be "
"profiled. This is only useful if there is some setup that should be excluded "
"from the profile."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:386
msgid "Collecting coverage reports for the llvm project"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:388
msgid ""
"To prepare a coverage report for llvm (and any of its sub-projects), add ``-"
"DLLVM_BUILD_INSTRUMENTED_COVERAGE=On`` to the cmake configuration. Raw "
"profiles will be written to ``$BUILD_DIR/profiles/``. To prepare an html "
"report, run ``llvm/utils/prepare-code-coverage-artifact.py``."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:393
msgid ""
"To specify an alternate directory for raw profiles, use ``-"
"DLLVM_PROFILE_DATA_DIR``. To change the size of the profile merge pool, use "
"``-DLLVM_PROFILE_MERGE_POOL_SIZE``."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:398
msgid "Drawbacks and limitations"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:400
msgid ""
"Prior to version 2.26, the GNU binutils BFD linker is not able link programs "
"compiled with ``-fcoverage-mapping`` in its ``--gc-sections`` mode.  "
"Possible workarounds include disabling ``--gc-sections``, upgrading to a "
"newer version of BFD, or using the Gold linker."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:405
msgid ""
"Code coverage does not handle unpredictable changes in control flow or stack "
"unwinding in the presence of exceptions precisely. Consider the following "
"function:"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:416
msgid ""
"If the call to ``may_throw()`` propagates an exception into ``f``, the code "
"coverage tool may mark the ``return`` statement as executed even though it "
"is not. A call to ``longjmp()`` can have similar effects."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:421
msgid "Clang implementation details"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:423
msgid ""
"This section may be of interest to those wishing to understand or improve "
"the clang code coverage implementation."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:427
msgid "Gap regions"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:429
msgid ""
"Gap regions are source regions with counts. A reporting tool cannot set a "
"line execution count to the count from a gap region unless that region is "
"the only one on a line."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:433
msgid ""
"Gap regions are used to eliminate unnatural artifacts in coverage reports, "
"such as red \"unexecuted\" highlights present at the end of an otherwise "
"covered line, or blue \"executed\" highlights present at the start of a line "
"that is otherwise not executed."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:439
msgid "Branch regions"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:440
msgid ""
"When viewing branch coverage details in source-based file-level sub-views "
"using ``--show-branches``, it is recommended that users show all macro "
"expansions (using option ``--show-expansions``) since macros may contain "
"hidden branch conditions.  The coverage summary report will always include "
"these macro-based boolean expressions in the overall branch coverage count "
"for a function or source file."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:447
msgid ""
"Branch coverage is not tracked for constant folded branch conditions since "
"branches are not generated for these cases.  In the source-based file-level "
"sub-view, these branches will simply be shown as ``[Folded - Ignored]`` so "
"that users are informed about what happened."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:452
msgid ""
"Branch coverage is tied directly to branch-generating conditions in the "
"source code.  Users should not see hidden branches that aren't actually tied "
"to the source code."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:458
msgid "Switch statements"
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:460
msgid ""
"The region mapping for a switch body consists of a gap region that covers "
"the entire body (starting from the '{' in 'switch (...) {', and terminating "
"where the last case ends). This gap region has a zero count: this causes "
"\"gap\" areas in between case statements, which contain no executable code, "
"to appear uncovered."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:465
msgid ""
"When a switch case is visited, the parent region is extended: if the parent "
"region has no start location, its start location becomes the start of the "
"case. This is used to support switch statements without a ``CompoundStmt`` "
"body, in which the switch body and the single case share a count."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:470
msgid ""
"For switches with ``CompoundStmt`` bodies, a new region is created at the "
"start of each switch case."
msgstr ""

#: ../../../SourceBasedCodeCoverage.rst:473
msgid ""
"Branch regions are also generated for each switch case, including the "
"default case. If there is no explicitly defined default case in the source "
"code, a branch region is generated to correspond to the implicit default "
"case that is generated by the compiler.  The implicit branch region is tied "
"to the line and column number of the switch statement condition since no "
"source code for the implicit case exists."
msgstr ""
