# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2025, The Clang Team
# This file is distributed under the same license as the Clang package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Clang 17\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-13 13:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../StandardCPlusPlusModules.rst:3
msgid "Standard C++ Modules"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:9
msgid "Introduction"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:11
msgid ""
"The term ``modules`` has a lot of meanings. For the users of Clang, modules "
"may refer to ``Objective-C Modules``, ``Clang C++ Modules`` (or ``Clang "
"Header Modules``, etc.) or ``Standard C++ Modules``. The implementation of "
"all these kinds of modules in Clang has a lot of shared code, but from the "
"perspective of users, their semantics and command line interfaces are very "
"different. This document focuses on an introduction of how to use standard C+"
"+ modules in Clang."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:18
msgid ""
"There is already a detailed document about `Clang modules <Modules.html>`_, "
"it should be helpful to read `Clang modules <Modules.html>`_ if you want to "
"know more about the general idea of modules. Since standard C++ modules have "
"different semantics (and work flows) from `Clang modules`, this page "
"describes the background and use of Clang with standard C++ modules."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:24
msgid ""
"Modules exist in two forms in the C++ Language Specification. They can refer "
"to either \"Named Modules\" or to \"Header Units\". This document covers "
"both forms."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:28
msgid "Standard C++ Named modules"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:30
msgid ""
"This document was intended to be a manual first and foremost, however, we "
"consider it helpful to introduce some language background here for readers "
"who are not familiar with the new language feature. This document is not "
"intended to be a language tutorial; it will only introduce necessary "
"concepts about the structure and building of the project."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:37
msgid "Background and terminology"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:40
msgid "Modules"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:42
msgid ""
"In this document, the term ``Modules``/``modules`` refers to standard C++ "
"modules feature if it is not decorated by ``Clang``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:46
msgid "Clang Modules"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:48
msgid ""
"In this document, the term ``Clang Modules``/``Clang modules`` refer to "
"Clang c++ modules extension. These are also known as ``Clang header "
"modules``, ``Clang module map modules`` or ``Clang c++ modules``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:53
msgid "Module and module unit"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:55
msgid ""
"A module consists of one or more module units. A module unit is a special "
"translation unit. Every module unit must have a module declaration. The "
"syntax of the module declaration is:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:63
msgid ""
"Terms enclosed in ``[]`` are optional. The syntax of ``module_name`` and "
"``partition_name`` in regex form corresponds to ``[a-zA-Z_][a-zA-"
"Z_0-9\\.]*``. In particular, a literal dot ``.`` in the name has no semantic "
"meaning (e.g. implying a hierarchy)."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:67
msgid "In this document, module units are classified into:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:69
msgid "Primary module interface unit."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:71
msgid "Module implementation unit."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:73
msgid "Module interface partition unit."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:75
msgid "Internal module partition unit."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:77
msgid ""
"A primary module interface unit is a module unit whose module declaration is "
"``export module module_name;``. The ``module_name`` here denotes the name of "
"the module. A module should have one and only one primary module interface "
"unit."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:81
msgid ""
"A module implementation unit is a module unit whose module declaration is "
"``module module_name;``. A module could have multiple module implementation "
"units with the same declaration."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:85
msgid ""
"A module interface partition unit is a module unit whose module declaration "
"is ``export module module_name:partition_name;``. The ``partition_name`` "
"should be unique within any given module."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:89
msgid ""
"An internal module partition unit is a module unit whose module declaration "
"is ``module module_name:partition_name;``. The ``partition_name`` should be "
"unique within any given module."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:93
msgid "In this document, we use the following umbrella terms:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:95
msgid ""
"A ``module interface unit`` refers to either a ``primary module interface "
"unit`` or a ``module interface partition unit``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:98
msgid ""
"An ``importable module unit`` refers to either a ``module interface unit`` "
"or a ``internal module partition unit``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:101
msgid ""
"A ``module partition unit`` refers to either a ``module interface partition "
"unit`` or a ``internal module partition unit``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:105
msgid "Built Module Interface file"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:107
msgid ""
"A ``Built Module Interface file`` stands for the precompiled result of an "
"importable module unit. It is also called the acronym ``BMI`` generally."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:111
msgid "Global module fragment"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:113
msgid ""
"In a module unit, the section from ``module;`` to the module declaration is "
"called the global module fragment."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:117
msgid "How to build projects using modules"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:120
#: ../../../StandardCPlusPlusModules.rst:705
msgid "Quick Start"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:122
msgid "Let's see a \"hello world\" example that uses modules."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:141
msgid "Then we type:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:150
msgid ""
"In this example, we make and use a simple module ``Hello`` which contains "
"only a primary module interface unit ``Hello.cppm``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:153
msgid ""
"Then let's see a little bit more complex \"hello world\" example which uses "
"the 4 kinds of module units."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:195
msgid "Then we are able to compile the example by the following command:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:214
msgid "We explain the options in the following sections."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:217
msgid "How to enable standard C++ modules"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:219
msgid ""
"Currently, standard C++ modules are enabled automatically if the language "
"standard is ``-std=c++20`` or newer. The ``-fmodules-ts`` option is "
"deprecated and is planned to be removed."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:224
msgid "How to produce a BMI"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:226
msgid ""
"We can generate a BMI for an importable module unit by either ``--"
"precompile`` or ``-fmodule-output`` flags."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:229
msgid ""
"The ``--precompile`` option generates the BMI as the output of the "
"compilation and the output path can be specified using the ``-o`` option."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:232
msgid ""
"The ``-fmodule-output`` option generates the BMI as a by-product of the "
"compilation. If ``-fmodule-output=`` is specified, the BMI will be emitted "
"the specified location. Then if ``-fmodule-output`` and ``-c`` are "
"specified, the BMI will be emitted in the directory of the output file with "
"the name of the input file with the new extension ``.pcm``. Otherwise, the "
"BMI will be emitted in the working directory with the name of the input file "
"with the new extension ``.pcm``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:239
msgid ""
"The style to generate BMIs by ``--precompile`` is called two-phase "
"compilation since it takes 2 steps to compile a source file to an object "
"file. The style to generate BMIs by ``-fmodule-output`` is called one-phase "
"compilation respectively. The one-phase compilation model is simpler for "
"build systems to implement and the two-phase compilation has the potential "
"to compile faster due to higher parallelism. As an example, if there are two "
"module units A and B, and B depends on A, the one-phase compilation model "
"would need to compile them serially, whereas the two-phase compilation model "
"may be able to compile them simultaneously if the compilation from A.pcm to "
"A.o takes a long time."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:249
msgid "File name requirement"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:251
msgid ""
"The file name of an ``importable module unit`` should end with ``.cppm`` (or "
"``.ccm``, ``.cxxm``, ``.c++m``). The file name of a ``module implementation "
"unit`` should end with ``.cpp`` (or ``.cc``, ``.cxx``, ``.c++``)."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:255
msgid ""
"The file name of BMIs should end with ``.pcm``. The file name of the BMI of "
"a ``primary module interface unit`` should be ``module_name.pcm``. The file "
"name of BMIs of ``module partition unit`` should be ``module_name-"
"partition_name.pcm``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:259
msgid ""
"If the file names use different extensions, Clang may fail to build the "
"module. For example, if the filename of an ``importable module unit`` ends "
"with ``.cpp`` instead of ``.cppm``, then we can't generate a BMI for the "
"``importable module unit`` by ``--precompile`` option since ``--precompile`` "
"option now would only run preprocessor, which is equal to `-E` now. If we "
"want the filename of an ``importable module unit`` ends with other suffixes "
"instead of ``.cppm``, we could put ``-x c++-module`` in front of the file. "
"For example,"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:283
msgid ""
"Now the filename of the ``module interface`` ends with ``.cpp`` instead of "
"``.cppm``, we can't compile them by the original command lines. But we are "
"still able to do it by:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:294
msgid "Module name requirement"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:296
msgid "[module.unit]p1 says:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:306
msgid "So all of the following name is not valid by default:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:316
msgid ""
"If you still want to use the reserved module names for any reason, currently "
"you can add a special line marker in the front of the module declaration "
"like:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:324
msgid ""
"Here the `__LINE_NUMBER__` is the actual line number of the corresponding "
"line. The `__FILE__` means the filename of the translation unit. The `1` "
"means the following is a new file. And `3` means this is a system header/"
"file so the certain warnings should be suppressed. You could find more "
"details at: https://gcc.gnu.org/onlinedocs/gcc-3.0.2/cpp_9.html."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:330
#: ../../../StandardCPlusPlusModules.rst:774
msgid "How to specify the dependent BMIs"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:332
msgid "There are 3 methods to specify the dependent BMIs:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:334
msgid "``-fprebuilt-module-path=<path/to/directory>``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:335
msgid "``-fmodule-file=<path/to/BMI>`` (Deprecated)."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:336
msgid "``-fmodule-file=<module-name>=<path/to/BMI>``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:338
msgid ""
"The option ``-fprebuilt-module-path`` tells the compiler the path where to "
"search for dependent BMIs. It may be used multiple times just like ``-I`` "
"for specifying paths for header files. The look up rule here is:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:341
msgid ""
"(1) When we import module M. The compiler would look up M.pcm in the "
"directories specified by ``-fprebuilt-module-path``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:343
msgid ""
"(2) When we import partition module unit M:P. The compiler would look up M-P."
"pcm in the directories specified by ``-fprebuilt-module-path``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:346
msgid ""
"The option ``-fmodule-file=<path/to/BMI>`` tells the compiler to load the "
"specified BMI directly. The option ``-fmodule-file=<module-name>=<path/to/"
"BMI>`` tells the compiler to load the specified BMI for the module specified "
"by ``<module-name>`` when necessary. The main difference is that ``-fmodule-"
"file=<path/to/BMI>`` will load the BMI eagerly, whereas ``-fmodule-"
"file=<module-name>=<path/to/BMI>`` will only load the BMI lazily, which is "
"similar with ``-fprebuilt-module-path``. The option ``-fmodule-file=<path/to/"
"BMI>`` for named modules is deprecated and is planning to be removed in "
"future versions."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:354
msgid ""
"In case all ``-fprebuilt-module-path=<path/to/directory>``, ``-fmodule-"
"file=<path/to/BMI>`` and ``-fmodule-file=<module-name>=<path/to/BMI>`` "
"exist, the ``-fmodule-file=<path/to/BMI>`` option takes highest precedence "
"and ``-fmodule-file=<module-name>=<path/to/BMI>`` will take the second "
"highest precedence."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:359
msgid ""
"When we compile a ``module implementation unit``, we must specify the BMI of "
"the corresponding ``primary module interface unit``. Since the language "
"specification says a module implementation unit implicitly imports the "
"primary module interface unit."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:364
msgid "[module.unit]p8"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:366
msgid ""
"A module-declaration that contains neither an export-keyword nor a module-"
"partition implicitly imports the primary module interface unit of the module "
"as if by a module-import-declaration."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:369
msgid ""
"All of the 3 options ``-fprebuilt-module-path=<path/to/directory>``, ``-"
"fmodule-file=<path/to/BMI>`` and ``-fmodule-file=<module-name>=<path/to/"
"BMI>`` may occur multiple times. For example, the command line to compile "
"``M.cppm`` in the above example could be rewritten into:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:378
msgid ""
"``-fprebuilt-module-path`` is more convenient and ``-fmodule-file`` is "
"faster since it saves time for file lookup."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:382
msgid "Remember that module units still have an object counterpart to the BMI"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:384
msgid ""
"It is easy to forget to compile BMIs at first since we may envision module "
"interfaces like headers. However, this is not true. Module units are "
"translation units. We need to compile them to object files and link the "
"object files like the example shows."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:389
msgid ""
"For example, the traditional compilation processes for headers are like:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:398
msgid "And the compilation process for module units are like:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:407
msgid ""
"As the diagrams show, we need to compile the BMI from module units to object "
"files and link the object files. (But we can't do this for the BMI from "
"header units. See the later section for the definition of header units)"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:410
msgid ""
"If we want to create a module library, we can't just ship the BMIs in an "
"archive. We must compile these BMIs(``*.pcm``) into object files(``*.o``) "
"and add those object files to the archive instead."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:414
msgid "Consistency Requirement"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:416
msgid ""
"If we envision modules as a cache to speed up compilation, then - as with "
"other caching techniques - it is important to keep cache consistency. So "
"**currently** Clang will do very strict check for consistency."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:421
msgid "Options consistency"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:423
msgid ""
"The language option of module units and their non-module-unit users should "
"be consistent. The following example is not allowed:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:439
msgid ""
"The compiler would reject the example due to the inconsistent language "
"options. Not all options are language options. For example, the following "
"example is allowed:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:451
msgid ""
"Although the two examples have inconsistent optimization and debugging "
"level, both of them are accepted."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:453
msgid ""
"Note that **currently** the compiler doesn't consider inconsistent macro "
"definition a problem. For example:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:461
msgid ""
"Currently Clang would accept the above example. But it may produce "
"surprising results if the debugging code depends on consistent use of "
"``NDEBUG`` also in other translation units."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:465
msgid "ABI Impacts"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:467
msgid ""
"The declarations in a module unit which are not in the global module "
"fragment have new linkage names."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:469
#: ../../../StandardCPlusPlusModules.rst:516
msgid "For example,"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:478
msgid ""
"The linkage name of ``NS::foo()`` would be ``_ZN2NSW1M3fooEv``. This "
"couldn't be demangled by previous versions of the debugger or demangler. As "
"of LLVM 15.x, users can utilize ``llvm-cxxfilt`` to demangle this:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:486
msgid ""
"The result would be ``NS::foo@M()``, which reads as ``NS::foo()`` in module "
"``M``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:488
msgid ""
"The ABI implies that we can't declare something in a module unit and define "
"it in a non-module unit (or vice-versa), as this would result in linking "
"errors."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:491
msgid ""
"If we still want to implement declarations within the compatible ABI in "
"module unit, we can use the language-linkage specifier. Since the "
"declarations in the language-linkage specifier is attached to the global "
"module fragments. For example:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:502
msgid "Now the linkage name of ``NS::foo()`` will be ``_ZN2NS3fooEv``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:505
msgid "Performance Tips"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:508
msgid "Reduce duplications"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:510
msgid ""
"While it is legal to have duplicated declarations in the global module "
"fragments of different module units, it is not free for clang to deal with "
"the duplicated declarations. In other word, for a translation unit, it will "
"compile slower if the translation unit itself and its importing module units "
"contains a lot duplicated declarations."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:552
msgid ""
"When ``big.header.h`` is big enough and there are a lot of partitions, the "
"compilation of ``use.cpp`` may be slower than the following style "
"significantly:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:592
msgid ""
"The key part of the tip is to reduce the duplications from the text includes."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:595
msgid "Known Problems"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:597
msgid ""
"The following describes issues in the current implementation of modules. "
"Please see https://github.com/llvm/llvm-project/labels/clang%3Amodules for "
"more issues or file a new issue if you don't find an existing one. If you're "
"going to create a new issue for standard C++ modules, please start the title "
"with ``[C++20] [Modules]`` (or ``[C++23] [Modules]``, etc) and add the label "
"``clang:modules`` (if you have permissions for that)."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:604
msgid ""
"For higher level support for proposals, you could visit https://clang.llvm."
"org/cxx_status.html."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:607
msgid "Including headers after import is problematic"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:609
msgid "For example, the following example can be accept:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:622
msgid ""
"but it will get rejected if we reverse the order of ``#include <iostream>`` "
"and ``import foo;``:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:636
msgid "Both of the above examples should be accepted."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:638
msgid ""
"This is a limitation in the implementation. In the first example, the "
"compiler will see and parse <iostream> first then the compiler will see the "
"import. So the ODR Checking and declarations merging will happen in the "
"deserializer. In the second example, the compiler will see the import first "
"and the include second. As a result, the ODR Checking and declarations "
"merging will happen in the semantic analyzer."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:644
msgid ""
"So there is divergence in the implementation path. It might be "
"understandable that why the orders matter here in the case. (Note that "
"\"understandable\" is different from \"makes sense\")."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:648
msgid "This is tracked in: https://github.com/llvm/llvm-project/issues/61465"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:651
msgid "Ignored PreferredName Attribute"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:653
msgid ""
"Due to a tricky problem, when Clang writes BMIs, Clang will ignore the "
"``preferred_name`` attribute, if any. This implies that the "
"``preferred_name`` wouldn't show in debugger or dumping."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:656
msgid "This is tracked in: https://github.com/llvm/llvm-project/issues/56490"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:659
msgid "Don't emit macros about module declaration"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:661
msgid ""
"This is covered by P1857R3. We mention it again here since users may abuse "
"it before we implement it."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:663
msgid ""
"Someone may want to write code which could be compiled both by modules or "
"non-modules. A direct idea would be use macros like:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:674
msgid ""
"So this file could be triggered like a module unit or a non-module unit "
"depending on the definition of some macros. However, this kind of usage is "
"forbidden by P1857R3 but we haven't implemented P1857R3 yet. This means that "
"is possible to write illegal modules code now, and obviously this will stop "
"working once P1857R3 is implemented. A simple suggestion would be \"Don't "
"play macro tricks with module declarations\"."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:681
msgid "This is tracked in: https://github.com/llvm/llvm-project/issues/56917"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:684
msgid "In consistent filename suffix requirement for importable module units"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:686
msgid ""
"Currently, clang requires the file name of an ``importable module unit`` "
"should end with ``.cppm`` (or ``.ccm``, ``.cxxm``, ``.c++m``). However, the "
"behavior is inconsistent with other compilers."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:689
msgid "This is tracked in: https://github.com/llvm/llvm-project/issues/57416"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:692
msgid "Header Units"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:695
msgid "How to build projects using header unit"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:699
msgid ""
"The user interfaces of header units is highly experimental. There are still "
"many unanswered question about how tools should interact with header units. "
"The user interfaces described here may change after we have progress on how "
"tools should support for header units."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:707
msgid "For the following example,"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:716
msgid "we could compile it as"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:724
msgid "How to produce BMIs"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:726
msgid ""
"Similar to named modules, we could use ``--precompile`` to produce the BMI. "
"But we need to specify that the input file is a header by ``-xc++-system-"
"header`` or ``-xc++-user-header``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:729
msgid ""
"Also we could use `-fmodule-header={user,system}` option to produce the BMI "
"for header units which has suffix like `.h` or `.hh`. The value of `-fmodule-"
"header` means the user search path or the system search path. The default "
"value for `-fmodule-header` is `user`. For example,"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:749
msgid "We could compile it as:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:756
msgid ""
"For headers which don't have a suffix, we need to pass ``-xc++-header`` (or "
"``-xc++-system-header`` or ``-xc++-user-header``) to mark it as a header. "
"For example,"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:776
msgid ""
"We could use ``-fmodule-file`` to specify the BMIs, and this option may "
"occur multiple times as well."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:778
msgid ""
"With the existing implementation ``-fprebuilt-module-path`` cannot be used "
"for header units (since they are nominally anonymous). For header units, "
"use  ``-fmodule-file`` to include the relevant PCM file for each header unit."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:782
msgid ""
"This is expect to be solved in future editions of the compiler either by the "
"tooling finding and specifying the -fmodule-file or by the use of a module-"
"mapper that understands how to map the header name to their PCMs."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:786
msgid "Don't compile the BMI"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:788
msgid ""
"Another difference with modules is that we can't compile the BMI from a "
"header unit. For example:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:797
msgid ""
"It makes sense due to the semantics of header units, which are just like "
"headers."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:800
msgid "Include translation"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:802
msgid ""
"The C++ spec allows the vendors to convert ``#include header-name`` to "
"``import header-name;`` when possible. Currently, Clang would do this "
"translation for the ``#include`` in the global module fragment."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:805
msgid "For example, the following two examples are the same:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:816
msgid "with the following one:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:832
msgid ""
"In the latter example, the Clang could find the BMI for the ``<iostream>`` "
"so it would try to replace the ``#include <iostream>`` to ``import "
"<iostream>;`` automatically."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:837
msgid "Relationships between Clang modules"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:839
msgid ""
"Header units have pretty similar semantics with Clang modules. The semantics "
"of both of them are like headers."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:842
msgid ""
"In fact, we could even \"mimic\" the sytle of header units by Clang modules:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:855
msgid "It would be simpler if we are using libcxx:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:861
msgid ""
"Since there is already one `module map <https://github.com/llvm/llvm-project/"
"blob/main/libcxx/include/module.modulemap.in>`_ in the source of libcxx."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:865
msgid ""
"Then immediately leads to the question: why don't we implement header units "
"through Clang header modules?"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:867
msgid ""
"The main reason for this is that Clang modules have more semantics like "
"hierarchy or wrapping multiple headers together as a big module. However, "
"these things are not part of Standard C++ Header units, and we want to avoid "
"the impression that these additional semantics get interpreted as Standard C+"
"+ behavior."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:872
msgid ""
"Another reason is that there are proposals to introduce module mappers to "
"the C++ standard (for example, https://wg21.link/p1184r2). If we decide to "
"reuse Clang's modulemap, we may get in trouble once we need to introduce "
"another module mapper."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:876
msgid ""
"So the final answer for why we don't reuse the interface of Clang modules "
"for header units is that there are some differences between header units and "
"Clang modules and that ignoring those differences now would likely become a "
"problem in the future."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:881
msgid "Discover Dependencies"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:883
msgid ""
"Prior to modules, all the translation units can be compiled parallelly. But "
"it is not true for the module units. The presence of module units requires "
"us to compile the translation units in a (topological) order."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:887
msgid ""
"The clang-scan-deps scanner implemented `P1689 paper <https://www.open-std."
"org/jtc1/sc22/wg21/docs/papers/2022/p1689r5.html>`_ to describe the order. "
"Only named modules are supported now."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:891
msgid ""
"We need a compilation database to use clang-scan-deps. See `JSON Compilation "
"Database Format Specification <JSONCompilationDatabase.html>`_ for example. "
"Note that the ``output`` entry is necessary for clang-scan-deps to scan "
"P1689 format. Here is an example:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:937
msgid "And here is the compilation database:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:974
msgid "And we can get the dependency information in P1689 format by:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:980
msgid "And we will get:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1058
msgid "See the P1689 paper for the meaning of the fields."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1060
msgid ""
"And if the user want a finer-grained control for any reason, e.g., to scan "
"the generated source files, the user can choose to get the dependency "
"information per file. For example:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1069
msgid ""
"The ``<path-to-compiler-executable>/clang++`` should point to the real "
"binary and not to a symlink. If it points to a symlink the include paths "
"will not be correctly resolved."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1073
msgid "And we'll get:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1099
msgid ""
"In this way, we can pass the single command line options after the ``--``. "
"Then clang-scan-deps will extract the necessary information from the "
"options. Note that we need to specify the path to the compiler executable "
"instead of saying ``clang++`` simply."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1104
msgid ""
"The users may want the scanner to get the transitional dependency "
"information for headers. Otherwise, the users have to scan twice for the "
"project, once for headers and once for modules. To address the requirement, "
"clang-scan-deps will recognize the specified preprocessor options in the "
"given command line and generate the corresponding dependency information. "
"For example,"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1114
msgid "We will get:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1126
msgid ""
"When clang-scan-deps detects ``-MF`` option, clang-scan-deps will try to "
"write the dependency information for headers to the file specified by ``-"
"MF``."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1130
msgid "Possible Questions"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1133
msgid "How modules speed up compilation"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1135
msgid ""
"A classic theory for the reason why modules speed up the compilation is: if "
"there are ``n`` headers and ``m`` source files and each header is included "
"by each source file, then the complexity of the compilation is ``O(n*m)``; "
"But if there are ``n`` module interfaces and ``m`` source files, the "
"complexity of the compilation is ``O(n+m)``. So, using modules would be a "
"big win when scaling. In a simpler word, we could get rid of many redundant "
"compilations by using modules."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1142
msgid ""
"Roughly, this theory is correct. But the problem is that it is too rough. "
"The behavior depends on the optimization level, as we will illustrate below."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1145
msgid ""
"First is ``O0``. The compilation process is described in the following graph."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1167
msgid ""
"Here we can see that the source file (could be a non-module unit or a module "
"unit) would get processed by the whole pipeline. But the imported code would "
"only get involved in semantic analysis, which is mainly about name lookup, "
"overload resolution and template instantiation. All of these processes are "
"fast relative to the whole compilation process. More importantly, the "
"imported code only needs to be processed once in frontend code generation, "
"as well as the whole middle end and backend. So we could get a big win for "
"the compilation time in O0."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1176
msgid "But with optimizations, things are different:"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1178
msgid ""
"(we omit ``code generation`` part for each end due to the limited space)"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1199
msgid ""
"It would be very unfortunate if we end up with worse performance after using "
"modules. The main concern is that when we compile a source file, the "
"compiler needs to see the function body of imported module units so that it "
"can perform IPO (InterProcedural Optimization, primarily inlining in "
"practice) to optimize functions in current source file with the help of the "
"information provided by the imported module units. In other words, the "
"imported code would be processed again and again in importee units by "
"optimizations (including IPO itself). The optimizations before IPO and the "
"IPO itself are the most time-consuming part in whole compilation process. So "
"from this perspective, we might not be able to get the improvements "
"described in the theory. But we could still save the time for optimizations "
"after IPO and the whole backend."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1210
msgid ""
"Overall, at ``O0`` the implementations of functions defined in a module will "
"not impact module users, but at higher optimization levels the definitions "
"of such functions are provided to user compilations for the purposes of "
"optimization (but definitions of these functions are still not included in "
"the use's object file)- this means the build speedup at higher optimization "
"levels may be lower than expected given ``O0`` experience, but does provide "
"by more optimization opportunities."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1217
msgid "Interoperability with Clang Modules"
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1219
msgid ""
"We **wish** to support clang modules and standard c++ modules at the same "
"time, but the mixed using form is not well used/tested yet."
msgstr ""

#: ../../../StandardCPlusPlusModules.rst:1222
msgid "Please file new github issues as you find interoperability problems."
msgstr ""
