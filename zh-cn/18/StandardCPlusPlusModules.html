<!DOCTYPE html>

<html lang="zh-CN" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Standard C++ Modules &#8212; Clang  文档</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=d75fae25" />
    <link rel="stylesheet" type="text/css" href="_static/haiku.css?v=fce32b03" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css?v=4ae1632d" />
    <script src="_static/documentation_options.js?v=7d86a446"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/translations.js?v=beaddf03"></script>
    <link rel="canonical" href="https://projects.localizethedocs.org/clang-docs-l10n/StandardCPlusPlusModules.html" />
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="搜索" href="search.html" />
    <link rel="next" title="Modules" href="Modules.html" />
    <link rel="prev" title="Source-based Code Coverage" href="SourceBasedCodeCoverage.html" />
<script type="text/javascript" src="ltd-provenance.js"></script>
<script type="text/javascript" src="ltd-current.js"></script>
<script type="text/javascript" src="../../ltd-config.js"></script>
<script type="text/javascript" src="../../ltd-flyout.js"></script>

  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Clang  文档</span></a></h1>
        <h2 class="heading"><span>Standard C++ Modules</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="Top">
      
        <p>
        «&#160;&#160;<a href="SourceBasedCodeCoverage.html">Source-based Code Coverage</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">目录</a>
        &#160;&#160;::&#160;&#160;
        <a href="Modules.html">Modules</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="standard-c-modules">
<h1>Standard C++ Modules<a class="headerlink" href="#standard-c-modules" title="Link to this heading">¶</a></h1>
<nav class="contents local" id="id1">
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id6">Introduction</a></p></li>
<li><p><a class="reference internal" href="#standard-c-named-modules" id="id7">Standard C++ Named modules</a></p>
<ul>
<li><p><a class="reference internal" href="#background-and-terminology" id="id8">Background and terminology</a></p>
<ul>
<li><p><a class="reference internal" href="#modules" id="id9">Modules</a></p></li>
<li><p><a class="reference internal" href="#id3" id="id10">Clang Modules</a></p></li>
<li><p><a class="reference internal" href="#module-and-module-unit" id="id11">Module and module unit</a></p></li>
<li><p><a class="reference internal" href="#built-module-interface-file" id="id12">Built Module Interface file</a></p></li>
<li><p><a class="reference internal" href="#global-module-fragment" id="id13">Global module fragment</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#how-to-build-projects-using-modules" id="id14">How to build projects using modules</a></p>
<ul>
<li><p><a class="reference internal" href="#quick-start" id="id15">Quick Start</a></p></li>
<li><p><a class="reference internal" href="#how-to-enable-standard-c-modules" id="id16">How to enable standard C++ modules</a></p></li>
<li><p><a class="reference internal" href="#how-to-produce-a-bmi" id="id17">How to produce a BMI</a></p></li>
<li><p><a class="reference internal" href="#file-name-requirement" id="id18">File name requirement</a></p></li>
<li><p><a class="reference internal" href="#module-name-requirement" id="id19">Module name requirement</a></p></li>
<li><p><a class="reference internal" href="#how-to-specify-the-dependent-bmis" id="id20">How to specify the dependent BMIs</a></p></li>
<li><p><a class="reference internal" href="#remember-that-module-units-still-have-an-object-counterpart-to-the-bmi" id="id21">Remember that module units still have an object counterpart to the BMI</a></p></li>
<li><p><a class="reference internal" href="#consistency-requirement" id="id22">Consistency Requirement</a></p>
<ul>
<li><p><a class="reference internal" href="#options-consistency" id="id23">Options consistency</a></p></li>
<li><p><a class="reference internal" href="#definitions-consistency" id="id24">Definitions consistency</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#abi-impacts" id="id25">ABI Impacts</a></p></li>
<li><p><a class="reference internal" href="#performance-tips" id="id26">Performance Tips</a></p>
<ul>
<li><p><a class="reference internal" href="#reduce-duplications" id="id27">Reduce duplications</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#known-problems" id="id28">Known Problems</a></p>
<ul>
<li><p><a class="reference internal" href="#including-headers-after-import-is-problematic" id="id29">Including headers after import is problematic</a></p></li>
<li><p><a class="reference internal" href="#ignored-preferredname-attribute" id="id30">Ignored PreferredName Attribute</a></p></li>
<li><p><a class="reference internal" href="#don-t-emit-macros-about-module-declaration" id="id31">Don't emit macros about module declaration</a></p></li>
<li><p><a class="reference internal" href="#in-consistent-filename-suffix-requirement-for-importable-module-units" id="id32">In consistent filename suffix requirement for importable module units</a></p></li>
<li><p><a class="reference internal" href="#clang-cl-is-not-compatible-with-the-standard-c-modules" id="id33">clang-cl is not compatible with the standard C++ modules</a></p></li>
<li><p><a class="reference internal" href="#false-positive-odr-violation-diagnostic-due-to-using-inconsistent-qualified-but-the-same-type" id="id34">false positive ODR violation diagnostic due to using inconsistent qualified but the same type</a></p></li>
<li><p><a class="reference internal" href="#using-tu-local-entity-in-other-units" id="id35">Using TU-local entity in other units</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#header-units" id="id36">Header Units</a></p>
<ul>
<li><p><a class="reference internal" href="#how-to-build-projects-using-header-unit" id="id37">How to build projects using header unit</a></p>
<ul>
<li><p><a class="reference internal" href="#id4" id="id38">Quick Start</a></p></li>
<li><p><a class="reference internal" href="#how-to-produce-bmis" id="id39">How to produce BMIs</a></p></li>
<li><p><a class="reference internal" href="#id5" id="id40">How to specify the dependent BMIs</a></p></li>
<li><p><a class="reference internal" href="#don-t-compile-the-bmi" id="id41">Don't compile the BMI</a></p></li>
<li><p><a class="reference internal" href="#include-translation" id="id42">Include translation</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#relationships-between-clang-modules" id="id43">Relationships between Clang modules</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#discover-dependencies" id="id44">Discover Dependencies</a></p>
<ul>
<li><p><a class="reference internal" href="#possible-issues-failed-to-find-system-headers" id="id45">Possible Issues: Failed to find system headers</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#possible-questions" id="id46">Possible Questions</a></p>
<ul>
<li><p><a class="reference internal" href="#how-modules-speed-up-compilation" id="id47">How modules speed up compilation</a></p></li>
<li><p><a class="reference internal" href="#interoperability-with-clang-modules" id="id48">Interoperability with Clang Modules</a></p></li>
</ul>
</li>
</ul>
</nav>
<section id="introduction">
<h2><a class="toc-backref" href="#id6" role="doc-backlink">Introduction</a><a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p>The term <code class="docutils literal notranslate"><span class="pre">modules</span></code> has a lot of meanings. For the users of Clang, modules may
refer to <code class="docutils literal notranslate"><span class="pre">Objective-C</span> <span class="pre">Modules</span></code>, <code class="docutils literal notranslate"><span class="pre">Clang</span> <span class="pre">C++</span> <span class="pre">Modules</span></code> (or <code class="docutils literal notranslate"><span class="pre">Clang</span> <span class="pre">Header</span> <span class="pre">Modules</span></code>,
etc.) or <code class="docutils literal notranslate"><span class="pre">Standard</span> <span class="pre">C++</span> <span class="pre">Modules</span></code>. The implementation of all these kinds of modules in Clang
has a lot of shared code, but from the perspective of users, their semantics and
command line interfaces are very different. This document focuses on
an introduction of how to use standard C++ modules in Clang.</p>
<p>There is already a detailed document about <a class="reference external" href="Modules.html">Clang modules</a>, it
should be helpful to read <a class="reference external" href="Modules.html">Clang modules</a> if you want to know
more about the general idea of modules. Since standard C++ modules have different semantics
(and work flows) from <cite>Clang modules</cite>, this page describes the background and use of
Clang with standard C++ modules.</p>
<p>Modules exist in two forms in the C++ Language Specification. They can refer to
either &quot;Named Modules&quot; or to &quot;Header Units&quot;. This document covers both forms.</p>
</section>
<section id="standard-c-named-modules">
<h2><a class="toc-backref" href="#id7" role="doc-backlink">Standard C++ Named modules</a><a class="headerlink" href="#standard-c-named-modules" title="Link to this heading">¶</a></h2>
<p>This document was intended to be a manual first and foremost, however, we consider it helpful to
introduce some language background here for readers who are not familiar with
the new language feature. This document is not intended to be a language
tutorial; it will only introduce necessary concepts about the
structure and building of the project.</p>
<section id="background-and-terminology">
<h3><a class="toc-backref" href="#id8" role="doc-backlink">Background and terminology</a><a class="headerlink" href="#background-and-terminology" title="Link to this heading">¶</a></h3>
<section id="modules">
<h4><a class="toc-backref" href="#id9" role="doc-backlink">Modules</a><a class="headerlink" href="#modules" title="Link to this heading">¶</a></h4>
<p>In this document, the term <code class="docutils literal notranslate"><span class="pre">Modules</span></code>/<code class="docutils literal notranslate"><span class="pre">modules</span></code> refers to standard C++ modules
feature if it is not decorated by <code class="docutils literal notranslate"><span class="pre">Clang</span></code>.</p>
</section>
<section id="id3">
<h4><a class="toc-backref" href="#id10" role="doc-backlink">Clang Modules</a><a class="headerlink" href="#id3" title="Link to this heading">¶</a></h4>
<p>In this document, the term <code class="docutils literal notranslate"><span class="pre">Clang</span> <span class="pre">Modules</span></code>/<code class="docutils literal notranslate"><span class="pre">Clang</span> <span class="pre">modules</span></code> refer to Clang
c++ modules extension. These are also known as <code class="docutils literal notranslate"><span class="pre">Clang</span> <span class="pre">header</span> <span class="pre">modules</span></code>,
<code class="docutils literal notranslate"><span class="pre">Clang</span> <span class="pre">module</span> <span class="pre">map</span> <span class="pre">modules</span></code> or <code class="docutils literal notranslate"><span class="pre">Clang</span> <span class="pre">c++</span> <span class="pre">modules</span></code>.</p>
</section>
<section id="module-and-module-unit">
<h4><a class="toc-backref" href="#id11" role="doc-backlink">Module and module unit</a><a class="headerlink" href="#module-and-module-unit" title="Link to this heading">¶</a></h4>
<p>A module consists of one or more module units. A module unit is a special
translation unit. Every module unit must have a module declaration. The syntax
of the module declaration is:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="k">export</span><span class="p">]</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">module_name</span><span class="p">[</span><span class="o">:</span><span class="n">partition_name</span><span class="p">];</span>
</pre></div>
</div>
<p>Terms enclosed in <code class="docutils literal notranslate"><span class="pre">[]</span></code> are optional. The syntax of <code class="docutils literal notranslate"><span class="pre">module_name</span></code> and <code class="docutils literal notranslate"><span class="pre">partition_name</span></code>
in regex form corresponds to <code class="docutils literal notranslate"><span class="pre">[a-zA-Z_][a-zA-Z_0-9\.]*</span></code>. In particular, a literal dot <code class="docutils literal notranslate"><span class="pre">.</span></code>
in the name has no semantic meaning (e.g. implying a hierarchy).</p>
<p>In this document, module units are classified into:</p>
<ul class="simple">
<li><p>Primary module interface unit.</p></li>
<li><p>Module implementation unit.</p></li>
<li><p>Module interface partition unit.</p></li>
<li><p>Internal module partition unit.</p></li>
</ul>
<p>A primary module interface unit is a module unit whose module declaration is
<code class="docutils literal notranslate"><span class="pre">export</span> <span class="pre">module</span> <span class="pre">module_name;</span></code>. The <code class="docutils literal notranslate"><span class="pre">module_name</span></code> here denotes the name of the
module. A module should have one and only one primary module interface unit.</p>
<p>A module implementation unit is a module unit whose module declaration is
<code class="docutils literal notranslate"><span class="pre">module</span> <span class="pre">module_name;</span></code>. A module could have multiple module implementation
units with the same declaration.</p>
<p>A module interface partition unit is a module unit whose module declaration is
<code class="docutils literal notranslate"><span class="pre">export</span> <span class="pre">module</span> <span class="pre">module_name:partition_name;</span></code>. The <code class="docutils literal notranslate"><span class="pre">partition_name</span></code> should be
unique within any given module.</p>
<p>An internal module partition unit is a module unit whose module declaration
is <code class="docutils literal notranslate"><span class="pre">module</span> <span class="pre">module_name:partition_name;</span></code>. The <code class="docutils literal notranslate"><span class="pre">partition_name</span></code> should be
unique within any given module.</p>
<p>In this document, we use the following umbrella terms:</p>
<ul class="simple">
<li><p>A <code class="docutils literal notranslate"><span class="pre">module</span> <span class="pre">interface</span> <span class="pre">unit</span></code> refers to either a <code class="docutils literal notranslate"><span class="pre">primary</span> <span class="pre">module</span> <span class="pre">interface</span> <span class="pre">unit</span></code>
or a <code class="docutils literal notranslate"><span class="pre">module</span> <span class="pre">interface</span> <span class="pre">partition</span> <span class="pre">unit</span></code>.</p></li>
<li><p>An <code class="docutils literal notranslate"><span class="pre">importable</span> <span class="pre">module</span> <span class="pre">unit</span></code> refers to either a <code class="docutils literal notranslate"><span class="pre">module</span> <span class="pre">interface</span> <span class="pre">unit</span></code>
or a <code class="docutils literal notranslate"><span class="pre">internal</span> <span class="pre">module</span> <span class="pre">partition</span> <span class="pre">unit</span></code>.</p></li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">module</span> <span class="pre">partition</span> <span class="pre">unit</span></code> refers to either a <code class="docutils literal notranslate"><span class="pre">module</span> <span class="pre">interface</span> <span class="pre">partition</span> <span class="pre">unit</span></code>
or a <code class="docutils literal notranslate"><span class="pre">internal</span> <span class="pre">module</span> <span class="pre">partition</span> <span class="pre">unit</span></code>.</p></li>
</ul>
</section>
<section id="built-module-interface-file">
<h4><a class="toc-backref" href="#id12" role="doc-backlink">Built Module Interface file</a><a class="headerlink" href="#built-module-interface-file" title="Link to this heading">¶</a></h4>
<p>A <code class="docutils literal notranslate"><span class="pre">Built</span> <span class="pre">Module</span> <span class="pre">Interface</span> <span class="pre">file</span></code> stands for the precompiled result of an importable module unit.
It is also called the acronym <code class="docutils literal notranslate"><span class="pre">BMI</span></code> generally.</p>
</section>
<section id="global-module-fragment">
<h4><a class="toc-backref" href="#id13" role="doc-backlink">Global module fragment</a><a class="headerlink" href="#global-module-fragment" title="Link to this heading">¶</a></h4>
<p>In a module unit, the section from <code class="docutils literal notranslate"><span class="pre">module;</span></code> to the module declaration is called the global module fragment.</p>
</section>
</section>
<section id="how-to-build-projects-using-modules">
<h3><a class="toc-backref" href="#id14" role="doc-backlink">How to build projects using modules</a><a class="headerlink" href="#how-to-build-projects-using-modules" title="Link to this heading">¶</a></h3>
<section id="quick-start">
<h4><a class="toc-backref" href="#id15" role="doc-backlink">Quick Start</a><a class="headerlink" href="#quick-start" title="Link to this heading">¶</a></h4>
<p>Let's see a &quot;hello world&quot; example that uses modules.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Hello.cppm</span>
<span class="k">module</span><span class="p">;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">Hello</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">hello</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Hello World!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// use.cpp</span>
<span class="k">import</span><span class="w"> </span><span class="n">Hello</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">hello</span><span class="p">();</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Then we type:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>Hello.cppm<span class="w"> </span>--precompile<span class="w"> </span>-o<span class="w"> </span>Hello.pcm
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>use.cpp<span class="w"> </span>-fmodule-file<span class="o">=</span><span class="nv">Hello</span><span class="o">=</span>Hello.pcm<span class="w"> </span>Hello.pcm<span class="w"> </span>-o<span class="w"> </span>Hello.out
<span class="gp">$ </span>./Hello.out
<span class="go">Hello World!</span>
</pre></div>
</div>
<p>In this example, we make and use a simple module <code class="docutils literal notranslate"><span class="pre">Hello</span></code> which contains only a
primary module interface unit <code class="docutils literal notranslate"><span class="pre">Hello.cppm</span></code>.</p>
<p>Then let's see a little bit more complex &quot;hello world&quot; example which uses the 4 kinds of module units.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// M.cppm</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="k">import</span><span class="w"> </span><span class="o">:</span><span class="n">interface_part</span><span class="p">;</span>
<span class="nl">import</span><span class="w"> </span><span class="p">:</span><span class="n">impl_part</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">Hello</span><span class="p">();</span>

<span class="c1">// interface_part.cppm</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="o">:</span><span class="n">interface_part</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">World</span><span class="p">();</span>

<span class="c1">// impl_part.cppm</span>
<span class="k">module</span><span class="p">;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span>
<span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="o">:</span><span class="n">impl_part</span><span class="p">;</span>
<span class="nl">import</span><span class="w"> </span><span class="p">:</span><span class="n">interface_part</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">W</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;World.&quot;</span><span class="p">;</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">World</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">W</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Impl.cpp</span>
<span class="k">module</span><span class="p">;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">Hello</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Hello &quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// User.cpp</span>
<span class="k">import</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">Hello</span><span class="p">();</span>
<span class="w">  </span><span class="n">World</span><span class="p">();</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Then we are able to compile the example by the following command:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>Precompiling<span class="w"> </span>the<span class="w"> </span>module
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>interface_part.cppm<span class="w"> </span>--precompile<span class="w"> </span>-o<span class="w"> </span>M-interface_part.pcm
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>impl_part.cppm<span class="w"> </span>--precompile<span class="w"> </span>-fprebuilt-module-path<span class="o">=</span>.<span class="w"> </span>-o<span class="w"> </span>M-impl_part.pcm
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>M.cppm<span class="w"> </span>--precompile<span class="w"> </span>-fprebuilt-module-path<span class="o">=</span>.<span class="w"> </span>-o<span class="w"> </span>M.pcm
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>Impl.cpp<span class="w"> </span>-fprebuilt-module-path<span class="o">=</span>.<span class="w"> </span>-c<span class="w"> </span>-o<span class="w"> </span>Impl.o

<span class="gp"># </span>Compiling<span class="w"> </span>the<span class="w"> </span>user
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>User.cpp<span class="w"> </span>-fprebuilt-module-path<span class="o">=</span>.<span class="w"> </span>-c<span class="w"> </span>-o<span class="w"> </span>User.o

<span class="gp"># </span>Compiling<span class="w"> </span>the<span class="w"> </span>module<span class="w"> </span>and<span class="w"> </span>linking<span class="w"> </span>it<span class="w"> </span>together
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>M-interface_part.pcm<span class="w"> </span>-fprebuilt-module-path<span class="o">=</span>.<span class="w"> </span>-c<span class="w"> </span>-o<span class="w"> </span>M-interface_part.o
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>M-impl_part.pcm<span class="w"> </span>-fprebuilt-module-path<span class="o">=</span>.<span class="w"> </span>-c<span class="w"> </span>-o<span class="w"> </span>M-impl_part.o
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>M.pcm<span class="w"> </span>-fprebuilt-module-path<span class="o">=</span>.<span class="w"> </span>-c<span class="w"> </span>-o<span class="w"> </span>M.o
<span class="gp">$ </span>clang++<span class="w"> </span>User.o<span class="w"> </span>M-interface_part.o<span class="w">  </span>M-impl_part.o<span class="w"> </span>M.o<span class="w"> </span>Impl.o<span class="w"> </span>-o<span class="w"> </span>a.out
</pre></div>
</div>
<p>We explain the options in the following sections.</p>
</section>
<section id="how-to-enable-standard-c-modules">
<h4><a class="toc-backref" href="#id16" role="doc-backlink">How to enable standard C++ modules</a><a class="headerlink" href="#how-to-enable-standard-c-modules" title="Link to this heading">¶</a></h4>
<p>Currently, standard C++ modules are enabled automatically
if the language standard is <code class="docutils literal notranslate"><span class="pre">-std=c++20</span></code> or newer.</p>
</section>
<section id="how-to-produce-a-bmi">
<h4><a class="toc-backref" href="#id17" role="doc-backlink">How to produce a BMI</a><a class="headerlink" href="#how-to-produce-a-bmi" title="Link to this heading">¶</a></h4>
<p>We can generate a BMI for an importable module unit by either <code class="docutils literal notranslate"><span class="pre">--precompile</span></code>
or <code class="docutils literal notranslate"><span class="pre">-fmodule-output</span></code> flags.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">--precompile</span></code> option generates the BMI as the output of the compilation and the output path
can be specified using the <code class="docutils literal notranslate"><span class="pre">-o</span></code> option.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">-fmodule-output</span></code> option generates the BMI as a by-product of the compilation.
If <code class="docutils literal notranslate"><span class="pre">-fmodule-output=</span></code> is specified, the BMI will be emitted the specified location. Then if
<code class="docutils literal notranslate"><span class="pre">-fmodule-output</span></code> and <code class="docutils literal notranslate"><span class="pre">-c</span></code> are specified, the BMI will be emitted in the directory of the
output file with the name of the input file with the new extension <code class="docutils literal notranslate"><span class="pre">.pcm</span></code>. Otherwise, the BMI
will be emitted in the working directory with the name of the input file with the new extension
<code class="docutils literal notranslate"><span class="pre">.pcm</span></code>.</p>
<p>The style to generate BMIs by <code class="docutils literal notranslate"><span class="pre">--precompile</span></code> is called two-phase compilation since it takes
2 steps to compile a source file to an object file. The style to generate BMIs by <code class="docutils literal notranslate"><span class="pre">-fmodule-output</span></code>
is called one-phase compilation respectively. The one-phase compilation model is simpler
for build systems to implement and the two-phase compilation has the potential to compile faster due
to higher parallelism. As an example, if there are two module units A and B, and B depends on A, the
one-phase compilation model would need to compile them serially, whereas the two-phase compilation
model may be able to compile them simultaneously if the compilation from A.pcm to A.o takes a long
time.</p>
</section>
<section id="file-name-requirement">
<h4><a class="toc-backref" href="#id18" role="doc-backlink">File name requirement</a><a class="headerlink" href="#file-name-requirement" title="Link to this heading">¶</a></h4>
<p>The file name of an <code class="docutils literal notranslate"><span class="pre">importable</span> <span class="pre">module</span> <span class="pre">unit</span></code> should end with <code class="docutils literal notranslate"><span class="pre">.cppm</span></code>
(or <code class="docutils literal notranslate"><span class="pre">.ccm</span></code>, <code class="docutils literal notranslate"><span class="pre">.cxxm</span></code>, <code class="docutils literal notranslate"><span class="pre">.c++m</span></code>). The file name of a <code class="docutils literal notranslate"><span class="pre">module</span> <span class="pre">implementation</span> <span class="pre">unit</span></code>
should end with <code class="docutils literal notranslate"><span class="pre">.cpp</span></code> (or <code class="docutils literal notranslate"><span class="pre">.cc</span></code>, <code class="docutils literal notranslate"><span class="pre">.cxx</span></code>, <code class="docutils literal notranslate"><span class="pre">.c++</span></code>).</p>
<p>The file name of BMIs should end with <code class="docutils literal notranslate"><span class="pre">.pcm</span></code>.
The file name of the BMI of a <code class="docutils literal notranslate"><span class="pre">primary</span> <span class="pre">module</span> <span class="pre">interface</span> <span class="pre">unit</span></code> should be <code class="docutils literal notranslate"><span class="pre">module_name.pcm</span></code>.
The file name of BMIs of <code class="docutils literal notranslate"><span class="pre">module</span> <span class="pre">partition</span> <span class="pre">unit</span></code> should be <code class="docutils literal notranslate"><span class="pre">module_name-partition_name.pcm</span></code>.</p>
<p>If the file names use different extensions, Clang may fail to build the module.
For example, if the filename of an <code class="docutils literal notranslate"><span class="pre">importable</span> <span class="pre">module</span> <span class="pre">unit</span></code> ends with <code class="docutils literal notranslate"><span class="pre">.cpp</span></code> instead of <code class="docutils literal notranslate"><span class="pre">.cppm</span></code>,
then we can't generate a BMI for the <code class="docutils literal notranslate"><span class="pre">importable</span> <span class="pre">module</span> <span class="pre">unit</span></code> by <code class="docutils literal notranslate"><span class="pre">--precompile</span></code> option
since <code class="docutils literal notranslate"><span class="pre">--precompile</span></code> option now would only run preprocessor, which is equal to <cite>-E</cite> now.
If we want the filename of an <code class="docutils literal notranslate"><span class="pre">importable</span> <span class="pre">module</span> <span class="pre">unit</span></code> ends with other suffixes instead of <code class="docutils literal notranslate"><span class="pre">.cppm</span></code>,
we could put <code class="docutils literal notranslate"><span class="pre">-x</span> <span class="pre">c++-module</span></code> in front of the file. For example,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Hello.cpp</span>
<span class="k">module</span><span class="p">;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">Hello</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">hello</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Hello World!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// use.cpp</span>
<span class="k">import</span><span class="w"> </span><span class="n">Hello</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">hello</span><span class="p">();</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now the filename of the <code class="docutils literal notranslate"><span class="pre">module</span> <span class="pre">interface</span></code> ends with <code class="docutils literal notranslate"><span class="pre">.cpp</span></code> instead of <code class="docutils literal notranslate"><span class="pre">.cppm</span></code>,
we can't compile them by the original command lines. But we are still able to do it by:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>-x<span class="w"> </span>c++-module<span class="w"> </span>Hello.cpp<span class="w"> </span>--precompile<span class="w"> </span>-o<span class="w"> </span>Hello.pcm
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>use.cpp<span class="w"> </span>-fprebuilt-module-path<span class="o">=</span>.<span class="w"> </span>Hello.pcm<span class="w"> </span>-o<span class="w"> </span>Hello.out
<span class="gp">$ </span>./Hello.out
<span class="go">Hello World!</span>
</pre></div>
</div>
</section>
<section id="module-name-requirement">
<h4><a class="toc-backref" href="#id19" role="doc-backlink">Module name requirement</a><a class="headerlink" href="#module-name-requirement" title="Link to this heading">¶</a></h4>
<p>[module.unit]p1 says:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>All module-names either beginning with an identifier consisting of std followed by zero
or more digits or containing a reserved identifier ([lex.name]) are reserved and shall not
be specified in a module-declaration; no diagnostic is required. If any identifier in a reserved
module-name is a reserved identifier, the module name is reserved for use by C++ implementations;
otherwise it is reserved for future standardization.
</pre></div>
</div>
<p>So all of the following name is not valid by default:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>std
std1
std.foo
__test
// and so on ...
</pre></div>
</div>
<p>If you still want to use the reserved module names for any reason, use
<code class="docutils literal notranslate"><span class="pre">-Wno-reserved-module-identifier</span></code> to suppress the warning.</p>
</section>
<section id="how-to-specify-the-dependent-bmis">
<h4><a class="toc-backref" href="#id20" role="doc-backlink">How to specify the dependent BMIs</a><a class="headerlink" href="#how-to-specify-the-dependent-bmis" title="Link to this heading">¶</a></h4>
<p>There are 3 methods to specify the dependent BMIs:</p>
<ul class="simple">
<li><ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">-fprebuilt-module-path=&lt;path/to/directory&gt;</span></code>.</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="2">
<li><p><code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;path/to/BMI&gt;</span></code> (Deprecated).</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="3">
<li><p><code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;module-name&gt;=&lt;path/to/BMI&gt;</span></code>.</p></li>
</ol>
</li>
</ul>
<p>The option <code class="docutils literal notranslate"><span class="pre">-fprebuilt-module-path</span></code> tells the compiler the path where to search for dependent BMIs.
It may be used multiple times just like <code class="docutils literal notranslate"><span class="pre">-I</span></code> for specifying paths for header files. The look up rule here is:</p>
<ul class="simple">
<li><p>(1) When we import module M. The compiler would look up M.pcm in the directories specified
by <code class="docutils literal notranslate"><span class="pre">-fprebuilt-module-path</span></code>.</p></li>
<li><p>(2) When we import partition module unit M:P. The compiler would look up M-P.pcm in the
directories specified by <code class="docutils literal notranslate"><span class="pre">-fprebuilt-module-path</span></code>.</p></li>
</ul>
<p>The option <code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;path/to/BMI&gt;</span></code> tells the compiler to load the specified BMI directly.
The option <code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;module-name&gt;=&lt;path/to/BMI&gt;</span></code> tells the compiler to load the specified BMI
for the module specified by <code class="docutils literal notranslate"><span class="pre">&lt;module-name&gt;</span></code> when necessary. The main difference is that
<code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;path/to/BMI&gt;</span></code> will load the BMI eagerly, whereas
<code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;module-name&gt;=&lt;path/to/BMI&gt;</span></code> will only load the BMI lazily, which is similar
with <code class="docutils literal notranslate"><span class="pre">-fprebuilt-module-path</span></code>. The option <code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;path/to/BMI&gt;</span></code> for named modules is deprecated
and is planning to be removed in future versions.</p>
<p>In case all <code class="docutils literal notranslate"><span class="pre">-fprebuilt-module-path=&lt;path/to/directory&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;path/to/BMI&gt;</span></code> and
<code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;module-name&gt;=&lt;path/to/BMI&gt;</span></code> exist, the <code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;path/to/BMI&gt;</span></code> option
takes highest precedence and <code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;module-name&gt;=&lt;path/to/BMI&gt;</span></code> will take the second
highest precedence.</p>
<p>We need to specify all the dependent (directly and indirectly) BMIs.
See <a class="reference external" href="https://github.com/llvm/llvm-project/issues/62707">https://github.com/llvm/llvm-project/issues/62707</a> for detail.</p>
<p>When we compile a <code class="docutils literal notranslate"><span class="pre">module</span> <span class="pre">implementation</span> <span class="pre">unit</span></code>, we must specify the BMI of the corresponding
<code class="docutils literal notranslate"><span class="pre">primary</span> <span class="pre">module</span> <span class="pre">interface</span> <span class="pre">unit</span></code>.
Since the language specification says a module implementation unit implicitly imports
the primary module interface unit.</p>
<blockquote>
<div><p>[module.unit]p8</p>
<p>A module-declaration that contains neither an export-keyword nor a module-partition implicitly
imports the primary module interface unit of the module as if by a module-import-declaration.</p>
</div></blockquote>
<p>All of the 3 options <code class="docutils literal notranslate"><span class="pre">-fprebuilt-module-path=&lt;path/to/directory&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;path/to/BMI&gt;</span></code>
and <code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;module-name&gt;=&lt;path/to/BMI&gt;</span></code> may occur multiple times.
For example, the command line to compile <code class="docutils literal notranslate"><span class="pre">M.cppm</span></code> in
the above example could be rewritten into:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>M.cppm<span class="w"> </span>--precompile<span class="w"> </span>-fmodule-file<span class="o">=</span>M:interface_part<span class="o">=</span>M-interface_part.pcm<span class="w"> </span>-fmodule-file<span class="o">=</span>M:impl_part<span class="o">=</span>M-impl_part.pcm<span class="w"> </span>-o<span class="w"> </span>M.pcm
</pre></div>
</div>
<p>When there are multiple <code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;module-name&gt;=</span></code> options for the same
<code class="docutils literal notranslate"><span class="pre">&lt;module-name&gt;</span></code>, the last <code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;module-name&gt;=</span></code> will override the previous
<code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;module-name&gt;=</span></code> options.</p>
<p><code class="docutils literal notranslate"><span class="pre">-fprebuilt-module-path</span></code> is more convenient and <code class="docutils literal notranslate"><span class="pre">-fmodule-file</span></code> is faster since
it saves time for file lookup.</p>
</section>
<section id="remember-that-module-units-still-have-an-object-counterpart-to-the-bmi">
<h4><a class="toc-backref" href="#id21" role="doc-backlink">Remember that module units still have an object counterpart to the BMI</a><a class="headerlink" href="#remember-that-module-units-still-have-an-object-counterpart-to-the-bmi" title="Link to this heading">¶</a></h4>
<p>It is easy to forget to compile BMIs at first since we may envision module interfaces like headers.
However, this is not true.
Module units are translation units. We need to compile them to object files
and link the object files like the example shows.</p>
<p>For example, the traditional compilation processes for headers are like:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>src1.cpp -+&gt; clang++ src1.cpp --&gt; src1.o ---,
hdr1.h  --&#39;                                 +-&gt; clang++ src1.o src2.o -&gt;  executable
hdr2.h  --,                                 |
src2.cpp -+&gt; clang++ src2.cpp --&gt; src2.o ---&#39;
</pre></div>
</div>
<p>And the compilation process for module units are like:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>              src1.cpp ----------------------------------------+&gt; clang++ src1.cpp -------&gt; src1.o -,
(header unit) hdr1.h    -&gt; clang++ hdr1.h ...    -&gt; hdr1.pcm --&#39;                                    +-&gt; clang++ src1.o mod1.o src2.o -&gt;  executable
              mod1.cppm -&gt; clang++ mod1.cppm ... -&gt; mod1.pcm --,--&gt; clang++ mod1.pcm ... -&gt; mod1.o -+
              src2.cpp ----------------------------------------+&gt; clang++ src2.cpp -------&gt; src2.o -&#39;
</pre></div>
</div>
<p>As the diagrams show, we need to compile the BMI from module units to object files and link the object files.
(But we can't do this for the BMI from header units. See the later section for the definition of header units)</p>
<p>If we want to create a module library, we can't just ship the BMIs in an archive.
We must compile these BMIs(<code class="docutils literal notranslate"><span class="pre">*.pcm</span></code>) into object files(<code class="docutils literal notranslate"><span class="pre">*.o</span></code>) and add those object files to the archive instead.</p>
</section>
<section id="consistency-requirement">
<h4><a class="toc-backref" href="#id22" role="doc-backlink">Consistency Requirement</a><a class="headerlink" href="#consistency-requirement" title="Link to this heading">¶</a></h4>
<p>If we envision modules as a cache to speed up compilation, then - as with other caching techniques -
it is important to keep cache consistency.
So <strong>currently</strong> Clang will do very strict check for consistency.</p>
<section id="options-consistency">
<h5><a class="toc-backref" href="#id23" role="doc-backlink">Options consistency</a><a class="headerlink" href="#options-consistency" title="Link to this heading">¶</a></h5>
<p>The language option of module units and their non-module-unit users should be consistent.
The following example is not allowed:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// M.cppm</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>

<span class="c1">// Use.cpp</span>
<span class="k">import</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>M.cppm<span class="w"> </span>--precompile<span class="w"> </span>-o<span class="w"> </span>M.pcm
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++23<span class="w"> </span>Use.cpp<span class="w"> </span>-fprebuilt-module-path<span class="o">=</span>.
</pre></div>
</div>
<p>The compiler would reject the example due to the inconsistent language options.
Not all options are language options.
For example, the following example is allowed:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>M.cppm<span class="w"> </span>--precompile<span class="w"> </span>-o<span class="w"> </span>M.pcm
<span class="gp"># </span>Inconsistent<span class="w"> </span>optimization<span class="w"> </span>level.
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>-O3<span class="w"> </span>Use.cpp<span class="w"> </span>-fprebuilt-module-path<span class="o">=</span>.
<span class="gp"># </span>Inconsistent<span class="w"> </span>debugging<span class="w"> </span>level.
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>-g<span class="w"> </span>Use.cpp<span class="w"> </span>-fprebuilt-module-path<span class="o">=</span>.
</pre></div>
</div>
<p>Although the two examples have inconsistent optimization and debugging level, both of them are accepted.</p>
<p>Note that <strong>currently</strong> the compiler doesn't consider inconsistent macro definition a problem. For example:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>M.cppm<span class="w"> </span>--precompile<span class="w"> </span>-o<span class="w"> </span>M.pcm
<span class="gp"># </span>Inconsistent<span class="w"> </span>optimization<span class="w"> </span>level.
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>-O3<span class="w"> </span>-DNDEBUG<span class="w"> </span>Use.cpp<span class="w"> </span>-fprebuilt-module-path<span class="o">=</span>.
</pre></div>
</div>
<p>Currently Clang would accept the above example. But it may produce surprising results if the
debugging code depends on consistent use of <code class="docutils literal notranslate"><span class="pre">NDEBUG</span></code> also in other translation units.</p>
</section>
<section id="definitions-consistency">
<h5><a class="toc-backref" href="#id24" role="doc-backlink">Definitions consistency</a><a class="headerlink" href="#definitions-consistency" title="Link to this heading">¶</a></h5>
<p>The C++ language defines that same declarations in different translation units should have
the same definition, as known as ODR (One Definition Rule). Prior to modules, the translation
units don't dependent on each other and the compiler itself can't perform a strong
ODR violation check. With the introduction of modules, now the compiler have
the chance to perform ODR violations with language semantics across translation units.</p>
<p>However, in the practice, we found the existing ODR checking mechanism is not stable
enough. Many people suffers from the false positive ODR violation diagnostics, AKA,
the compiler are complaining two identical declarations have different definitions
incorrectly. Also the true positive ODR violations are rarely reported.
Also we learned that MSVC don't perform ODR check for declarations in the global module
fragment.</p>
<p>So in order to get better user experience, save the time checking ODR and keep consistent
behavior with MSVC, we disabled the ODR check for the declarations in the global module
fragment by default. Users who want more strict check can still use the
<code class="docutils literal notranslate"><span class="pre">-Xclang</span> <span class="pre">-fno-skip-odr-check-in-gmf</span></code> flag to get the ODR check enabled. It is also
encouraged to report issues if users find false positive ODR violations or false negative ODR
violations with the flag enabled.</p>
</section>
</section>
</section>
<section id="abi-impacts">
<h3><a class="toc-backref" href="#id25" role="doc-backlink">ABI Impacts</a><a class="headerlink" href="#abi-impacts" title="Link to this heading">¶</a></h3>
<p>The declarations in a module unit which are not in the global module fragment have new linkage names.</p>
<p>For example,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">NS</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">export</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">foo</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The linkage name of <code class="docutils literal notranslate"><span class="pre">NS::foo()</span></code> would be <code class="docutils literal notranslate"><span class="pre">_ZN2NSW1M3fooEv</span></code>.
This couldn't be demangled by previous versions of the debugger or demangler.
As of LLVM 15.x, users can utilize <code class="docutils literal notranslate"><span class="pre">llvm-cxxfilt</span></code> to demangle this:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>llvm-cxxfilt<span class="w"> </span>_ZN2NSW1M3fooEv
</pre></div>
</div>
<p>The result would be <code class="docutils literal notranslate"><span class="pre">NS::foo&#64;M()</span></code>, which reads as <code class="docutils literal notranslate"><span class="pre">NS::foo()</span></code> in module <code class="docutils literal notranslate"><span class="pre">M</span></code>.</p>
<p>The ABI implies that we can't declare something in a module unit and define it in a non-module unit (or vice-versa),
as this would result in linking errors.</p>
<p>If we still want to implement declarations within the compatible ABI in module unit,
we can use the language-linkage specifier. Since the declarations in the language-linkage specifier
is attached to the global module fragments. For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">NS</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">export</span><span class="w"> </span><span class="k">extern</span><span class="w"> </span><span class="s">&quot;C++&quot;</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">foo</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now the linkage name of <code class="docutils literal notranslate"><span class="pre">NS::foo()</span></code> will be <code class="docutils literal notranslate"><span class="pre">_ZN2NS3fooEv</span></code>.</p>
</section>
<section id="performance-tips">
<h3><a class="toc-backref" href="#id26" role="doc-backlink">Performance Tips</a><a class="headerlink" href="#performance-tips" title="Link to this heading">¶</a></h3>
<section id="reduce-duplications">
<h4><a class="toc-backref" href="#id27" role="doc-backlink">Reduce duplications</a><a class="headerlink" href="#reduce-duplications" title="Link to this heading">¶</a></h4>
<p>While it is legal to have duplicated declarations in the global module fragments
of different module units, it is not free for clang to deal with the duplicated
declarations. In other word, for a translation unit, it will compile slower if the
translation unit itself and its importing module units contains a lot duplicated
declarations.</p>
<p>For example,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// M-partA.cppm</span>
<span class="k">module</span><span class="p">;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;big.header.h&quot;</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="o">:</span><span class="n">partA</span><span class="p">;</span>
<span class="p">...</span>

<span class="c1">// M-partB.cppm</span>
<span class="k">module</span><span class="p">;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;big.header.h&quot;</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="o">:</span><span class="n">partB</span><span class="p">;</span>
<span class="p">...</span>

<span class="c1">// other partitions</span>
<span class="p">...</span>

<span class="c1">// M-partZ.cppm</span>
<span class="k">module</span><span class="p">;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;big.header.h&quot;</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="o">:</span><span class="n">partZ</span><span class="p">;</span>
<span class="p">...</span>

<span class="c1">// M.cppm</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="k">import</span><span class="w"> </span><span class="o">:</span><span class="n">partA</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="k">import</span><span class="w"> </span><span class="o">:</span><span class="n">partB</span><span class="p">;</span>
<span class="p">...</span>
<span class="k">export</span><span class="w"> </span><span class="k">import</span><span class="w"> </span><span class="o">:</span><span class="n">partZ</span><span class="p">;</span>

<span class="c1">// use.cpp</span>
<span class="k">import</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
<span class="p">...</span><span class="w"> </span><span class="c1">// use declarations from module M.</span>
</pre></div>
</div>
<p>When <code class="docutils literal notranslate"><span class="pre">big.header.h</span></code> is big enough and there are a lot of partitions,
the compilation of <code class="docutils literal notranslate"><span class="pre">use.cpp</span></code> may be slower than
the following style significantly:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">module</span><span class="p">;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;big.header.h&quot;</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">m</span><span class="o">:</span><span class="n">big</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">wrapper</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="c1">// export the needed declarations</span>

<span class="c1">// M-partA.cppm</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="o">:</span><span class="n">partA</span><span class="p">;</span>
<span class="nl">import</span><span class="w"> </span><span class="p">:</span><span class="n">big</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">wrapper</span><span class="p">;</span>
<span class="p">...</span>

<span class="c1">// M-partB.cppm</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="o">:</span><span class="n">partB</span><span class="p">;</span>
<span class="nl">import</span><span class="w"> </span><span class="p">:</span><span class="n">big</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">wrapper</span><span class="p">;</span>
<span class="p">...</span>

<span class="c1">// other partitions</span>
<span class="p">...</span>

<span class="c1">// M-partZ.cppm</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="o">:</span><span class="n">partZ</span><span class="p">;</span>
<span class="nl">import</span><span class="w"> </span><span class="p">:</span><span class="n">big</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">wrapper</span><span class="p">;</span>
<span class="p">...</span>

<span class="c1">// M.cppm</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="k">import</span><span class="w"> </span><span class="o">:</span><span class="n">partA</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="k">import</span><span class="w"> </span><span class="o">:</span><span class="n">partB</span><span class="p">;</span>
<span class="p">...</span>
<span class="k">export</span><span class="w"> </span><span class="k">import</span><span class="w"> </span><span class="o">:</span><span class="n">partZ</span><span class="p">;</span>

<span class="c1">// use.cpp</span>
<span class="k">import</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
<span class="p">...</span><span class="w"> </span><span class="c1">// use declarations from module M.</span>
</pre></div>
</div>
<p>The key part of the tip is to reduce the duplications from the text includes.</p>
</section>
</section>
<section id="known-problems">
<h3><a class="toc-backref" href="#id28" role="doc-backlink">Known Problems</a><a class="headerlink" href="#known-problems" title="Link to this heading">¶</a></h3>
<p>The following describes issues in the current implementation of modules.
Please see <a class="reference external" href="https://github.com/llvm/llvm-project/labels/clang%3Amodules">https://github.com/llvm/llvm-project/labels/clang%3Amodules</a> for more issues
or file a new issue if you don't find an existing one.
If you're going to create a new issue for standard C++ modules,
please start the title with <code class="docutils literal notranslate"><span class="pre">[C++20]</span> <span class="pre">[Modules]</span></code> (or <code class="docutils literal notranslate"><span class="pre">[C++23]</span> <span class="pre">[Modules]</span></code>, etc)
and add the label <code class="docutils literal notranslate"><span class="pre">clang:modules</span></code> (if you have permissions for that).</p>
<p>For higher level support for proposals, you could visit <a class="reference external" href="https://clang.llvm.org/cxx_status.html">https://clang.llvm.org/cxx_status.html</a>.</p>
<section id="including-headers-after-import-is-problematic">
<h4><a class="toc-backref" href="#id29" role="doc-backlink">Including headers after import is problematic</a><a class="headerlink" href="#including-headers-after-import-is-problematic" title="Link to this heading">¶</a></h4>
<p>For example, the following example can be accept:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="k">import</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span><span class="w"> </span><span class="c1">// assume module &#39;foo&#39; contain the declarations from `&lt;iostream&gt;`</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Test</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>but it will get rejected if we reverse the order of <code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;iostream&gt;</span></code> and
<code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">foo;</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span><span class="w"> </span><span class="c1">// assume module &#39;foo&#39; contain the declarations from `&lt;iostream&gt;`</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Test</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Both of the above examples should be accepted.</p>
<p>This is a limitation in the implementation. In the first example,
the compiler will see and parse &lt;iostream&gt; first then the compiler will see the import.
So the ODR Checking and declarations merging will happen in the deserializer.
In the second example, the compiler will see the import first and the include second.
As a result, the ODR Checking and declarations merging will happen in the semantic analyzer.</p>
<p>So there is divergence in the implementation path. It might be understandable that why
the orders matter here in the case.
(Note that &quot;understandable&quot; is different from &quot;makes sense&quot;).</p>
<p>This is tracked in: <a class="reference external" href="https://github.com/llvm/llvm-project/issues/61465">https://github.com/llvm/llvm-project/issues/61465</a></p>
</section>
<section id="ignored-preferredname-attribute">
<h4><a class="toc-backref" href="#id30" role="doc-backlink">Ignored PreferredName Attribute</a><a class="headerlink" href="#ignored-preferredname-attribute" title="Link to this heading">¶</a></h4>
<p>Due to a tricky problem, when Clang writes BMIs, Clang will ignore the <code class="docutils literal notranslate"><span class="pre">preferred_name</span></code> attribute, if any.
This implies that the <code class="docutils literal notranslate"><span class="pre">preferred_name</span></code> wouldn't show in debugger or dumping.</p>
<p>This is tracked in: <a class="reference external" href="https://github.com/llvm/llvm-project/issues/56490">https://github.com/llvm/llvm-project/issues/56490</a></p>
</section>
<section id="don-t-emit-macros-about-module-declaration">
<h4><a class="toc-backref" href="#id31" role="doc-backlink">Don't emit macros about module declaration</a><a class="headerlink" href="#don-t-emit-macros-about-module-declaration" title="Link to this heading">¶</a></h4>
<p>This is covered by P1857R3. We mention it again here since users may abuse it before we implement it.</p>
<p>Someone may want to write code which could be compiled both by modules or non-modules.
A direct idea would be use macros like:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MODULE</span>
<span class="n">IMPORT</span><span class="w"> </span><span class="n">header_name</span>
<span class="n">EXPORT_MODULE</span><span class="w"> </span><span class="n">MODULE_NAME</span><span class="p">;</span>
<span class="n">IMPORT</span><span class="w"> </span><span class="n">header_name</span>
<span class="n">EXPORT</span><span class="w"> </span><span class="p">...</span>
</pre></div>
</div>
<p>So this file could be triggered like a module unit or a non-module unit depending on the definition
of some macros.
However, this kind of usage is forbidden by P1857R3 but we haven't implemented P1857R3 yet.
This means that is possible to write illegal modules code now, and obviously this will stop working
once P1857R3 is implemented.
A simple suggestion would be &quot;Don't play macro tricks with module declarations&quot;.</p>
<p>This is tracked in: <a class="reference external" href="https://github.com/llvm/llvm-project/issues/56917">https://github.com/llvm/llvm-project/issues/56917</a></p>
</section>
<section id="in-consistent-filename-suffix-requirement-for-importable-module-units">
<h4><a class="toc-backref" href="#id32" role="doc-backlink">In consistent filename suffix requirement for importable module units</a><a class="headerlink" href="#in-consistent-filename-suffix-requirement-for-importable-module-units" title="Link to this heading">¶</a></h4>
<p>Currently, clang requires the file name of an <code class="docutils literal notranslate"><span class="pre">importable</span> <span class="pre">module</span> <span class="pre">unit</span></code> should end with <code class="docutils literal notranslate"><span class="pre">.cppm</span></code>
(or <code class="docutils literal notranslate"><span class="pre">.ccm</span></code>, <code class="docutils literal notranslate"><span class="pre">.cxxm</span></code>, <code class="docutils literal notranslate"><span class="pre">.c++m</span></code>). However, the behavior is inconsistent with other compilers.</p>
<p>This is tracked in: <a class="reference external" href="https://github.com/llvm/llvm-project/issues/57416">https://github.com/llvm/llvm-project/issues/57416</a></p>
</section>
<section id="clang-cl-is-not-compatible-with-the-standard-c-modules">
<h4><a class="toc-backref" href="#id33" role="doc-backlink">clang-cl is not compatible with the standard C++ modules</a><a class="headerlink" href="#clang-cl-is-not-compatible-with-the-standard-c-modules" title="Link to this heading">¶</a></h4>
<p>Now we can't use the <cite>/clang:-fmodule-file</cite> or <cite>/clang:-fprebuilt-module-path</cite> to specify
the BMI within <code class="docutils literal notranslate"><span class="pre">clang-cl.exe</span></code>.</p>
<p>This is tracked in: <a class="reference external" href="https://github.com/llvm/llvm-project/issues/64118">https://github.com/llvm/llvm-project/issues/64118</a></p>
</section>
<section id="false-positive-odr-violation-diagnostic-due-to-using-inconsistent-qualified-but-the-same-type">
<h4><a class="toc-backref" href="#id34" role="doc-backlink">false positive ODR violation diagnostic due to using inconsistent qualified but the same type</a><a class="headerlink" href="#false-positive-odr-violation-diagnostic-due-to-using-inconsistent-qualified-but-the-same-type" title="Link to this heading">¶</a></h4>
<p>ODR violation is a pretty common issue when using modules.
Sometimes the program violated the One Definition Rule actually.
But sometimes it shows the compiler gives false positive diagnostics.</p>
<p>One often reported example is:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// part.cc</span>
<span class="k">module</span><span class="p">;</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">T</span><span class="p">;</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">ns</span><span class="w"> </span><span class="p">{</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">fun</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">(</span><span class="kt">void</span><span class="p">)(</span><span class="n">T</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">repro</span><span class="o">:</span><span class="n">part</span><span class="p">;</span>

<span class="c1">// repro.cc</span>
<span class="k">module</span><span class="p">;</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">T</span><span class="p">;</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">ns</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">T</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">ns</span><span class="w"> </span><span class="p">{</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">fun</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">(</span><span class="kt">void</span><span class="p">)(</span><span class="n">T</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">repro</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="k">import</span><span class="w"> </span><span class="o">:</span><span class="n">part</span><span class="p">;</span>
</pre></div>
</div>
<p>Currently the compiler complains about the inconsistent definition of <cite>fun()</cite> in
2 module units. This is incorrect. Since both definitions of <cite>fun()</cite> has the same
spelling and <cite>T</cite> refers to the same type entity finally. So the program should be
fine.</p>
<p>This is tracked in <a class="reference external" href="https://github.com/llvm/llvm-project/issues/78850">https://github.com/llvm/llvm-project/issues/78850</a>.</p>
</section>
<section id="using-tu-local-entity-in-other-units">
<h4><a class="toc-backref" href="#id35" role="doc-backlink">Using TU-local entity in other units</a><a class="headerlink" href="#using-tu-local-entity-in-other-units" title="Link to this heading">¶</a></h4>
<p>Module units are translation units. So the entities which should only be local to the
module unit itself shouldn't be used by other units in any means.</p>
<p>In the language side, to address the idea formally, the language specification defines
the concept of <code class="docutils literal notranslate"><span class="pre">TU-local</span></code> and <code class="docutils literal notranslate"><span class="pre">exposure</span></code> in
<a class="reference external" href="https://eel.is/c++draft/basic.link#14">basic.link/p14</a>,
<a class="reference external" href="https://eel.is/c++draft/basic.link#15">basic.link/p15</a>,
<a class="reference external" href="https://eel.is/c++draft/basic.link#16">basic.link/p16</a>,
<a class="reference external" href="https://eel.is/c++draft/basic.link#17">basic.link/p17</a> and
<a class="reference external" href="https://eel.is/c++draft/basic.link#18">basic.link/p18</a>.</p>
<p>However, the compiler doesn't support these 2 ideas formally.
This results in unclear and confusing diagnostic messages.
And it is worse that the compiler may import TU-local entities to other units without any
diagnostics.</p>
<p>This is tracked in <a class="reference external" href="https://github.com/llvm/llvm-project/issues/78173">https://github.com/llvm/llvm-project/issues/78173</a>.</p>
</section>
</section>
</section>
<section id="header-units">
<h2><a class="toc-backref" href="#id36" role="doc-backlink">Header Units</a><a class="headerlink" href="#header-units" title="Link to this heading">¶</a></h2>
<section id="how-to-build-projects-using-header-unit">
<h3><a class="toc-backref" href="#id37" role="doc-backlink">How to build projects using header unit</a><a class="headerlink" href="#how-to-build-projects-using-header-unit" title="Link to this heading">¶</a></h3>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>The user interfaces of header units is highly experimental. There are still
many unanswered question about how tools should interact with header units.
The user interfaces described here may change after we have progress on how
tools should support for header units.</p>
</div>
<section id="id4">
<h4><a class="toc-backref" href="#id38" role="doc-backlink">Quick Start</a><a class="headerlink" href="#id4" title="Link to this heading">¶</a></h4>
<p>For the following example,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="o">&lt;</span><span class="n">iostream</span><span class="o">&gt;</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Hello World.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>we could compile it as</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>-xc++-system-header<span class="w"> </span>--precompile<span class="w"> </span>iostream<span class="w"> </span>-o<span class="w"> </span>iostream.pcm
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>-fmodule-file<span class="o">=</span>iostream.pcm<span class="w"> </span>main.cpp
</pre></div>
</div>
</section>
<section id="how-to-produce-bmis">
<h4><a class="toc-backref" href="#id39" role="doc-backlink">How to produce BMIs</a><a class="headerlink" href="#how-to-produce-bmis" title="Link to this heading">¶</a></h4>
<p>Similar to named modules, we could use <code class="docutils literal notranslate"><span class="pre">--precompile</span></code> to produce the BMI.
But we need to specify that the input file is a header by <code class="docutils literal notranslate"><span class="pre">-xc++-system-header</span></code> or <code class="docutils literal notranslate"><span class="pre">-xc++-user-header</span></code>.</p>
<p>Also we could use <cite>-fmodule-header={user,system}</cite> option to produce the BMI for header units
which has suffix like <cite>.h</cite> or <cite>.hh</cite>.
The value of <cite>-fmodule-header</cite> means the user search path or the system search path.
The default value for <cite>-fmodule-header</cite> is <cite>user</cite>.
For example,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// foo.h</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">Hello</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Hello World.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// use.cpp</span>
<span class="k">import</span><span class="w"> </span><span class="s">&quot;foo.h&quot;</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">Hello</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We could compile it as:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>-fmodule-header<span class="w"> </span>foo.h<span class="w"> </span>-o<span class="w"> </span>foo.pcm
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>-fmodule-file<span class="o">=</span>foo.pcm<span class="w"> </span>use.cpp
</pre></div>
</div>
<p>For headers which don't have a suffix, we need to pass <code class="docutils literal notranslate"><span class="pre">-xc++-header</span></code>
(or <code class="docutils literal notranslate"><span class="pre">-xc++-system-header</span></code> or <code class="docutils literal notranslate"><span class="pre">-xc++-user-header</span></code>) to mark it as a header.
For example,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// use.cpp</span>
<span class="k">import</span><span class="w"> </span><span class="s">&quot;foo.h&quot;</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">Hello</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>-fmodule-header<span class="o">=</span>system<span class="w"> </span>-xc++-header<span class="w"> </span>iostream<span class="w"> </span>-o<span class="w"> </span>iostream.pcm
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>-fmodule-file<span class="o">=</span>iostream.pcm<span class="w"> </span>use.cpp
</pre></div>
</div>
</section>
<section id="id5">
<h4><a class="toc-backref" href="#id40" role="doc-backlink">How to specify the dependent BMIs</a><a class="headerlink" href="#id5" title="Link to this heading">¶</a></h4>
<p>We could use <code class="docutils literal notranslate"><span class="pre">-fmodule-file</span></code> to specify the BMIs, and this option may occur multiple times as well.</p>
<p>With the existing implementation <code class="docutils literal notranslate"><span class="pre">-fprebuilt-module-path</span></code> cannot be used for header units
(since they are nominally anonymous).
For header units, use  <code class="docutils literal notranslate"><span class="pre">-fmodule-file</span></code> to include the relevant PCM file for each header unit.</p>
<p>This is expect to be solved in future editions of the compiler either by the tooling finding and specifying
the -fmodule-file or by the use of a module-mapper that understands how to map the header name to their PCMs.</p>
</section>
<section id="don-t-compile-the-bmi">
<h4><a class="toc-backref" href="#id41" role="doc-backlink">Don't compile the BMI</a><a class="headerlink" href="#don-t-compile-the-bmi" title="Link to this heading">¶</a></h4>
<p>Another difference with modules is that we can't compile the BMI from a header unit.
For example:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>-xc++-system-header<span class="w"> </span>--precompile<span class="w"> </span>iostream<span class="w"> </span>-o<span class="w"> </span>iostream.pcm
<span class="gp"># </span>This<span class="w"> </span>is<span class="w"> </span>not<span class="w"> </span>allowed!
<span class="gp">$ </span>clang++<span class="w"> </span>iostream.pcm<span class="w"> </span>-c<span class="w"> </span>-o<span class="w"> </span>iostream.o
</pre></div>
</div>
<p>It makes sense due to the semantics of header units, which are just like headers.</p>
</section>
<section id="include-translation">
<h4><a class="toc-backref" href="#id42" role="doc-backlink">Include translation</a><a class="headerlink" href="#include-translation" title="Link to this heading">¶</a></h4>
<p>The C++ spec allows the vendors to convert <code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">header-name</span></code> to <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">header-name;</span></code> when possible.
Currently, Clang would do this translation for the <code class="docutils literal notranslate"><span class="pre">#include</span></code> in the global module fragment.</p>
<p>For example, the following two examples are the same:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">module</span><span class="p">;</span>
<span class="k">import</span><span class="w"> </span><span class="o">&lt;</span><span class="n">iostream</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">Hello</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Hello.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>with the following one:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">module</span><span class="p">;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">Hello</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Hello.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>-xc++-system-header<span class="w"> </span>--precompile<span class="w"> </span>iostream<span class="w"> </span>-o<span class="w"> </span>iostream.pcm
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>-fmodule-file<span class="o">=</span>iostream.pcm<span class="w"> </span>--precompile<span class="w"> </span>M.cppm<span class="w"> </span>-o<span class="w"> </span>M.cpp
</pre></div>
</div>
<p>In the latter example, the Clang could find the BMI for the <code class="docutils literal notranslate"><span class="pre">&lt;iostream&gt;</span></code>
so it would try to replace the <code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;iostream&gt;</span></code> to <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">&lt;iostream&gt;;</span></code> automatically.</p>
</section>
</section>
<section id="relationships-between-clang-modules">
<h3><a class="toc-backref" href="#id43" role="doc-backlink">Relationships between Clang modules</a><a class="headerlink" href="#relationships-between-clang-modules" title="Link to this heading">¶</a></h3>
<p>Header units have pretty similar semantics with Clang modules.
The semantics of both of them are like headers.</p>
<p>In fact, we could even &quot;mimic&quot; the sytle of header units by Clang modules:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">module</span><span class="w"> </span><span class="s">&quot;iostream&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">export</span><span class="w"> </span><span class="o">*</span>
<span class="w">  </span><span class="n">header</span><span class="w"> </span><span class="s">&quot;/path/to/libstdcxx/iostream&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>-fimplicit-modules<span class="w"> </span>-fmodule-map-file<span class="o">=</span>.modulemap<span class="w"> </span>main.cpp
</pre></div>
</div>
<p>It would be simpler if we are using libcxx:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>main.cpp<span class="w"> </span>-fimplicit-modules<span class="w"> </span>-fimplicit-module-maps
</pre></div>
</div>
<p>Since there is already one
<a class="reference external" href="https://github.com/llvm/llvm-project/blob/main/libcxx/include/module.modulemap.in">module map</a>
in the source of libcxx.</p>
<p>Then immediately leads to the question: why don't we implement header units through Clang header modules?</p>
<p>The main reason for this is that Clang modules have more semantics like hierarchy or
wrapping multiple headers together as a big module.
However, these things are not part of Standard C++ Header units,
and we want to avoid the impression that these additional semantics get interpreted as Standard C++ behavior.</p>
<p>Another reason is that there are proposals to introduce module mappers to the C++ standard
(for example, <a class="reference external" href="https://wg21.link/p1184r2">https://wg21.link/p1184r2</a>).
If we decide to reuse Clang's modulemap, we may get in trouble once we need to introduce another module mapper.</p>
<p>So the final answer for why we don't reuse the interface of Clang modules for header units is that
there are some differences between header units and Clang modules and that ignoring those
differences now would likely become a problem in the future.</p>
</section>
</section>
<section id="discover-dependencies">
<h2><a class="toc-backref" href="#id44" role="doc-backlink">Discover Dependencies</a><a class="headerlink" href="#discover-dependencies" title="Link to this heading">¶</a></h2>
<p>Prior to modules, all the translation units can be compiled parallelly.
But it is not true for the module units. The presence of module units requires
us to compile the translation units in a (topological) order.</p>
<p>The clang-scan-deps scanner implemented
<a class="reference external" href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1689r5.html">P1689 paper</a>
to describe the order. Only named modules are supported now.</p>
<p>We need a compilation database to use clang-scan-deps. See
<a class="reference external" href="JSONCompilationDatabase.html">JSON Compilation Database Format Specification</a>
for example. Note that the <code class="docutils literal notranslate"><span class="pre">output</span></code> entry is necessary for clang-scan-deps
to scan P1689 format. Here is an example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">//--- M.cppm</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="k">import</span><span class="w"> </span><span class="o">:</span><span class="n">interface_part</span><span class="p">;</span>
<span class="nl">import</span><span class="w"> </span><span class="p">:</span><span class="n">impl_part</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">Hello</span><span class="p">();</span>

<span class="c1">//--- interface_part.cppm</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="o">:</span><span class="n">interface_part</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">World</span><span class="p">();</span>

<span class="c1">//--- Impl.cpp</span>
<span class="k">module</span><span class="p">;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">Hello</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Hello &quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//--- impl_part.cppm</span>
<span class="k">module</span><span class="p">;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="o">:</span><span class="n">impl_part</span><span class="p">;</span>
<span class="nl">import</span><span class="w"> </span><span class="p">:</span><span class="n">interface_part</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">W</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;World.&quot;</span><span class="p">;</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">World</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">W</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//--- User.cpp</span>
<span class="k">import</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
<span class="k">import</span><span class="w"> </span><span class="n">third_party_module</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">Hello</span><span class="p">();</span>
<span class="w">  </span><span class="n">World</span><span class="p">();</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>And here is the compilation database:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>[
{
    &quot;directory&quot;: &quot;.&quot;,
    &quot;command&quot;: &quot;&lt;path-to-compiler-executable&gt;/clang++ -std=c++20 M.cppm -c -o M.o&quot;,
    &quot;file&quot;: &quot;M.cppm&quot;,
    &quot;output&quot;: &quot;M.o&quot;
},
{
    &quot;directory&quot;: &quot;.&quot;,
    &quot;command&quot;: &quot;&lt;path-to-compiler-executable&gt;/clang++ -std=c++20 Impl.cpp -c -o Impl.o&quot;,
    &quot;file&quot;: &quot;Impl.cpp&quot;,
    &quot;output&quot;: &quot;Impl.o&quot;
},
{
    &quot;directory&quot;: &quot;.&quot;,
    &quot;command&quot;: &quot;&lt;path-to-compiler-executable&gt;/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o&quot;,
    &quot;file&quot;: &quot;impl_part.cppm&quot;,
    &quot;output&quot;: &quot;impl_part.o&quot;
},
{
    &quot;directory&quot;: &quot;.&quot;,
    &quot;command&quot;: &quot;&lt;path-to-compiler-executable&gt;/clang++ -std=c++20 interface_part.cppm -c -o interface_part.o&quot;,
    &quot;file&quot;: &quot;interface_part.cppm&quot;,
    &quot;output&quot;: &quot;interface_part.o&quot;
},
{
    &quot;directory&quot;: &quot;.&quot;,
    &quot;command&quot;: &quot;&lt;path-to-compiler-executable&gt;/clang++ -std=c++20 User.cpp -c -o User.o&quot;,
    &quot;file&quot;: &quot;User.cpp&quot;,
    &quot;output&quot;: &quot;User.o&quot;
}
]
</pre></div>
</div>
<p>And we can get the dependency information in P1689 format by:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang-scan-deps<span class="w"> </span>-format<span class="o">=</span>p1689<span class="w"> </span>-compilation-database<span class="w"> </span>P1689.json
</pre></div>
</div>
<p>And we will get:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>{
  &quot;revision&quot;: 0,
  &quot;rules&quot;: [
    {
      &quot;primary-output&quot;: &quot;Impl.o&quot;,
      &quot;requires&quot;: [
        {
          &quot;logical-name&quot;: &quot;M&quot;,
          &quot;source-path&quot;: &quot;M.cppm&quot;
        }
      ]
    },
    {
      &quot;primary-output&quot;: &quot;M.o&quot;,
      &quot;provides&quot;: [
        {
          &quot;is-interface&quot;: true,
          &quot;logical-name&quot;: &quot;M&quot;,
          &quot;source-path&quot;: &quot;M.cppm&quot;
        }
      ],
      &quot;requires&quot;: [
        {
          &quot;logical-name&quot;: &quot;M:interface_part&quot;,
          &quot;source-path&quot;: &quot;interface_part.cppm&quot;
        },
        {
          &quot;logical-name&quot;: &quot;M:impl_part&quot;,
          &quot;source-path&quot;: &quot;impl_part.cppm&quot;
        }
      ]
    },
    {
      &quot;primary-output&quot;: &quot;User.o&quot;,
      &quot;requires&quot;: [
        {
          &quot;logical-name&quot;: &quot;M&quot;,
          &quot;source-path&quot;: &quot;M.cppm&quot;
        },
        {
          &quot;logical-name&quot;: &quot;third_party_module&quot;
        }
      ]
    },
    {
      &quot;primary-output&quot;: &quot;impl_part.o&quot;,
      &quot;provides&quot;: [
        {
          &quot;is-interface&quot;: false,
          &quot;logical-name&quot;: &quot;M:impl_part&quot;,
          &quot;source-path&quot;: &quot;impl_part.cppm&quot;
        }
      ],
      &quot;requires&quot;: [
        {
          &quot;logical-name&quot;: &quot;M:interface_part&quot;,
          &quot;source-path&quot;: &quot;interface_part.cppm&quot;
        }
      ]
    },
    {
      &quot;primary-output&quot;: &quot;interface_part.o&quot;,
      &quot;provides&quot;: [
        {
          &quot;is-interface&quot;: true,
          &quot;logical-name&quot;: &quot;M:interface_part&quot;,
          &quot;source-path&quot;: &quot;interface_part.cppm&quot;
        }
      ]
    }
  ],
  &quot;version&quot;: 1
}
</pre></div>
</div>
<p>See the P1689 paper for the meaning of the fields.</p>
<p>And if the user want a finer-grained control for any reason, e.g., to scan the generated source files,
the user can choose to get the dependency information per file. For example:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang-scan-deps<span class="w"> </span>-format<span class="o">=</span>p1689<span class="w"> </span>--<span class="w"> </span>&lt;path-to-compiler-executable&gt;/clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>impl_part.cppm<span class="w"> </span>-c<span class="w"> </span>-o<span class="w"> </span>impl_part.o
</pre></div>
</div>
<p>And we'll get:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>{
  &quot;revision&quot;: 0,
  &quot;rules&quot;: [
    {
      &quot;primary-output&quot;: &quot;impl_part.o&quot;,
      &quot;provides&quot;: [
        {
          &quot;is-interface&quot;: false,
          &quot;logical-name&quot;: &quot;M:impl_part&quot;,
          &quot;source-path&quot;: &quot;impl_part.cppm&quot;
        }
      ],
      &quot;requires&quot;: [
        {
          &quot;logical-name&quot;: &quot;M:interface_part&quot;
        }
      ]
    }
  ],
  &quot;version&quot;: 1
}
</pre></div>
</div>
<p>In this way, we can pass the single command line options after the <code class="docutils literal notranslate"><span class="pre">--</span></code>.
Then clang-scan-deps will extract the necessary information from the options.
Note that we need to specify the path to the compiler executable instead of saying
<code class="docutils literal notranslate"><span class="pre">clang++</span></code> simply.</p>
<p>The users may want the scanner to get the transitional dependency information for headers.
Otherwise, the users have to scan twice for the project, once for headers and once for modules.
To address the requirement, clang-scan-deps will recognize the specified preprocessor options
in the given command line and generate the corresponding dependency information. For example,</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang-scan-deps<span class="w"> </span>-format<span class="o">=</span>p1689<span class="w"> </span>--<span class="w"> </span>../bin/clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>impl_part.cppm<span class="w"> </span>-c<span class="w"> </span>-o<span class="w"> </span>impl_part.o<span class="w"> </span>-MD<span class="w"> </span>-MT<span class="w"> </span>impl_part.ddi<span class="w"> </span>-MF<span class="w"> </span>impl_part.dep
<span class="gp">$ </span>cat<span class="w"> </span>impl_part.dep
</pre></div>
</div>
<p>We will get:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>impl_part.ddi: \
  /usr/include/bits/wchar.h /usr/include/bits/types/wint_t.h \
  /usr/include/bits/types/mbstate_t.h \
  /usr/include/bits/types/__mbstate_t.h /usr/include/bits/types/__FILE.h \
  /usr/include/bits/types/FILE.h /usr/include/bits/types/locale_t.h \
  /usr/include/bits/types/__locale_t.h \
  ...
</pre></div>
</div>
<p>When clang-scan-deps detects <code class="docutils literal notranslate"><span class="pre">-MF</span></code> option, clang-scan-deps will try to write the
dependency information for headers to the file specified by <code class="docutils literal notranslate"><span class="pre">-MF</span></code>.</p>
<section id="possible-issues-failed-to-find-system-headers">
<h3><a class="toc-backref" href="#id45" role="doc-backlink">Possible Issues: Failed to find system headers</a><a class="headerlink" href="#possible-issues-failed-to-find-system-headers" title="Link to this heading">¶</a></h3>
<p>In case the users encounter errors like <code class="docutils literal notranslate"><span class="pre">fatal</span> <span class="pre">error:</span> <span class="pre">'stddef.h'</span> <span class="pre">file</span> <span class="pre">not</span> <span class="pre">found</span></code>,
probably the specified <code class="docutils literal notranslate"><span class="pre">&lt;path-to-compiler-executable&gt;/clang++</span></code> refers to a symlink
instead a real binary. There are 4 potential solutions to the problem:</p>
<ul class="simple">
<li><p>(1) End users can resolve the issue by pointing the specified compiler executable to
the real binary instead of the symlink.</p></li>
<li><p>(2) End users can invoke <code class="docutils literal notranslate"><span class="pre">&lt;path-to-compiler-executable&gt;/clang++</span> <span class="pre">-print-resource-dir</span></code>
to get the corresponding resource directory for your compiler and add that directory
to the include search paths manually in the build scripts.</p></li>
<li><p>(3) Build systems that use a compilation database as the input for clang-scan-deps
scanner, the build system can add the flag <code class="docutils literal notranslate"><span class="pre">--resource-dir-recipe</span> <span class="pre">invoke-compiler</span></code> to
the clang-scan-deps scanner to calculate the resources directory dynamically.
The calculation happens only once for a unique <code class="docutils literal notranslate"><span class="pre">&lt;path-to-compiler-executable&gt;/clang++</span></code>.</p></li>
<li><p>(4) For build systems that invokes the clang-scan-deps scanner per file, repeatedly
calculating the resource directory may be inefficient. In such cases, the build
system can cache the resource directory by itself and pass <code class="docutils literal notranslate"><span class="pre">-resource-dir</span> <span class="pre">&lt;resource-dir&gt;</span></code>
explicitly in the command line options:</p></li>
</ul>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang-scan-deps<span class="w"> </span>-format<span class="o">=</span>p1689<span class="w"> </span>--<span class="w"> </span>&lt;path-to-compiler-executable&gt;/clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>-resource-dir<span class="w"> </span>&lt;resource-dir&gt;<span class="w"> </span>mod.cppm<span class="w"> </span>-c<span class="w"> </span>-o<span class="w"> </span>mod.o
</pre></div>
</div>
</section>
</section>
<section id="possible-questions">
<h2><a class="toc-backref" href="#id46" role="doc-backlink">Possible Questions</a><a class="headerlink" href="#possible-questions" title="Link to this heading">¶</a></h2>
<section id="how-modules-speed-up-compilation">
<h3><a class="toc-backref" href="#id47" role="doc-backlink">How modules speed up compilation</a><a class="headerlink" href="#how-modules-speed-up-compilation" title="Link to this heading">¶</a></h3>
<p>A classic theory for the reason why modules speed up the compilation is:
if there are <code class="docutils literal notranslate"><span class="pre">n</span></code> headers and <code class="docutils literal notranslate"><span class="pre">m</span></code> source files and each header is included by each source file,
then the complexity of the compilation is <code class="docutils literal notranslate"><span class="pre">O(n*m)</span></code>;
But if there are <code class="docutils literal notranslate"><span class="pre">n</span></code> module interfaces and <code class="docutils literal notranslate"><span class="pre">m</span></code> source files, the complexity of the compilation is
<code class="docutils literal notranslate"><span class="pre">O(n+m)</span></code>. So, using modules would be a big win when scaling.
In a simpler word, we could get rid of many redundant compilations by using modules.</p>
<p>Roughly, this theory is correct. But the problem is that it is too rough.
The behavior depends on the optimization level, as we will illustrate below.</p>
<p>First is <code class="docutils literal notranslate"><span class="pre">O0</span></code>. The compilation process is described in the following graph.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>├-------------frontend----------┼-------------middle end----------------┼----backend----┤
│                               │                                       │               │
└---parsing----sema----codegen--┴----- transformations ---- codegen ----┴---- codegen --┘

┌---------------------------------------------------------------------------------------┐
|                                                                                       │
|                                     source file                                       │
|                                                                                       │
└---------------------------------------------------------------------------------------┘

            ┌--------┐
            │        │
            │imported│
            │        │
            │  code  │
            │        │
            └--------┘
</pre></div>
</div>
<p>Here we can see that the source file (could be a non-module unit or a module unit) would get processed by the
whole pipeline.
But the imported code would only get involved in semantic analysis, which is mainly about name lookup,
overload resolution and template instantiation.
All of these processes are fast relative to the whole compilation process.
More importantly, the imported code only needs to be processed once in frontend code generation,
as well as the whole middle end and backend.
So we could get a big win for the compilation time in O0.</p>
<p>But with optimizations, things are different:</p>
<p>(we omit <code class="docutils literal notranslate"><span class="pre">code</span> <span class="pre">generation</span></code> part for each end due to the limited space)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>├-------- frontend ---------┼--------------- middle end --------------------┼------ backend ----┤
│                           │                                               │                   │
└--- parsing ---- sema -----┴--- optimizations --- IPO ---- optimizations---┴--- optimizations -┘

┌-----------------------------------------------------------------------------------------------┐
│                                                                                               │
│                                         source file                                           │
│                                                                                               │
└-----------------------------------------------------------------------------------------------┘
              ┌---------------------------------------┐
              │                                       │
              │                                       │
              │            imported code              │
              │                                       │
              │                                       │
              └---------------------------------------┘
</pre></div>
</div>
<p>It would be very unfortunate if we end up with worse performance after using modules.
The main concern is that when we compile a source file, the compiler needs to see the function body
of imported module units so that it can perform IPO (InterProcedural Optimization, primarily inlining
in practice) to optimize functions in current source file with the help of the information provided by
the imported module units.
In other words, the imported code would be processed again and again in importee units
by optimizations (including IPO itself).
The optimizations before IPO and the IPO itself are the most time-consuming part in whole compilation process.
So from this perspective, we might not be able to get the improvements described in the theory.
But we could still save the time for optimizations after IPO and the whole backend.</p>
<p>Overall, at <code class="docutils literal notranslate"><span class="pre">O0</span></code> the implementations of functions defined in a module will not impact module users,
but at higher optimization levels the definitions of such functions are provided to user compilations for the
purposes of optimization (but definitions of these functions are still not included in the use's object file)-
this means the build speedup at higher optimization levels may be lower than expected given <code class="docutils literal notranslate"><span class="pre">O0</span></code> experience,
but does provide by more optimization opportunities.</p>
</section>
<section id="interoperability-with-clang-modules">
<h3><a class="toc-backref" href="#id48" role="doc-backlink">Interoperability with Clang Modules</a><a class="headerlink" href="#interoperability-with-clang-modules" title="Link to this heading">¶</a></h3>
<p>We <strong>wish</strong> to support clang modules and standard c++ modules at the same time,
but the mixed using form is not well used/tested yet.</p>
<p>Please file new github issues as you find interoperability problems.</p>
</section>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="Bottom">
      
        <p>
        «&#160;&#160;<a href="SourceBasedCodeCoverage.html">Source-based Code Coverage</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">目录</a>
        &#160;&#160;::&#160;&#160;
        <a href="Modules.html">Modules</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
    &#169; 版权所有 2007-2025, The Clang Team.
      由 <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3创建。
    </div>
  </body>
</html>