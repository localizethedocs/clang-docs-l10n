<!DOCTYPE html>

<html lang="zh-CN" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>SanitizerCoverage &#8212; Clang 3.9 文档</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=d75fae25" />
    <link rel="stylesheet" type="text/css" href="_static/haiku.css?v=fce32b03" />
    <script src="_static/documentation_options.js?v=9016a3c2"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/translations.js?v=beaddf03"></script>
    <link rel="canonical" href="https://projects.localizethedocs.org/clang-docs-l10n/SanitizerCoverage.html" />
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="搜索" href="search.html" />
    <link rel="next" title="SanitizerStats" href="SanitizerStats.html" />
    <link rel="prev" title="LeakSanitizer" href="LeakSanitizer.html" />
<script type="text/javascript" src="ltd-provenance.js"></script>
<script type="text/javascript" src="ltd-current.js"></script>
<script type="text/javascript" src="../../ltd-config.js"></script>
<script type="text/javascript" src="../../ltd-flyout.js"></script>

  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Clang 3.9 文档</span></a></h1>
        <h2 class="heading"><span>SanitizerCoverage</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="Top">
      
        <p>
        «&#160;&#160;<a href="LeakSanitizer.html">LeakSanitizer</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">目录</a>
        &#160;&#160;::&#160;&#160;
        <a href="SanitizerStats.html">SanitizerStats</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="sanitizercoverage">
<h1>SanitizerCoverage<a class="headerlink" href="#sanitizercoverage" title="Link to this heading">¶</a></h1>
<nav class="contents local" id="id1">
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id2">Introduction</a></p></li>
<li><p><a class="reference internal" href="#how-to-build-and-run" id="id3">How to build and run</a></p></li>
<li><p><a class="reference internal" href="#postprocessing" id="id4">Postprocessing</a></p></li>
<li><p><a class="reference internal" href="#sancov-tool" id="id5">Sancov Tool</a></p></li>
<li><p><a class="reference internal" href="#automatic-html-report-generation" id="id6">Automatic HTML Report Generation</a></p></li>
<li><p><a class="reference internal" href="#how-good-is-the-coverage" id="id7">How good is the coverage?</a></p></li>
<li><p><a class="reference internal" href="#edge-coverage" id="id8">Edge coverage</a></p></li>
<li><p><a class="reference internal" href="#bitset" id="id9">Bitset</a></p></li>
<li><p><a class="reference internal" href="#caller-callee-coverage" id="id10">Caller-callee coverage</a></p></li>
<li><p><a class="reference internal" href="#coverage-counters" id="id11">Coverage counters</a></p></li>
<li><p><a class="reference internal" href="#tracing-basic-blocks" id="id12">Tracing basic blocks</a></p></li>
<li><p><a class="reference internal" href="#tracing-pcs" id="id13">Tracing PCs</a></p></li>
<li><p><a class="reference internal" href="#tracing-data-flow" id="id14">Tracing data flow</a></p></li>
<li><p><a class="reference internal" href="#output-directory" id="id15">Output directory</a></p></li>
<li><p><a class="reference internal" href="#sudden-death" id="id16">Sudden death</a></p></li>
<li><p><a class="reference internal" href="#in-process-fuzzing" id="id17">In-process fuzzing</a></p></li>
<li><p><a class="reference internal" href="#performance" id="id18">Performance</a></p></li>
<li><p><a class="reference internal" href="#why-another-coverage" id="id19">Why another coverage?</a></p></li>
</ul>
</nav>
<section id="introduction">
<h2><a class="toc-backref" href="#id2" role="doc-backlink">Introduction</a><a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p>Sanitizer tools have a very simple code coverage tool built in. It allows to
get function-level, basic-block-level, and edge-level coverage at a very low
cost.</p>
</section>
<section id="how-to-build-and-run">
<h2><a class="toc-backref" href="#id3" role="doc-backlink">How to build and run</a><a class="headerlink" href="#how-to-build-and-run" title="Link to this heading">¶</a></h2>
<p>SanitizerCoverage can be used with <a class="reference internal" href="AddressSanitizer.html"><span class="doc">AddressSanitizer</span></a>,
<a class="reference internal" href="LeakSanitizer.html"><span class="doc">LeakSanitizer</span></a>, <a class="reference internal" href="MemorySanitizer.html"><span class="doc">MemorySanitizer</span></a>,
UndefinedBehaviorSanitizer, or without any sanitizer.  Pass one of the
following compile-time flags:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">-fsanitize-coverage=func</span></code> for function-level coverage (very fast).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-fsanitize-coverage=bb</span></code> for basic-block-level coverage (may add up to 30%
<strong>extra</strong> slowdown).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-fsanitize-coverage=edge</span></code> for edge-level coverage (up to 40% slowdown).</p></li>
</ul>
<p>You may also specify <code class="docutils literal notranslate"><span class="pre">-fsanitize-coverage=indirect-calls</span></code> for
additional <a class="reference internal" href="#caller-callee-coverage">caller-callee coverage</a>.</p>
<p>At run time, pass <code class="docutils literal notranslate"><span class="pre">coverage=1</span></code> in <code class="docutils literal notranslate"><span class="pre">ASAN_OPTIONS</span></code>,
<code class="docutils literal notranslate"><span class="pre">LSAN_OPTIONS</span></code>, <code class="docutils literal notranslate"><span class="pre">MSAN_OPTIONS</span></code> or <code class="docutils literal notranslate"><span class="pre">UBSAN_OPTIONS</span></code>, as
appropriate. For the standalone coverage mode, use <code class="docutils literal notranslate"><span class="pre">UBSAN_OPTIONS</span></code>.</p>
<p>To get <a class="reference internal" href="#coverage-counters">Coverage counters</a>, add <code class="docutils literal notranslate"><span class="pre">-fsanitize-coverage=8bit-counters</span></code>
to one of the above compile-time flags. At runtime, use
<code class="docutils literal notranslate"><span class="pre">*SAN_OPTIONS=coverage=1:coverage_counters=1</span></code>.</p>
<p>Example:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">% </span>cat<span class="w"> </span>-n<span class="w"> </span>cov.cc
<span class="go">     1  #include &lt;stdio.h&gt;</span>
<span class="go">     2  __attribute__((noinline))</span>
<span class="go">     3  void foo() { printf(&quot;foo\n&quot;); }</span>
<span class="go">     4</span>
<span class="go">     5  int main(int argc, char **argv) {</span>
<span class="go">     6    if (argc == 2)</span>
<span class="go">     7      foo();</span>
<span class="go">     8    printf(&quot;main\n&quot;);</span>
<span class="go">     9  }</span>
<span class="gp">% </span>clang++<span class="w"> </span>-g<span class="w"> </span>cov.cc<span class="w"> </span>-fsanitize<span class="o">=</span>address<span class="w"> </span>-fsanitize-coverage<span class="o">=</span>func
<span class="gp">% </span><span class="nv">ASAN_OPTIONS</span><span class="o">=</span><span class="nv">coverage</span><span class="o">=</span><span class="m">1</span><span class="w"> </span>./a.out<span class="p">;</span><span class="w"> </span>ls<span class="w"> </span>-l<span class="w"> </span>*sancov
<span class="go">main</span>
<span class="go">-rw-r----- 1 kcc eng 4 Nov 27 12:21 a.out.22673.sancov</span>
<span class="gp">% </span><span class="nv">ASAN_OPTIONS</span><span class="o">=</span><span class="nv">coverage</span><span class="o">=</span><span class="m">1</span><span class="w"> </span>./a.out<span class="w"> </span>foo<span class="w"> </span><span class="p">;</span><span class="w"> </span>ls<span class="w"> </span>-l<span class="w"> </span>*sancov
<span class="go">foo</span>
<span class="go">main</span>
<span class="go">-rw-r----- 1 kcc eng 4 Nov 27 12:21 a.out.22673.sancov</span>
<span class="go">-rw-r----- 1 kcc eng 8 Nov 27 12:21 a.out.22679.sancov</span>
</pre></div>
</div>
<p>Every time you run an executable instrumented with SanitizerCoverage
one <code class="docutils literal notranslate"><span class="pre">*.sancov</span></code> file is created during the process shutdown.
If the executable is dynamically linked against instrumented DSOs,
one <code class="docutils literal notranslate"><span class="pre">*.sancov</span></code> file will be also created for every DSO.</p>
</section>
<section id="postprocessing">
<h2><a class="toc-backref" href="#id4" role="doc-backlink">Postprocessing</a><a class="headerlink" href="#postprocessing" title="Link to this heading">¶</a></h2>
<p>The format of <code class="docutils literal notranslate"><span class="pre">*.sancov</span></code> files is very simple: the first 8 bytes is the magic,
one of <code class="docutils literal notranslate"><span class="pre">0xC0BFFFFFFFFFFF64</span></code> and <code class="docutils literal notranslate"><span class="pre">0xC0BFFFFFFFFFFF32</span></code>. The last byte of the
magic defines the size of the following offsets. The rest of the data is the
offsets in the corresponding binary/DSO that were executed during the run.</p>
<p>A simple script
<code class="docutils literal notranslate"><span class="pre">$LLVM/projects/compiler-rt/lib/sanitizer_common/scripts/sancov.py</span></code> is
provided to dump these offsets.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">% </span>sancov.py<span class="w"> </span>print<span class="w"> </span>a.out.22679.sancov<span class="w"> </span>a.out.22673.sancov
<span class="go">sancov.py: read 2 PCs from a.out.22679.sancov</span>
<span class="go">sancov.py: read 1 PCs from a.out.22673.sancov</span>
<span class="go">sancov.py: 2 files merged; 2 PCs total</span>
<span class="go">0x465250</span>
<span class="go">0x4652a0</span>
</pre></div>
</div>
<p>You can then filter the output of <code class="docutils literal notranslate"><span class="pre">sancov.py</span></code> through <code class="docutils literal notranslate"><span class="pre">addr2line</span> <span class="pre">--exe</span>
<span class="pre">ObjectFile</span></code> or <code class="docutils literal notranslate"><span class="pre">llvm-symbolizer</span> <span class="pre">--obj</span> <span class="pre">ObjectFile</span></code> to get file names and line
numbers:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">% </span>sancov.py<span class="w"> </span>print<span class="w"> </span>a.out.22679.sancov<span class="w"> </span>a.out.22673.sancov<span class="w"> </span><span class="m">2</span>&gt;<span class="w"> </span>/dev/null<span class="w"> </span><span class="p">|</span><span class="w"> </span>llvm-symbolizer<span class="w"> </span>--obj<span class="w"> </span>a.out
<span class="go">cov.cc:3</span>
<span class="go">cov.cc:5</span>
</pre></div>
</div>
</section>
<section id="sancov-tool">
<h2><a class="toc-backref" href="#id5" role="doc-backlink">Sancov Tool</a><a class="headerlink" href="#sancov-tool" title="Link to this heading">¶</a></h2>
<p>A new experimental <code class="docutils literal notranslate"><span class="pre">sancov</span></code> tool is developed to process coverage files.
The tool is part of LLVM project and is currently supported only on Linux.
It can handle symbolization tasks autonomously without any extra support
from the environment. You need to pass .sancov files (named
<code class="docutils literal notranslate"><span class="pre">&lt;module_name&gt;.&lt;pid&gt;.sancov</span></code> and paths to all corresponding binary elf files.
Sancov matches these files using module names and binaries file names.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">USAGE: sancov [options] &lt;action&gt; (&lt;binary file&gt;|&lt;.sancov file&gt;)...</span>

<span class="go">Action (required)</span>
<span class="go">  -print                    - Print coverage addresses</span>
<span class="go">  -covered-functions        - Print all covered functions.</span>
<span class="go">  -not-covered-functions    - Print all not covered functions.</span>
<span class="go">  -html-report              - Print HTML coverage report.</span>

<span class="go">Options</span>
<span class="go">  -blacklist=&lt;string&gt;         - Blacklist file (sanitizer blacklist format).</span>
<span class="go">  -demangle                   - Print demangled function name.</span>
<span class="go">  -strip_path_prefix=&lt;string&gt; - Strip this prefix from file paths in reports</span>
</pre></div>
</div>
</section>
<section id="automatic-html-report-generation">
<h2><a class="toc-backref" href="#id6" role="doc-backlink">Automatic HTML Report Generation</a><a class="headerlink" href="#automatic-html-report-generation" title="Link to this heading">¶</a></h2>
<p>If <code class="docutils literal notranslate"><span class="pre">*SAN_OPTIONS</span></code> contains <code class="docutils literal notranslate"><span class="pre">html_cov_report=1</span></code> option set, then html
coverage report would be automatically generated alongside the coverage files.
The <code class="docutils literal notranslate"><span class="pre">sancov</span></code> binary should be present in <code class="docutils literal notranslate"><span class="pre">PATH</span></code> or
<code class="docutils literal notranslate"><span class="pre">sancov_path=&lt;path_to_sancov</span></code> option can be used to specify tool location.</p>
</section>
<section id="how-good-is-the-coverage">
<h2><a class="toc-backref" href="#id7" role="doc-backlink">How good is the coverage?</a><a class="headerlink" href="#how-good-is-the-coverage" title="Link to this heading">¶</a></h2>
<p>It is possible to find out which PCs are not covered, by subtracting the covered
set from the set of all instrumented PCs. The latter can be obtained by listing
all callsites of <code class="docutils literal notranslate"><span class="pre">__sanitizer_cov()</span></code> in the binary. On Linux, <code class="docutils literal notranslate"><span class="pre">sancov.py</span></code>
can do this for you. Just supply the path to binary and a list of covered PCs:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">% </span>sancov.py<span class="w"> </span>print<span class="w"> </span>a.out.12345.sancov<span class="w"> </span>&gt;<span class="w"> </span>covered.txt
<span class="go">sancov.py: read 2 64-bit PCs from a.out.12345.sancov</span>
<span class="go">sancov.py: 1 file merged; 2 PCs total</span>
<span class="gp">% </span>sancov.py<span class="w"> </span>missing<span class="w"> </span>a.out<span class="w"> </span>&lt;<span class="w"> </span>covered.txt
<span class="go">sancov.py: found 3 instrumented PCs in a.out</span>
<span class="go">sancov.py: read 2 PCs from stdin</span>
<span class="go">sancov.py: 1 PCs missing from coverage</span>
<span class="go">0x4cc61c</span>
</pre></div>
</div>
</section>
<section id="edge-coverage">
<h2><a class="toc-backref" href="#id8" role="doc-backlink">Edge coverage</a><a class="headerlink" href="#edge-coverage" title="Link to this heading">¶</a></h2>
<p>Consider this code:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="w">    </span><span class="o">*</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>It contains 3 basic blocks, let's name them A, B, C:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>A
|\
| \
|  B
| /
|/
C
</pre></div>
</div>
<p>If blocks A, B, and C are all covered we know for certain that the edges A=&gt;B
and B=&gt;C were executed, but we still don't know if the edge A=&gt;C was executed.
Such edges of control flow graph are called
<a class="reference external" href="http://en.wikipedia.org/wiki/Control_flow_graph#Special_edges">critical</a>. The
edge-level coverage (<code class="docutils literal notranslate"><span class="pre">-fsanitize-coverage=edge</span></code>) simply splits all critical
edges by introducing new dummy blocks and then instruments those blocks:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>A
|\
| \
D  B
| /
|/
C
</pre></div>
</div>
</section>
<section id="bitset">
<h2><a class="toc-backref" href="#id9" role="doc-backlink">Bitset</a><a class="headerlink" href="#bitset" title="Link to this heading">¶</a></h2>
<p>When <code class="docutils literal notranslate"><span class="pre">coverage_bitset=1</span></code> run-time flag is given, the coverage will also be
dumped as a bitset (text file with 1 for blocks that have been executed and 0
for blocks that were not).</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">% </span>clang++<span class="w"> </span>-fsanitize<span class="o">=</span>address<span class="w"> </span>-fsanitize-coverage<span class="o">=</span>edge<span class="w"> </span>cov.cc
<span class="gp">% </span><span class="nv">ASAN_OPTIONS</span><span class="o">=</span><span class="s2">&quot;coverage=1:coverage_bitset=1&quot;</span><span class="w"> </span>./a.out
<span class="go">main</span>
<span class="gp">% </span><span class="nv">ASAN_OPTIONS</span><span class="o">=</span><span class="s2">&quot;coverage=1:coverage_bitset=1&quot;</span><span class="w"> </span>./a.out<span class="w"> </span><span class="m">1</span>
<span class="go">foo</span>
<span class="go">main</span>
<span class="gp">% </span>head<span class="w"> </span>*bitset*
<span class="go">==&gt; a.out.38214.bitset-sancov &lt;==</span>
<span class="go">01101</span>
<span class="go">==&gt; a.out.6128.bitset-sancov &lt;==</span>
<span class="go">11011%</span>
</pre></div>
</div>
<p>For a given executable the length of the bitset is always the same (well,
unless dlopen/dlclose come into play), so the bitset coverage can be
easily used for bitset-based corpus distillation.</p>
</section>
<section id="caller-callee-coverage">
<h2><a class="toc-backref" href="#id10" role="doc-backlink">Caller-callee coverage</a><a class="headerlink" href="#caller-callee-coverage" title="Link to this heading">¶</a></h2>
<p>(Experimental!)
Every indirect function call is instrumented with a run-time function call that
captures caller and callee.  At the shutdown time the process dumps a separate
file called <code class="docutils literal notranslate"><span class="pre">caller-callee.PID.sancov</span></code> which contains caller/callee pairs as
pairs of lines (odd lines are callers, even lines are callees)</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">a.out 0x4a2e0c</span>
<span class="go">a.out 0x4a6510</span>
<span class="go">a.out 0x4a2e0c</span>
<span class="go">a.out 0x4a87f0</span>
</pre></div>
</div>
<p>Current limitations:</p>
<ul class="simple">
<li><p>Only the first 14 callees for every caller are recorded, the rest are silently
ignored.</p></li>
<li><p>The output format is not very compact since caller and callee may reside in
different modules and we need to spell out the module names.</p></li>
<li><p>The routine that dumps the output is not optimized for speed</p></li>
<li><p>Only Linux x86_64 is tested so far.</p></li>
<li><p>Sandboxes are not supported.</p></li>
</ul>
</section>
<section id="coverage-counters">
<h2><a class="toc-backref" href="#id11" role="doc-backlink">Coverage counters</a><a class="headerlink" href="#coverage-counters" title="Link to this heading">¶</a></h2>
<p>This experimental feature is inspired by
<a class="reference external" href="http://lcamtuf.coredump.cx/afl/technical_details.txt">AFL</a>'s coverage
instrumentation. With additional compile-time and run-time flags you can get
more sensitive coverage information.  In addition to boolean values assigned to
every basic block (edge) the instrumentation will collect imprecise counters.
On exit, every counter will be mapped to a 8-bit bitset representing counter
ranges: <code class="docutils literal notranslate"><span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4-7,</span> <span class="pre">8-15,</span> <span class="pre">16-31,</span> <span class="pre">32-127,</span> <span class="pre">128+</span></code> and those 8-bit bitsets will
be dumped to disk.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">% </span>clang++<span class="w"> </span>-g<span class="w"> </span>cov.cc<span class="w"> </span>-fsanitize<span class="o">=</span>address<span class="w"> </span>-fsanitize-coverage<span class="o">=</span>edge,8bit-counters
<span class="gp">% </span><span class="nv">ASAN_OPTIONS</span><span class="o">=</span><span class="s2">&quot;coverage=1:coverage_counters=1&quot;</span><span class="w"> </span>./a.out
<span class="gp">% </span>ls<span class="w"> </span>-l<span class="w"> </span>*counters-sancov
<span class="go">... a.out.17110.counters-sancov</span>
<span class="gp">% </span>xxd<span class="w"> </span>*counters-sancov
<span class="go">0000000: 0001 0100 01</span>
</pre></div>
</div>
<p>These counters may also be used for in-process coverage-guided fuzzers. See
<code class="docutils literal notranslate"><span class="pre">include/sanitizer/coverage_interface.h</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// The coverage instrumentation may optionally provide imprecise counters.</span>
<span class="c1">// Rather than exposing the counter values to the user we instead map</span>
<span class="c1">// the counters to a bitset.</span>
<span class="c1">// Every counter is associated with 8 bits in the bitset.</span>
<span class="c1">// We define 8 value ranges: 1, 2, 3, 4-7, 8-15, 16-31, 32-127, 128+</span>
<span class="c1">// The i-th bit is set to 1 if the counter value is in the i-th range.</span>
<span class="c1">// This counter-based coverage implementation is *not* thread-safe.</span>

<span class="c1">// Returns the number of registered coverage counters.</span>
<span class="kt">uintptr_t</span><span class="w"> </span><span class="nf">__sanitizer_get_number_of_counters</span><span class="p">();</span>
<span class="c1">// Updates the counter &#39;bitset&#39;, clears the counters and returns the number of</span>
<span class="c1">// new bits in &#39;bitset&#39;.</span>
<span class="c1">// If &#39;bitset&#39; is nullptr, only clears the counters.</span>
<span class="c1">// Otherwise &#39;bitset&#39; should be at least</span>
<span class="c1">// __sanitizer_get_number_of_counters bytes long and 8-aligned.</span>
<span class="kt">uintptr_t</span>
<span class="nf">__sanitizer_update_counter_bitset_and_clear_counters</span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">bitset</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="tracing-basic-blocks">
<h2><a class="toc-backref" href="#id12" role="doc-backlink">Tracing basic blocks</a><a class="headerlink" href="#tracing-basic-blocks" title="Link to this heading">¶</a></h2>
<p>Experimental support for basic block (or edge) tracing.
With <code class="docutils literal notranslate"><span class="pre">-fsanitize-coverage=trace-bb</span></code> the compiler will insert
<code class="docutils literal notranslate"><span class="pre">__sanitizer_cov_trace_basic_block(s32</span> <span class="pre">*id)</span></code> before every function, basic block, or edge
(depending on the value of <code class="docutils literal notranslate"><span class="pre">-fsanitize-coverage=[func,bb,edge]</span></code>).
Example:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">% </span>clang<span class="w"> </span>-g<span class="w"> </span>-fsanitize<span class="o">=</span>address<span class="w"> </span>-fsanitize-coverage<span class="o">=</span>edge,trace-bb<span class="w"> </span>foo.cc
<span class="gp">% </span><span class="nv">ASAN_OPTIONS</span><span class="o">=</span><span class="nv">coverage</span><span class="o">=</span><span class="m">1</span><span class="w"> </span>./a.out
</pre></div>
</div>
<p>This will produce two files after the process exit:
<cite>trace-points.PID.sancov</cite> and <cite>trace-events.PID.sancov</cite>.
The first file will contain a textual description of all the instrumented points in the program
in the form that you can feed into llvm-symbolizer (e.g. <cite>a.out 0x4dca89</cite>), one per line.
The second file will contain the actual execution trace as a sequence of 4-byte integers
-- these integers are the indices into the array of instrumented points (the first file).</p>
<p>Basic block tracing is currently supported only for single-threaded applications.</p>
</section>
<section id="tracing-pcs">
<h2><a class="toc-backref" href="#id13" role="doc-backlink">Tracing PCs</a><a class="headerlink" href="#tracing-pcs" title="Link to this heading">¶</a></h2>
<p><em>Experimental</em> feature similar to tracing basic blocks, but with a different API.
With <code class="docutils literal notranslate"><span class="pre">-fsanitize-coverage=trace-pc</span></code> the compiler will insert
<code class="docutils literal notranslate"><span class="pre">__sanitizer_cov_trace_pc()</span></code> on every edge.
With an additional <code class="docutils literal notranslate"><span class="pre">...=trace-pc,indirect-calls</span></code> flag
<code class="docutils literal notranslate"><span class="pre">__sanitizer_cov_trace_pc_indirect(void</span> <span class="pre">*callee)</span></code> will be inserted on every indirect call.
These callbacks are not implemented in the Sanitizer run-time and should be defined
by the user. So, these flags do not require the other sanitizer to be used.
This mechanism is used for fuzzing the Linux kernel (<a class="reference external" href="https://github.com/google/syzkaller">https://github.com/google/syzkaller</a>)
and can be used with <a class="reference external" href="http://lcamtuf.coredump.cx/afl">AFL</a>.</p>
</section>
<section id="tracing-data-flow">
<h2><a class="toc-backref" href="#id14" role="doc-backlink">Tracing data flow</a><a class="headerlink" href="#tracing-data-flow" title="Link to this heading">¶</a></h2>
<p>An <em>experimental</em> feature to support data-flow-guided fuzzing.
With <code class="docutils literal notranslate"><span class="pre">-fsanitize-coverage=trace-cmp</span></code> the compiler will insert extra instrumentation
around comparison instructions and switch statements.
The fuzzer will need to define the following functions,
they will be called by the instrumented code.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Called before a comparison instruction.</span>
<span class="c1">// SizeAndType is a packed value containing</span>
<span class="c1">//   - [63:32] the Size of the operands of comparison in bits</span>
<span class="c1">//   - [31:0] the Type of comparison (one of ICMP_EQ, ... ICMP_SLE)</span>
<span class="c1">// Arg1 and Arg2 are arguments of the comparison.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">__sanitizer_cov_trace_cmp</span><span class="p">(</span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">SizeAndType</span><span class="p">,</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">Arg1</span><span class="p">,</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">Arg2</span><span class="p">);</span>

<span class="c1">// Called before a switch statement.</span>
<span class="c1">// Val is the switch operand.</span>
<span class="c1">// Cases[0] is the number of case constants.</span>
<span class="c1">// Cases[1] is the size of Val in bits.</span>
<span class="c1">// Cases[2:] are the case constants.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">__sanitizer_cov_trace_switch</span><span class="p">(</span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">Val</span><span class="p">,</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="o">*</span><span class="n">Cases</span><span class="p">);</span>
</pre></div>
</div>
<p>This interface is a subject to change.
The current implementation is not thread-safe and thus can be safely used only for single-threaded targets.</p>
</section>
<section id="output-directory">
<h2><a class="toc-backref" href="#id15" role="doc-backlink">Output directory</a><a class="headerlink" href="#output-directory" title="Link to this heading">¶</a></h2>
<p>By default, .sancov files are created in the current working directory.
This can be changed with <code class="docutils literal notranslate"><span class="pre">ASAN_OPTIONS=coverage_dir=/path</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">% </span><span class="nv">ASAN_OPTIONS</span><span class="o">=</span><span class="s2">&quot;coverage=1:coverage_dir=/tmp/cov&quot;</span><span class="w"> </span>./a.out<span class="w"> </span>foo
<span class="gp">% </span>ls<span class="w"> </span>-l<span class="w"> </span>/tmp/cov/*sancov
<span class="go">-rw-r----- 1 kcc eng 4 Nov 27 12:21 a.out.22673.sancov</span>
<span class="go">-rw-r----- 1 kcc eng 8 Nov 27 12:21 a.out.22679.sancov</span>
</pre></div>
</div>
</section>
<section id="sudden-death">
<h2><a class="toc-backref" href="#id16" role="doc-backlink">Sudden death</a><a class="headerlink" href="#sudden-death" title="Link to this heading">¶</a></h2>
<p>Normally, coverage data is collected in memory and saved to disk when the
program exits (with an <code class="docutils literal notranslate"><span class="pre">atexit()</span></code> handler), when a SIGSEGV is caught, or when
<code class="docutils literal notranslate"><span class="pre">__sanitizer_cov_dump()</span></code> is called.</p>
<p>If the program ends with a signal that ASan does not handle (or can not handle
at all, like SIGKILL), coverage data will be lost. This is a big problem on
Android, where SIGKILL is a normal way of evicting applications from memory.</p>
<p>With <code class="docutils literal notranslate"><span class="pre">ASAN_OPTIONS=coverage=1:coverage_direct=1</span></code> coverage data is written to a
memory-mapped file as soon as it collected.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">% </span><span class="nv">ASAN_OPTIONS</span><span class="o">=</span><span class="s2">&quot;coverage=1:coverage_direct=1&quot;</span><span class="w"> </span>./a.out
<span class="go">main</span>
<span class="gp">% </span>ls
<span class="go">7036.sancov.map  7036.sancov.raw  a.out</span>
<span class="gp">% </span>sancov.py<span class="w"> </span>rawunpack<span class="w"> </span><span class="m">7036</span>.sancov.raw
<span class="go">sancov.py: reading map 7036.sancov.map</span>
<span class="go">sancov.py: unpacking 7036.sancov.raw</span>
<span class="go">writing 1 PCs to a.out.7036.sancov</span>
<span class="gp">% </span>sancov.py<span class="w"> </span>print<span class="w"> </span>a.out.7036.sancov
<span class="go">sancov.py: read 1 PCs from a.out.7036.sancov</span>
<span class="go">sancov.py: 1 files merged; 1 PCs total</span>
<span class="go">0x4b2bae</span>
</pre></div>
</div>
<p>Note that on 64-bit platforms, this method writes 2x more data than the default,
because it stores full PC values instead of 32-bit offsets.</p>
</section>
<section id="in-process-fuzzing">
<h2><a class="toc-backref" href="#id17" role="doc-backlink">In-process fuzzing</a><a class="headerlink" href="#in-process-fuzzing" title="Link to this heading">¶</a></h2>
<p>Coverage data could be useful for fuzzers and sometimes it is preferable to run
a fuzzer in the same process as the code being fuzzed (in-process fuzzer).</p>
<p>You can use <code class="docutils literal notranslate"><span class="pre">__sanitizer_get_total_unique_coverage()</span></code> from
<code class="docutils literal notranslate"><span class="pre">&lt;sanitizer/coverage_interface.h&gt;</span></code> which returns the number of currently
covered entities in the program. This will tell the fuzzer if the coverage has
increased after testing every new input.</p>
<p>If a fuzzer finds a bug in the ASan run, you will need to save the reproducer
before exiting the process.  Use <code class="docutils literal notranslate"><span class="pre">__asan_set_death_callback</span></code> from
<code class="docutils literal notranslate"><span class="pre">&lt;sanitizer/asan_interface.h&gt;</span></code> to do that.</p>
<p>An example of such fuzzer can be found in <a class="reference external" href="http://llvm.org/viewvc/llvm-project/llvm/trunk/lib/Fuzzer/README.txt?view=markup">the LLVM tree</a>.</p>
</section>
<section id="performance">
<h2><a class="toc-backref" href="#id18" role="doc-backlink">Performance</a><a class="headerlink" href="#performance" title="Link to this heading">¶</a></h2>
<p>This coverage implementation is <strong>fast</strong>. With function-level coverage
(<code class="docutils literal notranslate"><span class="pre">-fsanitize-coverage=func</span></code>) the overhead is not measurable. With
basic-block-level coverage (<code class="docutils literal notranslate"><span class="pre">-fsanitize-coverage=bb</span></code>) the overhead varies
between 0 and 25%.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>benchmark</p></th>
<th class="head"><p>cov0</p></th>
<th class="head"><p>cov1</p></th>
<th class="head"><p>diff 0-1</p></th>
<th class="head"><p>cov2</p></th>
<th class="head"><p>diff 0-2</p></th>
<th class="head"><p>diff 1-2</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>400.perlbench</p></td>
<td><p>1296.00</p></td>
<td><p>1307.00</p></td>
<td><p>1.01</p></td>
<td><p>1465.00</p></td>
<td><p>1.13</p></td>
<td><p>1.12</p></td>
</tr>
<tr class="row-odd"><td><p>401.bzip2</p></td>
<td><p>858.00</p></td>
<td><p>854.00</p></td>
<td><p>1.00</p></td>
<td><p>1010.00</p></td>
<td><p>1.18</p></td>
<td><p>1.18</p></td>
</tr>
<tr class="row-even"><td><p>403.gcc</p></td>
<td><p>613.00</p></td>
<td><p>617.00</p></td>
<td><p>1.01</p></td>
<td><p>683.00</p></td>
<td><p>1.11</p></td>
<td><p>1.11</p></td>
</tr>
<tr class="row-odd"><td><p>429.mcf</p></td>
<td><p>605.00</p></td>
<td><p>582.00</p></td>
<td><p>0.96</p></td>
<td><p>610.00</p></td>
<td><p>1.01</p></td>
<td><p>1.05</p></td>
</tr>
<tr class="row-even"><td><p>445.gobmk</p></td>
<td><p>896.00</p></td>
<td><p>880.00</p></td>
<td><p>0.98</p></td>
<td><p>1050.00</p></td>
<td><p>1.17</p></td>
<td><p>1.19</p></td>
</tr>
<tr class="row-odd"><td><p>456.hmmer</p></td>
<td><p>892.00</p></td>
<td><p>892.00</p></td>
<td><p>1.00</p></td>
<td><p>918.00</p></td>
<td><p>1.03</p></td>
<td><p>1.03</p></td>
</tr>
<tr class="row-even"><td><p>458.sjeng</p></td>
<td><p>995.00</p></td>
<td><p>1009.00</p></td>
<td><p>1.01</p></td>
<td><p>1217.00</p></td>
<td><p>1.22</p></td>
<td><p>1.21</p></td>
</tr>
<tr class="row-odd"><td><p>462.libquantum</p></td>
<td><p>497.00</p></td>
<td><p>492.00</p></td>
<td><p>0.99</p></td>
<td><p>534.00</p></td>
<td><p>1.07</p></td>
<td><p>1.09</p></td>
</tr>
<tr class="row-even"><td><p>464.h264ref</p></td>
<td><p>1461.00</p></td>
<td><p>1467.00</p></td>
<td><p>1.00</p></td>
<td><p>1543.00</p></td>
<td><p>1.06</p></td>
<td><p>1.05</p></td>
</tr>
<tr class="row-odd"><td><p>471.omnetpp</p></td>
<td><p>575.00</p></td>
<td><p>590.00</p></td>
<td><p>1.03</p></td>
<td><p>660.00</p></td>
<td><p>1.15</p></td>
<td><p>1.12</p></td>
</tr>
<tr class="row-even"><td><p>473.astar</p></td>
<td><p>658.00</p></td>
<td><p>652.00</p></td>
<td><p>0.99</p></td>
<td><p>715.00</p></td>
<td><p>1.09</p></td>
<td><p>1.10</p></td>
</tr>
<tr class="row-odd"><td><p>483.xalancbmk</p></td>
<td><p>471.00</p></td>
<td><p>491.00</p></td>
<td><p>1.04</p></td>
<td><p>582.00</p></td>
<td><p>1.24</p></td>
<td><p>1.19</p></td>
</tr>
<tr class="row-even"><td><p>433.milc</p></td>
<td><p>616.00</p></td>
<td><p>627.00</p></td>
<td><p>1.02</p></td>
<td><p>627.00</p></td>
<td><p>1.02</p></td>
<td><p>1.00</p></td>
</tr>
<tr class="row-odd"><td><p>444.namd</p></td>
<td><p>602.00</p></td>
<td><p>601.00</p></td>
<td><p>1.00</p></td>
<td><p>654.00</p></td>
<td><p>1.09</p></td>
<td><p>1.09</p></td>
</tr>
<tr class="row-even"><td><p>447.dealII</p></td>
<td><p>630.00</p></td>
<td><p>634.00</p></td>
<td><p>1.01</p></td>
<td><p>653.00</p></td>
<td><p>1.04</p></td>
<td><p>1.03</p></td>
</tr>
<tr class="row-odd"><td><p>450.soplex</p></td>
<td><p>365.00</p></td>
<td><p>368.00</p></td>
<td><p>1.01</p></td>
<td><p>395.00</p></td>
<td><p>1.08</p></td>
<td><p>1.07</p></td>
</tr>
<tr class="row-even"><td><p>453.povray</p></td>
<td><p>427.00</p></td>
<td><p>434.00</p></td>
<td><p>1.02</p></td>
<td><p>495.00</p></td>
<td><p>1.16</p></td>
<td><p>1.14</p></td>
</tr>
<tr class="row-odd"><td><p>470.lbm</p></td>
<td><p>357.00</p></td>
<td><p>375.00</p></td>
<td><p>1.05</p></td>
<td><p>370.00</p></td>
<td><p>1.04</p></td>
<td><p>0.99</p></td>
</tr>
<tr class="row-even"><td><p>482.sphinx3</p></td>
<td><p>927.00</p></td>
<td><p>928.00</p></td>
<td><p>1.00</p></td>
<td><p>1000.00</p></td>
<td><p>1.08</p></td>
<td><p>1.08</p></td>
</tr>
</tbody>
</table>
</section>
<section id="why-another-coverage">
<h2><a class="toc-backref" href="#id19" role="doc-backlink">Why another coverage?</a><a class="headerlink" href="#why-another-coverage" title="Link to this heading">¶</a></h2>
<dl class="simple">
<dt>Why did we implement yet another code coverage?</dt><dd><ul class="simple">
<li><p>We needed something that is lightning fast, plays well with
AddressSanitizer, and does not significantly increase the binary size.</p></li>
<li><p>Traditional coverage implementations based in global counters
<a class="reference external" href="https://groups.google.com/forum/#!topic/llvm-dev/cDqYgnxNEhY">suffer from contention on counters</a>.</p></li>
</ul>
</dd>
</dl>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="Bottom">
      
        <p>
        «&#160;&#160;<a href="LeakSanitizer.html">LeakSanitizer</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">目录</a>
        &#160;&#160;::&#160;&#160;
        <a href="SanitizerStats.html">SanitizerStats</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
    &#169; 版权所有 2007-2025, The Clang Team.
      由 <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3创建。
    </div>
  </body>
</html>