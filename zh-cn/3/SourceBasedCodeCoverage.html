<!DOCTYPE html>

<html lang="zh-CN" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Source-based Code Coverage &#8212; Clang 3.9 文档</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=d75fae25" />
    <link rel="stylesheet" type="text/css" href="_static/haiku.css?v=fce32b03" />
    <script src="_static/documentation_options.js?v=9016a3c2"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/translations.js?v=beaddf03"></script>
    <link rel="canonical" href="https://projects.localizethedocs.org/clang-docs-l10n/SourceBasedCodeCoverage.html" />
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="搜索" href="search.html" />
    <link rel="next" title="Modules" href="Modules.html" />
    <link rel="prev" title="SafeStack" href="SafeStack.html" />
<script type="text/javascript" src="ltd-provenance.js"></script>
<script type="text/javascript" src="ltd-current.js"></script>
<script type="text/javascript" src="../../ltd-config.js"></script>
<script type="text/javascript" src="../../ltd-flyout.js"></script>

  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Clang 3.9 文档</span></a></h1>
        <h2 class="heading"><span>Source-based Code Coverage</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="Top">
      
        <p>
        «&#160;&#160;<a href="SafeStack.html">SafeStack</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">目录</a>
        &#160;&#160;::&#160;&#160;
        <a href="Modules.html">Modules</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="source-based-code-coverage">
<h1>Source-based Code Coverage<a class="headerlink" href="#source-based-code-coverage" title="Link to this heading">¶</a></h1>
<nav class="contents local" id="id1">
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id2">Introduction</a></p></li>
<li><p><a class="reference internal" href="#the-code-coverage-workflow" id="id3">The code coverage workflow</a></p></li>
<li><p><a class="reference internal" href="#compiling-with-coverage-enabled" id="id4">Compiling with coverage enabled</a></p></li>
<li><p><a class="reference internal" href="#running-the-instrumented-program" id="id5">Running the instrumented program</a></p></li>
<li><p><a class="reference internal" href="#creating-coverage-reports" id="id6">Creating coverage reports</a></p></li>
<li><p><a class="reference internal" href="#format-compatibility-guarantees" id="id7">Format compatibility guarantees</a></p></li>
<li><p><a class="reference internal" href="#using-the-profiling-runtime-without-static-initializers" id="id8">Using the profiling runtime without static initializers</a></p></li>
<li><p><a class="reference internal" href="#drawbacks-and-limitations" id="id9">Drawbacks and limitations</a></p></li>
</ul>
</nav>
<section id="introduction">
<h2><a class="toc-backref" href="#id2" role="doc-backlink">Introduction</a><a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p>This document explains how to use clang's source-based code coverage feature.
It's called &quot;source-based&quot; because it operates on AST and preprocessor
information directly. This allows it to generate very precise coverage data.</p>
<p>Clang ships two other code coverage implementations:</p>
<ul class="simple">
<li><p><a class="reference internal" href="SanitizerCoverage.html"><span class="doc">SanitizerCoverage</span></a> - A low-overhead tool meant for use alongside the
various sanitizers. It can provide up to edge-level coverage.</p></li>
<li><p>gcov - A GCC-compatible coverage implementation which operates on DebugInfo.</p></li>
</ul>
<p>From this point onwards &quot;code coverage&quot; will refer to the source-based kind.</p>
</section>
<section id="the-code-coverage-workflow">
<h2><a class="toc-backref" href="#id3" role="doc-backlink">The code coverage workflow</a><a class="headerlink" href="#the-code-coverage-workflow" title="Link to this heading">¶</a></h2>
<p>The code coverage workflow consists of three main steps:</p>
<ul class="simple">
<li><p>Compiling with coverage enabled.</p></li>
<li><p>Running the instrumented program.</p></li>
<li><p>Creating coverage reports.</p></li>
</ul>
<p>The next few sections work through a complete, copy-'n-paste friendly example
based on this program:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="w"> </span><span class="n">cat</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="n">EOF</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">foo</span><span class="p">.</span><span class="n">cc</span>
<span class="cp">#define BAR(x) ((x) || (x))</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">I</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">I</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">I</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">BAR</span><span class="p">(</span><span class="n">I</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>
<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">foo</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="n">foo</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EOF</span>
</pre></div>
</div>
</section>
<section id="compiling-with-coverage-enabled">
<h2><a class="toc-backref" href="#id4" role="doc-backlink">Compiling with coverage enabled</a><a class="headerlink" href="#compiling-with-coverage-enabled" title="Link to this heading">¶</a></h2>
<p>To compile code with coverage enabled, pass <code class="docutils literal notranslate"><span class="pre">-fprofile-instr-generate</span>
<span class="pre">-fcoverage-mapping</span></code> to the compiler:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>Step<span class="w"> </span><span class="m">1</span>:<span class="w"> </span>Compile<span class="w"> </span>with<span class="w"> </span>coverage<span class="w"> </span>enabled.
<span class="gp">% </span>clang++<span class="w"> </span>-fprofile-instr-generate<span class="w"> </span>-fcoverage-mapping<span class="w"> </span>foo.cc<span class="w"> </span>-o<span class="w"> </span>foo
</pre></div>
</div>
<p>Note that linking together code with and without coverage instrumentation is
supported: any uninstrumented code simply won't be accounted for.</p>
</section>
<section id="running-the-instrumented-program">
<h2><a class="toc-backref" href="#id5" role="doc-backlink">Running the instrumented program</a><a class="headerlink" href="#running-the-instrumented-program" title="Link to this heading">¶</a></h2>
<p>The next step is to run the instrumented program. When the program exits it
will write a <strong>raw profile</strong> to the path specified by the <code class="docutils literal notranslate"><span class="pre">LLVM_PROFILE_FILE</span></code>
environment variable. If that variable does not exist, the profile is written
to <code class="docutils literal notranslate"><span class="pre">default.profraw</span></code> in the current directory of the program. If
<code class="docutils literal notranslate"><span class="pre">LLVM_PROFILE_FILE</span></code> contains a path to a non-existent directory, the missing
directory structure will be created.  Additionally, the following special
<strong>pattern strings</strong> are rewritten:</p>
<ul class="simple">
<li><p>&quot;%p&quot; expands out to the process ID.</p></li>
<li><p>&quot;%h&quot; expands out to the hostname of the machine running the program.</p></li>
<li><p>&quot;%Nm&quot; expands out to the instrumented binary's signature. When this pattern
is specified, the runtime creates a pool of N raw profiles which are used for
on-line profile merging. The runtime takes care of selecting a raw profile
from the pool, locking it, and updating it before the program exits.  If N is
not specified (i.e the pattern is &quot;%m&quot;), it's assumed that <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">1</span></code>. N must
be between 1 and 9. The merge pool specifier can only occur once per filename
pattern.</p></li>
</ul>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>Step<span class="w"> </span><span class="m">2</span>:<span class="w"> </span>Run<span class="w"> </span>the<span class="w"> </span>program.
<span class="gp">% </span><span class="nv">LLVM_PROFILE_FILE</span><span class="o">=</span><span class="s2">&quot;foo.profraw&quot;</span><span class="w"> </span>./foo
</pre></div>
</div>
</section>
<section id="creating-coverage-reports">
<h2><a class="toc-backref" href="#id6" role="doc-backlink">Creating coverage reports</a><a class="headerlink" href="#creating-coverage-reports" title="Link to this heading">¶</a></h2>
<p>Raw profiles have to be <strong>indexed</strong> before they can be used to generate
coverage reports. This is done using the &quot;merge&quot; tool in <code class="docutils literal notranslate"><span class="pre">llvm-profdata</span></code>, so
named because it can combine and index profiles at the same time:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>Step<span class="w"> </span><span class="m">3</span><span class="o">(</span>a<span class="o">)</span>:<span class="w"> </span>Index<span class="w"> </span>the<span class="w"> </span>raw<span class="w"> </span>profile.
<span class="gp">% </span>llvm-profdata<span class="w"> </span>merge<span class="w"> </span>-sparse<span class="w"> </span>foo.profraw<span class="w"> </span>-o<span class="w"> </span>foo.profdata
</pre></div>
</div>
<p>There are multiple different ways to render coverage reports. One option is to
generate a line-oriented report:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>Step<span class="w"> </span><span class="m">3</span><span class="o">(</span>b<span class="o">)</span>:<span class="w"> </span>Create<span class="w"> </span>a<span class="w"> </span>line-oriented<span class="w"> </span>coverage<span class="w"> </span>report.
<span class="gp">% </span>llvm-cov<span class="w"> </span>show<span class="w"> </span>./foo<span class="w"> </span>-instr-profile<span class="o">=</span>foo.profdata
</pre></div>
</div>
<p>To demangle any C++ identifiers in the output, use:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">% </span>llvm-cov<span class="w"> </span>show<span class="w"> </span>./foo<span class="w"> </span>-instr-profile<span class="o">=</span>foo.profdata<span class="w"> </span><span class="p">|</span><span class="w"> </span>c++filt<span class="w"> </span>-n
</pre></div>
</div>
<p>This report includes a summary view as well as dedicated sub-views for
templated functions and their instantiations. For our example program, we get
distinct views for <code class="docutils literal notranslate"><span class="pre">foo&lt;int&gt;(...)</span></code> and <code class="docutils literal notranslate"><span class="pre">foo&lt;float&gt;(...)</span></code>.  If
<code class="docutils literal notranslate"><span class="pre">-show-line-counts-or-regions</span></code> is enabled, <code class="docutils literal notranslate"><span class="pre">llvm-cov</span></code> displays sub-line
region counts (even in macro expansions):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>   20|    1|#define BAR(x) ((x) || (x))
                           ^20     ^2
    2|    2|template &lt;typename T&gt; void foo(T x) {
   22|    3|  for (unsigned I = 0; I &lt; 10; ++I) { BAR(I); }
                                   ^22     ^20  ^20^20
    2|    4|}
------------------
| void foo&lt;int&gt;(int):
|      1|    2|template &lt;typename T&gt; void foo(T x) {
|     11|    3|  for (unsigned I = 0; I &lt; 10; ++I) { BAR(I); }
|                                     ^11     ^10  ^10^10
|      1|    4|}
------------------
| void foo&lt;float&gt;(int):
|      1|    2|template &lt;typename T&gt; void foo(T x) {
|     11|    3|  for (unsigned I = 0; I &lt; 10; ++I) { BAR(I); }
|                                     ^11     ^10  ^10^10
|      1|    4|}
------------------
</pre></div>
</div>
<p>It's possible to generate a file-level summary of coverage statistics (instead
of a line-oriented report) with:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>Step<span class="w"> </span><span class="m">3</span><span class="o">(</span>c<span class="o">)</span>:<span class="w"> </span>Create<span class="w"> </span>a<span class="w"> </span>coverage<span class="w"> </span>summary.
<span class="gp">% </span>llvm-cov<span class="w"> </span>report<span class="w"> </span>./foo<span class="w"> </span>-instr-profile<span class="o">=</span>foo.profdata
<span class="go">Filename                    Regions    Miss   Cover Functions  Executed</span>
<span class="go">-----------------------------------------------------------------------</span>
<span class="go">/tmp/foo.cc                      13       0 100.00%         3   100.00%</span>
<span class="go">-----------------------------------------------------------------------</span>
<span class="go">TOTAL                            13       0 100.00%         3   100.00%</span>
</pre></div>
</div>
<p>A few final notes:</p>
<ul>
<li><p>The <code class="docutils literal notranslate"><span class="pre">-sparse</span></code> flag is optional but can result in dramatically smaller
indexed profiles. This option should not be used if the indexed profile will
be reused for PGO.</p></li>
<li><p>Raw profiles can be discarded after they are indexed. Advanced use of the
profile runtime library allows an instrumented program to merge profiling
information directly into an existing raw profile on disk. The details are
out of scope.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">llvm-profdata</span></code> tool can be used to merge together multiple raw or
indexed profiles. To combine profiling data from multiple runs of a program,
try e.g:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">% </span>llvm-profdata<span class="w"> </span>merge<span class="w"> </span>-sparse<span class="w"> </span>foo1.profraw<span class="w"> </span>foo2.profdata<span class="w"> </span>-o<span class="w"> </span>foo3.profdata
</pre></div>
</div>
</li>
</ul>
</section>
<section id="format-compatibility-guarantees">
<h2><a class="toc-backref" href="#id7" role="doc-backlink">Format compatibility guarantees</a><a class="headerlink" href="#format-compatibility-guarantees" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p>There are no backwards or forwards compatibility guarantees for the raw
profile format. Raw profiles may be dependent on the specific compiler
revision used to generate them. It's inadvisable to store raw profiles for
long periods of time.</p></li>
<li><p>Tools must retain <strong>backwards</strong> compatibility with indexed profile formats.
These formats are not forwards-compatible: i.e, a tool which uses format
version X will not be able to understand format version (X+k).</p></li>
<li><p>There is a third format in play: the format of the coverage mappings emitted
into instrumented binaries. Tools must retain <strong>backwards</strong> compatibility
with these formats. These formats are not forwards-compatible.</p></li>
</ul>
</section>
<section id="using-the-profiling-runtime-without-static-initializers">
<h2><a class="toc-backref" href="#id8" role="doc-backlink">Using the profiling runtime without static initializers</a><a class="headerlink" href="#using-the-profiling-runtime-without-static-initializers" title="Link to this heading">¶</a></h2>
<p>By default the compiler runtime uses a static initializer to determine the
profile output path and to register a writer function. To collect profiles
without using static initializers, do this manually:</p>
<ul class="simple">
<li><p>Export a <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">__llvm_profile_runtime</span></code> symbol from each instrumented shared
library and executable. When the linker finds a definition of this symbol, it
knows to skip loading the object which contains the profiling runtime's
static initializer.</p></li>
<li><p>Forward-declare <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__llvm_profile_initialize_file(void)</span></code> and call it
once from each instrumented executable. This function parses
<code class="docutils literal notranslate"><span class="pre">LLVM_PROFILE_FILE</span></code>, sets the output path, and truncates any existing files
at that path. To get the same behavior without truncating existing files,
pass a filename pattern string to <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__llvm_profile_set_filename(char</span>
<span class="pre">*)</span></code>.  These calls can be placed anywhere so long as they precede all calls
to <code class="docutils literal notranslate"><span class="pre">__llvm_profile_write_file</span></code>.</p></li>
<li><p>Forward-declare <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">__llvm_profile_write_file(void)</span></code> and call it to write
out a profile. This function returns 0 when it succeeds, and a non-zero value
otherwise. Calling this function multiple times appends profile data to an
existing on-disk raw profile.</p></li>
</ul>
</section>
<section id="drawbacks-and-limitations">
<h2><a class="toc-backref" href="#id9" role="doc-backlink">Drawbacks and limitations</a><a class="headerlink" href="#drawbacks-and-limitations" title="Link to this heading">¶</a></h2>
<ul>
<li><p>Code coverage does not handle unpredictable changes in control flow or stack
unwinding in the presence of exceptions precisely. Consider the following
function:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">f</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">may_throw</span><span class="p">();</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If the call to <code class="docutils literal notranslate"><span class="pre">may_throw()</span></code> propagates an exception into <code class="docutils literal notranslate"><span class="pre">f</span></code>, the code
coverage tool may mark the <code class="docutils literal notranslate"><span class="pre">return</span></code> statement as executed even though it is
not. A call to <code class="docutils literal notranslate"><span class="pre">longjmp()</span></code> can have similar effects.</p>
</li>
</ul>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="Bottom">
      
        <p>
        «&#160;&#160;<a href="SafeStack.html">SafeStack</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">目录</a>
        &#160;&#160;::&#160;&#160;
        <a href="Modules.html">Modules</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
    &#169; 版权所有 2007-2026, The Clang Team.
      由 <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3创建。
    </div>
  </body>
</html>